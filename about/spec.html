<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>Clojure - clojure.spec - 論理的根拠と概要</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clojure の日本語ドキュメントです">
    <meta name="author" content="Japan Clojurians">
    <meta name="keywords" content="Clojure 日本語">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/normalize.css" rel="stylesheet">
    <link href="../css/webflow.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" type="image/x-icon" href="../images/clojure-logo-icon-32.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">Clojure</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../about/rationale.html">概要</a></li>
            <li><a href="../reference/documentation">リファレンス</a></li>
            <!-- <li><a href="../api/api.html">API</a></li>
              <li><a href="../community/downloads.html">リリース</a></li> -->
              <li><a href="../guides/guides.html">ガイド</a></li>
            <!-- <li><a href="../community/resources.html">コミュニティ</a></li>
              <li><a href="../news/news.html">ニュース</a></li>
              <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
              <li><a href="#">Action</a></li>
              <li><a href="#">Another action</a></li>
              <li><a href="#">Something else here</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Nav header</li>
              <li><a href="#">Separated link</a></li>
              <li><a href="#">One more separated link</a></li>
              </ul>
              </li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

<div class="page-header">
  <h1>clojure.spec - 論理的根拠と概要</h1>
</div>

<p><em></em></p>

<p><div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_問題">問題</a>
<ul class="sectlevel2">
<li><a href="#_docsでは十分ではない">docsでは十分ではない</a></li>
<li><a href="#_マップのspecはキーセットのみで構成されるべきだ">マップのspecはキーセットのみで構成されるべきだ</a></li>
<li><a href="#_手動でのパース処理やエラー報告は十分に良いものではない">手動でのパース処理やエラー報告は十分に良いものではない</a></li>
<li><a href="#_生成的テストと頑健性">生成的テストと頑健性</a></li>
<li><a href="#_標準的なアプローチが必要だ">標準的なアプローチが必要だ</a></li>
</ul>
</li>
<li><a href="#_目的">目的</a>
<ul class="sectlevel2">
<li><a href="#_コミュニケーション">コミュニケーション</a></li>
<li><a href="#_あらゆるコンテキストにおける仕様記述を統一">あらゆるコンテキストにおける仕様記述を統一</a></li>
<li><a href="#_仕様記述の労力を最大限に活用する">仕様記述の労力を最大限に活用する</a></li>
<li><a href="#_侵入を最小化">侵入を最小化</a></li>
<li><a href="#_マップ_キー_値を分離する">マップ、キー、値を分離する</a></li>
<li><a href="#_意味の変更と互換性に関する対話を可能にし_開始する">意味の変更と互換性に関する対話を可能にし、開始する</a></li>
</ul>
</li>
<li><a href="#_ガイドライン">ガイドライン</a>
<ul class="sectlevel2">
<li><a href="#_ミスは起こりうる">ミスは起こりうる</a></li>
<li><a href="#_表現力_証明">表現力 &gt; 証明</a></li>
<li><a href="#_名前は重要だ">名前は重要だ</a></li>
<li><a href="#_グローバルな_ネームスペース付きの_名前はより重要だ">グローバルな(ネームスペース付きの)名前はより重要だ</a></li>
<li><a href="#_clojureの_実体化された_ネームスペースにさらに追加し_負担をかけすぎてはならない">Clojureの(実体化された)ネームスペースにさらに追加し/負担をかけすぎてはならない</a></li>
<li><a href="#_コードはデータだ_逆ではない">コードはデータだ(逆ではない)</a></li>
<li><a href="#_セット_マップ_は所属関係に関するもの_それだけだ">セット(マップ)は所属関係に関するもの、それだけだ</a></li>
<li><a href="#_情報的_vs_実装的">情報的 vs 実装的</a></li>
<li><a href="#_k_i_s_s">K.I.S.S.</a></li>
<li><a href="#_test_checkの上に構築するが_その知識は要求しない">test.checkの上に構築するが、その知識は要求しない</a></li>
</ul>
</li>
<li><a href="#_特徴">特徴</a>
<ul class="sectlevel2">
<li><a href="#_概要">概要</a></li>
<li><a href="#_specを定義する">specを定義する</a></li>
<li><a href="#_specを使う">specを使う</a></li>
</ul>
</li>
<li><a href="#_用語集">用語集</a>
<ul class="sectlevel2">
<li><a href="#_predicates_述語">predicates (述語)</a></li>
<li><a href="#_specs_仕様記述">specs (仕様記述)</a></li>
<li><a href="#_regex_ops_正規表現演算子">regex ops (正規表現演算子)</a></li>
<li><a href="#_conform_一致させる">conform (一致させる)</a></li>
<li><a href="#_explain_説明する">explain (説明する)</a></li>
<li><a href="#_paths_パス">paths (パス)</a></li>
</ul>
</li>
<li><a href="#_先行技術">先行技術</a></li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_問題">問題</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_docsでは十分ではない">docsでは十分ではない</h3>
<div class="paragraph">
<p>Clojureは動的言語だ。何よりこれは型アノテーションがコードの実行に必要とされないことを意味する。Clojureは型ヒントをいくらかサポートしているが、型ヒントは強制のメカニズムではなく、網羅的でもなく、効率的なコード生成を支援するためコンパイラに情報を伝えることに限定されている。ClojureはJVM自身による豊富な型に対する実行時チェックの恩恵を受けている。</p>
</div>
<div class="paragraph">
<p>しかし、情報をデータとしてシンプルに表現することが常にコミュニティで広く評価され実践されてきたClojureの指針だった。したがって、Clojureシステムの重要なプロパティはデータの形状やその他の述語的なプロパティによって表現され伝達され、実行時の型は区別の付かない異種の型が混在するマップやベクターであるため、それ以外で捕捉されたりチェックされたりすることはない。</p>
</div>
<div class="paragraph">
<p>ドキュメンテーション文字列は人間の利用者とのコミュニケーションに利用可能だが、プログラムやテストで活用することはできない、つまり最小限の力しか持っていないのだ。ユーザーはより強力な仕様記述を得るために
<a href="https://github.com/plumatic/schema">Schema</a> や
<a href="https://github.com/miner/herbert">Herbert</a> のような様々なライブラリを頼ってきた。</p>
</div>
</div>
<div class="sect2">
<h3 id="_マップのspecはキーセットのみで構成されるべきだ">マップのspecはキーセットのみで構成されるべきだ</h3>
<div class="paragraph">
<p>構造を記述するためのたいていのシステムではキーのセットに関する仕様(例えばマップのキーやオブジェクトのフィールドに関するもの)とそうしたキーが指し示す値に関する仕様を混同している。つまり、そうしたアプローチではあるマップに対するスキーマは:a-keyの型がx-typeで:b-keyの型がy-typeだと言うかもしれない。これは硬直性と冗長性の大きな原因だ。</p>
</div>
<div class="paragraph">
<p>Clojureではマップを動的に合成し、マージし、構築することによって力を得ている。日常的に選択的なデータや部分的なデータ、信頼できない外部ソースから生み出されたデータ、動的なクエリなどを扱っている。こうしたマップは同一のキーの様々な集合や部分集合、共通部分、和集合を表し、一般に同一のキーはどこで使われても同一の意味を持つ必要がある。あらゆる部分集合/和集合/共通部分に対する仕様を定義し、そして個々のキーの意味を冗長に述べるというのは、たいていの動的なケースでアンチパターンであり上手く機能するものでもない。</p>
</div>
</div>
<div class="sect2">
<h3 id="_手動でのパース処理やエラー報告は十分に良いものではない">手動でのパース処理やエラー報告は十分に良いものではない</h3>
<div class="paragraph">
<p>多くのユーザー、特に初心者は、とりわけ2つの実行コンテキストがあるマクロ(マクロのコンパイル時の実行と実行時の展開はどちらもユーザーエラーのために失敗しうる)において、手書きのパース処理やコードの分配束縛により生成されるエラーメッセージにフラストレーションを覚えたり困難に直面したりしている。これは「マクロ文法」の必要性につながっているが、実際にはマクロはデータ&#8594;データの関数にすぎず、データのバリデーションや分配束縛のためのあらゆる解決策はその他の関数と同様にマクロにも機能するはずだ。つまり、マクロは上記の問題の一例だといえる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_生成的テストと頑健性">生成的テストと頑健性</h3>
<div class="paragraph">
<p>最後に、動的でもそうでなくてもすべての言語において、テストは品質に不可欠なものだ。あまりにも多くの重要なプロパティが一般的な型システムでは捕捉されない。しかし手動でのテストは労力に対する効果の割合が非常に低い。
<a href="https://github.com/clojure/test.check">test.check</a>
でClojure向けに実装されているような、プロパティベースの生成的テストは手書きのテストよりもずっと強力であることが分かってきた。</p>
</div>
<div class="paragraph">
<p>それでも、プロパティベーストテストはプロパティの定義が必要となり、それにはそれを生み出すためのさらなる労力と熟練が必要となり、そうした定義は関数のレベルでは関数の仕様記述と大きな重複がある。関数のレベルでの多くの興味深いプロパティがすでに構造的+述語的なspecによって捕捉されているだろう。理想的には、specは生成的テストと統合し、ある種の生成的テストを「ただで」提供するべきだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_標準的なアプローチが必要だ">標準的なアプローチが必要だ</h3>
<div class="paragraph">
<p>要するに、Clojureには仕様記述とテストのための標準的で表現力のある強力で統合されたシステムがないのだ。</p>
</div>
<div class="paragraph">
<p><strong>clojure.spec</strong> はそれを提供することを目指している。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_目的">目的</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_コミュニケーション">コミュニケーション</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Species - appearance, form, sort, kind, equivalent to spec (ere) to look,
regard<br>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+
-iēs abstract noun suffix</p>
</div>
<div class="paragraph">
<p>Specify - species + -ficus -fic (make)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>仕様(specification)とはあるものがどう「見える」かに関するものだが、最も重要なのは、見られるものだ。specは、読みやすく、プログラマがすでに使っている「単語」(述語関数)で構成され、ドキュメンテーションに統合されているべきだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_あらゆるコンテキストにおける仕様記述を統一">あらゆるコンテキストにおける仕様記述を統一</h3>
<div class="paragraph">
<p>データ構造や属性値、関数のためのspecはすべて同じであるべきであり、グローバルにネームスペースの付いたディレクトリにあるべきだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_仕様記述の労力を最大限に活用する">仕様記述の労力を最大限に活用する</h3>
<div class="paragraph">
<p>specを書くことで以下のことが <em>自動的</em> に可能になるべきだ:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>バリデーション</p>
</li>
<li>
<p>エラー報告</p>
</li>
<li>
<p>分配束縛</p>
</li>
<li>
<p>specの組み込み(instrumentation)</p>
</li>
<li>
<p>テストデータ生成</p>
</li>
<li>
<p>生成的テストの生成</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_侵入を最小化">侵入を最小化</h3>
<div class="paragraph">
<p>例えば関数を異なる方法で定義することを要求してはならない。 <code>doc</code> と <code>macroexpand</code>
への小さな変更によって、独立して書かれたspecが再定義することなくfn/macroの振る舞いを修飾することが可能になる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_マップ_キー_値を分離する">マップ、キー、値を分離する</h3>
<div class="paragraph">
<p>マップ(キーセット)のspecを属性(キー&#8594;値)のspecから分けておこう。ネームスペース付きのキーワードから値へのspecという、属性の粒度でのspecを推奨しサポートしよう。(マップの仕様を記述するために)キーを組み合わせてセットにすることが直交的になり、完全に動的なケースでのチェックが可能になる、つまりマップのspecが存在しない場合でさえ、属性(キー-値)はチェックできる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_意味の変更と互換性に関する対話を可能にし_開始する">意味の変更と互換性に関する対話を可能にし、開始する</h3>
<div class="paragraph">
<p>プログラマは名前を同じにしたままで再定義する時に大いに苦しめられる。変更のいくらかは互換性があるが、いくらかは破壊的で、たいていのツールはそれを区別することができない。互換性が判断できるようにセットの所属関係や正規表現のような構造を利用し、(一般的な述語による等価性は除外して)互換性チェックのためのツールを提供しよう。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ガイドライン">ガイドライン</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ミスは起こりうる">ミスは起こりうる</h3>
<div class="paragraph">
<p>私たちはミスを起こしえない世界で生きているわけではない(そうすることもできないだろう)。その代わりに、私たちは定期的にミスしていないことをチェックするのだ。Amazonは
<code>UPS&lt;Trucks&lt;Boxes&lt;TV&gt;&gt;&gt;</code>
経由でテレビを送ってくるわけではない。そのため時には電子レンジを受け取ることもあるかもしれないが、サプライチェーンが正確性を証明する責任を負っているわけではない。その代わりに私たちが終端でチェックしてテストするのだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_表現力_証明">表現力 &gt; 証明</h3>
<div class="paragraph">
<p>主に型システムがしているのはそれなのだが、仕様記述を証明可能なものに制限する理由はない。システムについてコミュニケーションを取り、正しさを確かめたいことはもっとたくさんある。これは、例えば定義域を狭めたり複数の入力の間の関係や入力と出力の間の関係を詳細に述べる、構造的/表象的な型や述語に対するタグ付け以上のものだ。加えて、私たちが最も気にするプロパティは多くの場合実行時の値に関するプロパティであり、静的な概念のようなものではない。そういうわけで
<strong>spec</strong> は型システムではない。</p>
</div>
</div>
<div class="sect2">
<h3 id="_名前は重要だ">名前は重要だ</h3>
<div class="paragraph">
<p>あらゆるプログラムは(型システムが使わない場合でさえ)名前を使い、名前は重要な意味を捉えている。 <code>Int x Int x Int</code>
は十分に良いものではない(長さ/幅/高さ なのか 高さ/幅/奥行き なのか?)。そのため、 <strong>spec</strong>
にはラベルなしのシーケンス要素やタグ付けされていない和集合の束縛はない。このことの効用は、 <strong>spec</strong>
がspecについてユーザーに何か言わければならない時、例えばエラー報告する場合、また逆に、例えばユーザーがspecのジェネレータをオーバーライドしたい場合に明らかになる。すべての分岐に名前が付いていれば、
<em>paths</em> を使ってspecの部分について言うことができる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_グローバルな_ネームスペース付きの_名前はより重要だ">グローバルな(ネームスペース付きの)名前はより重要だ</h3>
<div class="paragraph">
<p>Clojureはネームスペース付きのキーワードとシンボルをサポートしている。ここではネームスペースで修飾された名前のことを言っているのであって、Clojureのネームスペースオブジェクトのことを言っているわけではないことに注意しよう。これらは悲しいことにあまり活用されていないが、ディクショナリ/db/マップ/セットの中で衝突することなく常に共存することができるため、重要な利益をもたらす。
<strong>spec</strong>
はspecを名付けるのにネームスペース付きのキーワードとシンボル(だけ)を認めている。ネームスペース付きのキーを情報を持ったマップのために使う(広まってほしい習慣だ)と、マップの属性のためのspecを直接マップのキーの名前で登録することができる。このことは、とりわけ動的な状況において、マップというものの自己記述を絶対的に変えることになり、合成や一貫性を促進することになる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_clojureの_実体化された_ネームスペースにさらに追加し_負担をかけすぎてはならない">Clojureの(実体化された)ネームスペースにさらに追加し/負担をかけすぎてはならない</h3>
<div class="paragraph">
<p>varやメタデータなどには何も付加されない。すべての関数にはネームスペース付きの名前があり、それは別のどこかに格納された関連するデータ(例えばspec)へのキーとして働く。</p>
</div>
</div>
<div class="sect2">
<h3 id="_コードはデータだ_逆ではない">コードはデータだ(逆ではない)</h3>
<div class="paragraph">
<p>Lisp(したがってClojure)では、コードはデータだ。しかし、データはそれに関する言語を定義するまでコードではない。この領域での多くのDSLはスキーマのデータ表現に向かっている。しかし、述語的なspecには開かれた大きな語彙があり、便利な述語の多くがすでに存在し、coreやその他のネームスペースの関数としてよく知られている、もしくはシンプルな式として書くことができる。こうしたあらゆる述語を「データ化」する、あるいは名前を付け直さなければならないことによって得られる価値はほとんどなく、正確な意味を理解するのに明確なコストがある。
<strong>spec</strong>
ではむしろ、もともとの述語と式が最初からデータであるという事実を活用して、ドキュメンテーションやエラー報告でのユーザーとのコミュニケーションで利用するためにそうしたデータを捉えている。そう、
<code>clojure.spec</code> の表層領域の多くはマクロになるが、specは圧倒的に人によって書かれ、組み合わせる時も手で行うということだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_セット_マップ_は所属関係に関するもの_それだけだ">セット(マップ)は所属関係に関するもの、それだけだ</h3>
<div class="paragraph">
<p>上述の通り、キーの値についての詳細を定義したマップは、根本的な関心の絡まり(complecting)であり、支持できないものだ。マップのspecは必須/オプションのキー(つまりセットの所属関係)について詳しく述べるが、キーワード/属性/値の意味は独立している。マップのチェックは、必須のキーの存在、そしてキー/値の一致という2フェーズだ。後者は、実行時に存在する(ネームスペース修飾された)キーがマップのspecにない場合でさえ行うことができる。これは合成と動的な性質のために極めて重要なものだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_情報的_vs_実装的">情報的 vs 実装的</h3>
<div class="paragraph">
<p>いつでも、人は仕様記述システムを実装の決定について詳述するのに利用しようとするが、そうすることによって自らに損害を与えている。最も良く最も有用なspec(とインターフェース)は純粋に情報の側面に関するものだ。情報のspecだけがネットワークを越えてシステムを横断して機能する。私たちは情報のアプローチを常に優先し、対立がある場合にはそちらを好むだろう。</p>
</div>
</div>
<div class="sect2">
<h3 id="_k_i_s_s">K.I.S.S.</h3>
<div class="paragraph">
<p>この領域には基礎的な概念が非常に少ないが、私たちはそれらにこだわる努力をする。固有の構造的な概念は少ない。少数のアトミックな型、シーケンシャルなもの、セット、マップだ。驚くに当たらないことだが、これらはClojureのデータ型であり、基礎的なオペレータはこれらに対してのみ提供される。同様に、これらについて言うための数学的なツールがあり(マップに対する集合論理、シーケンスに対する正規表現)、価値のある性質を備えている。私たちはアドホックな解決策よりもこれらを好むだろう。</p>
</div>
</div>
<div class="sect2">
<h3 id="_test_checkの上に構築するが_その知識は要求しない">test.checkの上に構築するが、その知識は要求しない</h3>
<div class="paragraph">
<p><strong>spec</strong> を土台とした生成的テストは <code>test.check</code>
を活用し、再発明はしない。しかし、specのユーザーは、自分自身でジェネレータを書きたかったり、さらなるプロパティベーストテストで <strong>spec</strong>
が生成したテストを補いたかったりするのでない限り、 <code>test.check</code> について何も知る必要がないようにするべきだ。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_特徴">特徴</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_概要">概要</h3>
<div class="sect3">
<h4 id="_述語的なspec">述語的なspec</h4>
<div class="paragraph">
<p>基本的なアイディアは、specは単なる述語の論理的な組み合わせにすぎないというものだ。根底では、 <code>int?</code> や <code>symbol?</code>
、自分で組み立てた式 <code>#(&lt; 42 % 66)</code> のような、慣れたシンプルなbooleanの述語について言っているのだ。 <strong>spec</strong> は
<code>spec/and</code> と <code>spec/or</code>
のような論理演算子を追加しており、論理的な方法でspecを組み合わせ、深いところまでの報告、生成、conformのサポート、 <code>spec/or</code>
のケースではタグ付きの戻り値を提供する。</p>
</div>
</div>
<div class="sect3">
<h4 id="_マップ">マップ</h4>
<div class="paragraph">
<p>マップのキーセットのためのspecは、必須とオプションのキーのセットについての仕様記述を提供する。あるマップに対するspecは、キーの名前のベクターに対応付けた
<code>:req</code> と <code>:opt</code> キーワード引数で <code>keys</code> を呼び出すことで生成される。</p>
</div>
<div class="paragraph">
<p><code>:req</code> のキーは論理演算子 <code>and</code> と <code>or</code> をサポートしている。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(spec/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>spec</strong> と他のシステムとの間で最も見た目に明らかな違いのひとつは、マップのspecに(例えば <code>::x</code> がとりうる) <em>値</em>
について記述する場所がないことだ。これは、 <code>:my.ns/k</code>
のようなネームスペース付きのキーワードに関連付けられた値の仕様はそのキーワード自体に登録され、そのキーワードが現れるあらゆるマップに適用されるべきだという
<strong>spec</strong> の(強制的な)主張だ。これにはいくつもの利点がある:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>すべての利用で意味が共有されるべきアプリケーション内で、そのキーワードのすべての利用に一貫性を保証する</p>
</li>
<li>
<p>同様に、ライブラリとその利用者との間の一貫性を保証する</p>
</li>
<li>
<p>そうでなければ多くのマップのspecがkについて同じ宣言をする必要があるため、冗長さを減らすことになる</p>
</li>
<li>
<p>ネームスペース付きキーワードのspecはマップのspecがそのキーを宣言していない時でさえチェックされる</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>この最後の点はマップを動的に構築し、合成し、生成する場合に極めて重要だ。あらゆるマップの部分集合/和集合/共通部分にspecを作るというのは上手くいかない。利用される時ではなく入ってきた時にフェイルファストで悪いデータを検知することも容易になる。</p>
</div>
<div class="paragraph">
<p>もちろん、多くの既存のマップベースのインターフェースはネームスペースなしのキーをとっている。正しくネームスペースが付いて再利用可能なspecとの接続をサポートするため、
<code>keys</code> は <code>:req</code> と <code>:opt</code> の <code>-un</code> 変種をサポートしている。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(spec/keys :req-un [:my.ns/a :my.ns/b])</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、非修飾のキー <code>:a</code> と <code>:b</code> を要求するが、それぞれ <code>:my.ns/a</code> と <code>:my.ns/b</code>
という名前のspecを(定義されている場合に)利用してバリデーションと生成を行うマップを記述している。これは非修飾のキーワードがネームスペース付きキーワードが持つのと同等の力を伝えることはできないことに注意しよう。結果として得られるマップは自己記述的ではないのだ。</p>
</div>
</div>
<div class="sect3">
<h4 id="_シーケンス">シーケンス</h4>
<div class="paragraph">
<p>シーケンス/ベクターのためのspecは、正規表現の標準的なセマンティクスで一連の標準的な正規表現演算子を利用する:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cat</code> - 述語/パターンの連結</p>
</li>
<li>
<p><code>alt</code> - 一連の述語/パターンから1つの選択</p>
</li>
<li>
<p><code>*</code> - 述語/パターンの0回以上の出現</p>
</li>
<li>
<p><code>+</code> - 1以上</p>
</li>
<li>
<p><code>?</code> - 1または0</p>
</li>
<li>
<p><code>&amp;</code> - 正規表現演算子をとり、1個以上の述語でさらに制約する</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらは任意にネストして複合的な式を形成する。</p>
</div>
<div class="paragraph">
<p><code>cat</code> と <code>alt</code>
はすべての構成要素がラベル付けされていることを要求し、それぞれ戻り値はマッチした構成要素に対応するキーのマップであることに注意しよう。このように
<strong>spec</strong> の正規表現は分配束縛やパース処理のツールとして振る舞う。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user=&gt; (require '[clojure.spec.alpha :as s])
(s/def ::even? (s/and integer? even?))
(s/def ::odd? (s/and integer? odd?))
(s/def ::a integer?)
(s/def ::b integer?)
(s/def ::c integer?)
(def s (s/cat :forty-two #{42}
              :odds (s/+ ::odd?)
              :m (s/keys :req-un [::a ::b ::c])
              :oes (s/* (s/cat :o ::odd? :e ::even?))
              :ex (s/alt :odd ::odd? :even ::even?)))
user=&gt; (s/conform s [42 11 13 15 {:a 1 :b 2 :c 3} 1 2 3 42 43 44 11])
{:forty-two 42,
 :odds [11 13 15],
 :m {:a 1, :b 2, :c 3},
 :oes [{:o 1, :e 2} {:o 3, :e 42} {:o 43, :e 44}],
 :ex {:odd 11}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_conform_explain">conform/explain</h4>
<div class="paragraph">
<p>上で見た通り、specを使うための基本操作は <code>conform</code> で、specと値をとって一致した値、もしくは値が一致しなかった場合には
<code>:clojure.spec.alpha/invalid</code> を返す。値が一致しない時には <code>explain</code> または
<code>explain-data</code> を呼び出してなぜ一致しなかったのか調べることができる。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_specを定義する">specを定義する</h3>
<div class="paragraph">
<p>specを定義するための主要な操作はs/def, s/and, s/or, s/keysと正規表現演算子だ。
述語関数または式、セット、もしくは正規表現演算子をとり、述語が暗示するジェネレータをオーバーライドするオプションのジェネレータをとることもできる
<code>spec</code> 関数がある。</p>
</div>
<div class="paragraph">
<p>しかし、 <code>def, and, or, keys</code> のspec関数と正規表現演算子はいずれも述語関数とセットを直接とって使うことができ、
<code>spec</code> でラップする必要はないことに注意しよう。 <code>spec</code>
はジェネレータをオーバーライドしたい場合やネストした正規表現が同じパターンに含まれるのではなく新しいパターンを開始するように記述したい場合にのみ必要となるはずだ。</p>
</div>
<div class="sect3">
<h4 id="_データspecの登録">データspecの登録</h4>
<div class="paragraph">
<p>specを名前で再利用できるようにするためには、 <code>def</code> によって登録しなければならない。 <code>def</code>
はネームスペース付きのキーワード/シンボルとspec/述語の式をとる。規約により、データのためのspecはキーワードに登録し、属性値はその属性名のキーワードに登録するべきだ。ひとたび登録すれば、specの名前はあらゆる
<strong>spec</strong> 操作でのspec/述語が必要なあらゆる場所で利用することができる。</p>
</div>
</div>
<div class="sect3">
<h4 id="_関数specの登録">関数specの登録</h4>
<div class="paragraph">
<p>関数は3つのspecで完全に記述することができる。引数のspec、戻り値のspec、引数を戻り値に対応付ける関数の操作のspecだ。</p>
</div>
<div class="paragraph">
<p>関数の引数のspecは常に引数がリスト、つまり <code>apply</code>
関数に渡すリストであるかのように記述する正規表現になる。これによって、単一のspecが複数のアリティを持つ関数を扱うことができる。</p>
</div>
<div class="paragraph">
<p>戻り値のspecは単一の値についての任意のspecだ。</p>
</div>
<div class="paragraph">
<p>(オプションの)関数のspecは引数と戻り値の関係、つまりその関数の機能についてのさらなる仕様記述だ。これは(例えばテスト時に) <code>{:args
conformed-args :ret conformed-ret}</code>
の入ったマップを受け取り、それらの値について説明する述語を一般に含むだろう。例えば入力のマップのすべてのキーが戻り値のマップに存在することを保証することができるだろう。</p>
</div>
<div class="paragraph">
<p>ある関数の3つすべてのspecを <code>fdef</code> 一度の呼び出しで指定することができ、それらのspecは <code>fn-specs</code>
によって取り出すことができる。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_specを使う">specを使う</h3>
<div class="sect3">
<h4 id="_ドキュメンテーション">ドキュメンテーション</h4>
<div class="paragraph">
<p><code>fdef</code> によって定義された関数specは関数名に対して <code>doc</code> を呼び出すと現れる。specに対して <code>describe</code>
を呼び出すと、説明がフォームとして得られる。</p>
</div>
</div>
<div class="sect3">
<h4 id="_パース処理_分配束縛">パース処理/分配束縛</h4>
<div class="paragraph">
<p><code>conform</code> を実装の中で分配束縛/パース処理/エラーチェックのために直接使うことができる。 <code>conform</code>
は例えばマクロの実装やI/Oの境界で利用できる。</p>
</div>
</div>
<div class="sect3">
<h4 id="_開発中に">開発中に</h4>
<div class="paragraph">
<p><code>instrument</code> で関数とネームスペースに選択的に組み込むことができる。これは関数のvarを <code>:args</code>
specをテストするラップされたバージョンの関数に差し替える。 <code>uninstrument</code>は関数を元のバージョンに戻す。
<code>gen/sample</code> でインタラクティブなテストのためにデータを生成することができる。</p>
</div>
</div>
<div class="sect3">
<h4 id="_テストのために">テストのために</h4>
<div class="paragraph">
<p><code>check</code> でネームスペース全体に対して一連のspecによる生成的テストを実行することができる。 <code>gen</code>
を呼び出すことでtest.ckeck互換のspecのジェネレータを得ることができる。 <code>clojure.core</code>
のデータの述語の多くと対応するジェネレータとの間には組み込みで関連があり、 <strong>spec</strong>
の複合的な演算子はそこからどのようにジェネレータを組み立てるべきか分かっている。 specに対して <code>gen</code>
を呼び出して一部のサブツリーについてジェネレータを組み立てることができないと、その場所を示す例外がスローされる。
specに分からないものにジェネレータを提供するためにジェネレータを返す関数を
<code>spec</code>　に渡すことができ、また、specの1つ以上のサブパスで代わりになるジェネレータを提供するためのオーバーライドマップを <code>gen</code>
に渡すことができる。</p>
</div>
</div>
<div class="sect3">
<h4 id="_実行時に">実行時に</h4>
<div class="paragraph">
<p>上述の分配束縛のユースケースに加えて、 <code>conform</code> や <code>valid?</code>
を実行時のチェックを行いたい箇所でどこでも呼び出すことができ、また、プロダクションで実行することを想定したテストのための内部利用限定の軽量なspecを作ることができる。</p>
</div>
<div class="paragraph">
<p>さらなるサンプルと利用方法の情報は <a href="xref/../../../guides/spec">specガイド</a> と
<a href="https://clojure.github.io/spec.alpha/index.html">API docs</a> を参照。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_用語集">用語集</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_predicates_述語">predicates (述語)</h3>
<div class="paragraph">
<p>spec APIの多くの部分で&#8217;predicates'(述語)つまり&#8217;preds&#8217;が必要となる。こうした引数は以下のもので満たすことができる:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>述語(boolean)関数</p>
</li>
<li>
<p>セット</p>
</li>
<li>
<p>登録済みのspecの名前</p>
</li>
<li>
<p>spec(<code>cat</code>, <code>alt</code>, <code>*</code>, <code>+</code>, <code>?</code>, <code>&amp;</code> の戻り値)</p>
</li>
<li>
<p>正規表現演算子(<code>cat</code>, <code>alt</code>, <code>*</code>, <code>+</code>, <code>?</code>, <code>&amp;</code> の戻り値)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>独立した正規表現の述語を正規表現の中にネストさせたい場合には <code>spec</code>
の呼び出しの中にラップしなければならず、そうしなければネストしたパターンとみなされることに注意しよう。</p>
</div>
</div>
<div class="sect2">
<h3 id="_specs_仕様記述">specs (仕様記述)</h3>
<div class="paragraph">
<p><code>spec</code>, <code>and</code>, <code>or</code>, <code>keys</code> の戻り値。</p>
</div>
</div>
<div class="sect2">
<h3 id="_regex_ops_正規表現演算子">regex ops (正規表現演算子)</h3>
<div class="paragraph">
<p><code>cat</code>, <code>alt</code>, <code>*</code>, <code>+</code>, <code>?</code>, <code>&amp;</code> の戻り値。ネストするとこれらは単一の式になる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conform_一致させる">conform (一致させる)</h3>
<div class="paragraph">
<p><code>conform</code>
はspecを利用する基本的な操作で、バリデーションと一致(conform)/分配束縛の両方を行う。conformは&#8217;deep&#8217;であり、すべてのspecと正規表現演算、マップのspecなどにわたることに注意しよう。
<code>nil</code> と <code>false</code> はconformした値として正当なものなため、値がconformできない場合には特別な
<code>:clojure.spec.alpha/invalid</code> が返される。</p>
</div>
</div>
<div class="sect2">
<h3 id="_explain_説明する">explain (説明する)</h3>
<div class="paragraph">
<p>ある値がspecのconformに失敗する場合には、同じspec+値で <code>explain</code> または <code>explain-data</code>
を呼び出して原因を調べることができる。こうした説明は、追加の作業をすることになるかもしれず、失敗しない入力やレポートが望ましくない場合にまでそのコストを負担する理由もないため、
<code>conform</code> 時には生成されない。説明の重要な構成要素は <em>パス</em> だ。 <code>explain</code>
は例えばネストしたマップや正規表現パターンを通るにつれてパスを伸ばしていくため、単なる全体もしくは葉の値よりも良い情報が得られる。
<code>explain-data</code> は問題箇所までのパスのマップを返す。</p>
</div>
</div>
<div class="sect2">
<h3 id="_paths_パス">paths (パス)</h3>
<div class="paragraph">
<p>例えばマップの <code>keys</code> や <code>or</code> と <code>alt</code> の選択肢、(省略されうる) <code>cat</code> の要素のようにspecのすべての
<em>分岐</em> 点はラベル付けされていることから、specのあらゆる部分式はその部分に名前を付ける <em>パス</em>
(キーのベクター)によって指し示すことができる。こうしたパスは <code>explain</code> や <code>gen</code>
のオーバーライド、様々なエラー報告に利用されている。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_先行技術">先行技術</h2>
<div class="sectionbody">
<div class="paragraph">
<p>specにはほとんど何も新規なところはない。上で述べたライブラリや
<a href="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">RDF</a>
、また、コントラクトシステムについてなされてきた様々な業績、例えば
<a href="https://docs.racket-lang.org/guide/contracts.html">Racketのコントラクト</a> を参照。</p>
</div>
<div class="paragraph">
<p><strong>specの有用性と強力さをぜひ知ってほしい。</strong></p>
</div>
<div class="paragraph">
<p>Rich Hickey</p>
</div>
</div>
</div></p>

<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>

  </body>
</html>