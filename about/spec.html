<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>Clojure - clojure.spec - Rationale and Overview</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clojure の日本語ドキュメントです">
    <meta name="author" content="Japan Clojurians">
    <meta name="keywords" content="Clojure 日本語">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/normalize.css" rel="stylesheet">
    <link href="../css/webflow.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" type="image/x-icon" href="../images/clojure-logo-icon-32.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">Clojure</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../about/rationale.html">概要</a></li>
            <li><a href="../reference/documentation">リファレンス</a></li>
            <!-- <li><a href="../api/api.html">API</a></li>
              <li><a href="../community/downloads.html">リリース</a></li>
              <li><a href="../guides/guides.html">ガイド</a></li>
              <li><a href="../community/resources.html">コミュニティ</a></li>
              <li><a href="../news/news.html">ニュース</a></li>
              <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
              <li><a href="#">Action</a></li>
              <li><a href="#">Another action</a></li>
              <li><a href="#">Something else here</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Nav header</li>
              <li><a href="#">Separated link</a></li>
              <li><a href="#">One more separated link</a></li>
              </ul>
              </li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

<div class="page-header">
  <h1>clojure.spec - Rationale and Overview</h1>
</div>

<p><em></em></p>

<p><div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_problems">Problems</a>
<ul class="sectlevel2">
<li><a href="#_docs_are_not_enough">Docs are not enough</a></li>
<li><a href="#_map_specs_should_be_of_keysets_only">Map specs should be of keysets only</a></li>
<li><a href="#_manual_parsing_and_error_reporting_is_not_good_enough">Manual parsing and error reporting is not good enough</a></li>
<li><a href="#_generative_testing_and_robustness">Generative testing and robustness</a></li>
<li><a href="#_a_standard_approach_is_needed">A standard approach is needed</a></li>
</ul>
</li>
<li><a href="#_objectives">Objectives</a>
<ul class="sectlevel2">
<li><a href="#_communication">Communication</a></li>
<li><a href="#_unify_specification_in_its_various_contexts">Unify specification in its various contexts</a></li>
<li><a href="#_maximize_leverage_from_specification_effort">Maximize leverage from specification effort</a></li>
<li><a href="#_minimize_intrusion">Minimize intrusion</a></li>
<li><a href="#_decomplect_maps_keys_values">Decomplect maps/keys/values</a></li>
<li><a href="#_enable_and_start_a_dialog_about_semantic_change_and_compatibility">Enable and start a dialog about semantic change and compatibility</a></li>
</ul>
</li>
<li><a href="#_guidelines">Guidelines</a>
<ul class="sectlevel2">
<li><a href="#_mistakes_will_be_made">Mistakes will be made</a></li>
<li><a href="#_expressivity_proof">expressivity &gt; proof</a></li>
<li><a href="#_names_are_important">Names are important</a></li>
<li><a href="#_global_namespaced_names_are_more_important">Global (namespaced) names are more important</a></li>
<li><a href="#_don_t_further_add_to_overload_the_reified_namespaces_of_clojure">Don&#8217;t further add to/overload the (reified) namespaces of Clojure</a></li>
<li><a href="#_code_is_data_not_vice_versa">Code is data (not vice versa)</a></li>
<li><a href="#_sets_maps_are_about_membership_that_s_it">Sets (maps) are about membership, that&#8217;s it</a></li>
<li><a href="#_informational_vs_implementational">Informational vs implementational</a></li>
<li><a href="#_k_i_s_s">K.I.S.S.</a></li>
<li><a href="#_build_on_test_check_but_don_t_require_knowledge_of_it">Build on test.check but don&#8217;t require knowledge of it</a></li>
</ul>
</li>
<li><a href="#_features">Features</a>
<ul class="sectlevel2">
<li><a href="#_overview">Overview</a></li>
<li><a href="#_defining_specs">Defining specs</a></li>
<li><a href="#_using_specs">Using specs</a></li>
</ul>
</li>
<li><a href="#_glossary">Glossary</a>
<ul class="sectlevel2">
<li><a href="#_predicates">predicates</a></li>
<li><a href="#_specs">specs</a></li>
<li><a href="#_regex_ops">regex ops</a></li>
<li><a href="#_conform">conform</a></li>
<li><a href="#_explain">explain</a></li>
<li><a href="#_paths">paths</a></li>
</ul>
</li>
<li><a href="#_prior_art">Prior Art</a></li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_problems">Problems</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_docs_are_not_enough">Docs are not enough</h3>
<div class="paragraph">
<p>Clojure is a dynamic language. Among other things this means that type annotations are not required for code to run.
While Clojure has some support for type hints, they are not an enforcement mechanism, nor comprehensive, and are
limited to communicating information to the compiler to aid in efficient code generation.
Clojure gets runtime checking of a richer set of types by the JVM itself.</p>
</div>
<div class="paragraph">
<p>However it has always been a guiding principle of Clojure, widely valued and practiced by the community,
to simply represent information as data.
Thus important properties of Clojure systems are represented and
conveyed by the shape and other predicative properties of the data, not captured or checked anywhere
since the runtime types are indistinguishable heterogeneous maps and vectors.</p>
</div>
<div class="paragraph">
<p>Documentation strings can be used to communicate with human consumers,
but they can&#8217;t be leveraged by programs or tests, i.e. they have minimal power.
Users have turned to various libraries such as <a href="https://github.com/plumatic/schema">Schema</a>
and <a href="https://github.com/miner/herbert">Herbert</a> to get more powerful specifications.</p>
</div>
</div>
<div class="sect2">
<h3 id="_map_specs_should_be_of_keysets_only">Map specs should be of keysets only</h3>
<div class="paragraph">
<p>Most systems for specifying structures conflate the specification of the key set
(e.g. of keys in a map, fields in an object) with the specification of the values designated by those keys.
I.e. in such approaches the schema for a map might say :a-key&#8217;s type is x-type and :b-key&#8217;s type is y-type.
This is a major source of rigidity and redundancy.</p>
</div>
<div class="paragraph">
<p>In Clojure we gain power by dynamically composing,
merging and building up maps. We routinely deal with optional and partial data, data produced by unreliable
external sources, dynamic queries etc. These maps represent various sets, subsets, intersections and unions
of the same keys, and in general ought to have the same semantic for the same key wherever it is used. Defining
specifications of every subset/union/intersection, and then redundantly stating the semantic of each key is both an
antipattern and unworkable in the most dynamic cases.</p>
</div>
</div>
<div class="sect2">
<h3 id="_manual_parsing_and_error_reporting_is_not_good_enough">Manual parsing and error reporting is not good enough</h3>
<div class="paragraph">
<p>Many users, especially beginners, are frustrated and challenged by the error messages produced by
hand-written parsing and destructuring code, especially in macros where there are two contexts of execution
(the macro runs at compile time and its expansion at runtime, either of which could fail due to user error).
This has led to a call for 'macro grammars', but in fact macros are just functions of data&#8594;data and any solution for
data validation and destructuring should work as well for them as for any other functions.
I.e. macros are an instance of the problems above.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generative_testing_and_robustness">Generative testing and robustness</h3>
<div class="paragraph">
<p>Finally, in all languages, dynamic or not, tests are essential to quality.
Too many critical properties are not captured by common type systems.
But manual testing has a very low effectiveness/effort ratio. Property-based, generative testing, as
implemented for Clojure in <a href="https://github.com/clojure/test.check">test.check</a>,
has proved to be far more powerful than manually written tests.</p>
</div>
<div class="paragraph">
<p>Yet property based testing requires the
definition of properties, which require extra effort and expertise to produce, and which,
at the function-level, have substantial overlap with function specifications.
Many interesting properties at the function level would already be captured by structural+predicative specs.
Ideally, specs should integrate with generative testing and provide certain categories of generative tests 'for free'.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_standard_approach_is_needed">A standard approach is needed</h3>
<div class="paragraph">
<p>In short, Clojure has no standard, expressive, powerful and integrated system for specification and testing.</p>
</div>
<div class="paragraph">
<p><strong>clojure.spec</strong> aims to provide it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_objectives">Objectives</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_communication">Communication</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Species - appearance, form, sort, kind, equivalent to spec (ere) to look, regard<br>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+ -iēs abstract noun suffix</p>
</div>
<div class="paragraph">
<p>Specify - species + -ficus -fic (make)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A specification is about how something 'looks', but is, most importantly, something that is looked at.
Specs should be readable, composed of 'words' (predicate functions) programmers are already using,
and integrated in documentation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unify_specification_in_its_various_contexts">Unify specification in its various contexts</h3>
<div class="paragraph">
<p>Specs for data structures, attribute values and functions should all be the same and live in a
globally-namespaced directory.</p>
</div>
</div>
<div class="sect2">
<h3 id="_maximize_leverage_from_specification_effort">Maximize leverage from specification effort</h3>
<div class="paragraph">
<p>Writing a spec should enable <em>automatic</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Validation</p>
</li>
<li>
<p>Error reporting</p>
</li>
<li>
<p>Destructuring</p>
</li>
<li>
<p>Instrumentation</p>
</li>
<li>
<p>Test-data generation</p>
</li>
<li>
<p>Generative test generation</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_minimize_intrusion">Minimize intrusion</h3>
<div class="paragraph">
<p>Don&#8217;t require that people e.g. define their functions differently. Minor modifications to <code>doc</code> and <code>macroexpand</code>
will allow independently written specs to adorn fn/macro behavior without redefinition.</p>
</div>
</div>
<div class="sect2">
<h3 id="_decomplect_maps_keys_values">Decomplect maps/keys/values</h3>
<div class="paragraph">
<p>Keep map (keyset) specs separate from attribute (key&#8594;value) specs. Encourage and support attribute-granularity specs
of namespaced keyword to value-spec. Combining keys into sets (to specify maps) becomes orthogonal,
and checking becomes possible in the fully-dynamic case, i.e. even when no map spec is present,
attributes (key-values) can be checked.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enable_and_start_a_dialog_about_semantic_change_and_compatibility">Enable and start a dialog about semantic change and compatibility</h3>
<div class="paragraph">
<p>Programmers suffer greatly when they redefine things while keeping the names the same. Yet some changes are
compatible and some are breaking, and most tools can&#8217;t distinguish. Use constructs like set membership and
regular expressions for which compatibility can be determined, and provide tools for compatibility checking
(while leaving general predicate equality out of scope).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_guidelines">Guidelines</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_mistakes_will_be_made">Mistakes will be made</h3>
<div class="paragraph">
<p>We don&#8217;t (and couldn&#8217;t) live in a world where we can&#8217;t make mistakes. Instead, we periodically check that we haven&#8217;t.
Amazon doesn&#8217;t send you your TV via a <code>UPS&lt;Trucks&lt;Boxes&lt;TV&gt;&gt;&gt;</code>. So occasionally you might get a microwave,
but the supply chain isn&#8217;t burdened with correctness proof. Instead we check at the edges and run tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_expressivity_proof">expressivity &gt; proof</h3>
<div class="paragraph">
<p>There is no reason to limit our specifications to what we can prove, yet that is primarily what type systems do.
There is so much more we want to communicate and verify about our systems. This goes beyond
structural/representational types and tagging to predicates that e.g. narrow domains or detail relationships
between inputs or between inputs and output.
Additionally, the properties we care most about are often those of the runtime values, not some static notion.
Thus <strong>spec</strong> is not a type system.</p>
</div>
</div>
<div class="sect2">
<h3 id="_names_are_important">Names are important</h3>
<div class="paragraph">
<p>All programs use names, even when the type systems don&#8217;t, and they capture important semantics. <code>Int x Int x Int</code>
just isn&#8217;t good enough (is it length/width/height or height/width/depth?). So <strong>spec</strong> will not have unlabeled sequence
components or untagged union bindings. The utility of this becomes evident when <strong>spec</strong> needs to talk to users about specs,
e.g. in error reporting, and vice versa, e.g. when users want to override generators in specs. When all branches are named,
you can talk about parts of specs using <em>paths</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_global_namespaced_names_are_more_important">Global (namespaced) names are more important</h3>
<div class="paragraph">
<p>Clojure supports namespaced keywords and symbols. Note here we are just talking about namespace-qualified names,
not Clojure namespace objects. These are tragically underutilized and convey important benefits because
they can always co-reside in dictionaries/dbs/maps/sets without conflict. <strong>spec</strong> will allow (only) namespace-qualified
keywords and symbols to name specs. People using namespaced keys for their informational maps
(a practice we&#8217;d like to see grow) can register the specs for those attributes directly under those names. This
categorically changes the self-description of maps, particularly in dynamic contexts, and encourages composition and consistency.</p>
</div>
</div>
<div class="sect2">
<h3 id="_don_t_further_add_to_overload_the_reified_namespaces_of_clojure">Don&#8217;t further add to/overload the (reified) namespaces of Clojure</h3>
<div class="paragraph">
<p>Nothing will be attached to vars, metadata etc. All functions have namespaced names which can serve as keys to their
related data (e.g. spec) that is stored elsewhere.</p>
</div>
</div>
<div class="sect2">
<h3 id="_code_is_data_not_vice_versa">Code is data (not vice versa)</h3>
<div class="paragraph">
<p>In Lisps (and thus Clojure), code is data. But data is not code until you define a language around it. Many DSLs in
this space drive at a data representation for schemas. But predicative specs have an open and large vocabulary,
and most of the useful predicates already exist and are well known as functions in the core and other namespaces,
or can be written as simple expressions. Having to 'datafy', possibly renaming, all of these predicates adds
little value, and has a definite cost in understanding precise semantics. <strong>spec</strong> instead leverages the fact that
the original predicates and expressions are data in the first place and captures that data for use in communicating
with the users in documentation and error reporting. Yes, this means that more of the
surface area of <code>clojure.spec</code> will be macros, but specs are overwhelmingly written by people and,
when composed, manually so.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sets_maps_are_about_membership_that_s_it">Sets (maps) are about membership, that&#8217;s it</h3>
<div class="paragraph">
<p>As per above, maps defining the details of the values at their keys is a fundamental complecting of concerns that will
not be supported. Map specs detail required/optional keys (i.e. set membership things) and keyword/attr/value
semantics are independent. Map checking is two-phase, required key presence then key/value conformance.
The latter can be done even when the (namespace-qualified) keys present at runtime are not in the map spec.
This is vital for composition and dynamicity.</p>
</div>
</div>
<div class="sect2">
<h3 id="_informational_vs_implementational">Informational vs implementational</h3>
<div class="paragraph">
<p>Invariably, people will try to use a specification system to detail implementation decisions, but they do so
to their detriment. The best and most useful specs (and interfaces) are related to purely information aspects.
Only information specs work over wires and across systems. We will always prioritize, and
where there is a conflict, prefer, the information approach.</p>
</div>
</div>
<div class="sect2">
<h3 id="_k_i_s_s">K.I.S.S.</h3>
<div class="paragraph">
<p>There are very few bottom notions in this space and we will endeavor to stick to them.
There are few distinct structural notions - a handful of atomic types, sequential things, sets and maps.
Unsurprisingly, these are the Clojure data types and fundamental ops will be provided only for these. Similarly there
are mathematical tools for talking about these - set logic for maps and regular expressions for sequences -
that have valuable properties. We will prefer these over ad hoc solutions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_build_on_test_check_but_don_t_require_knowledge_of_it">Build on test.check but don&#8217;t require knowledge of it</h3>
<div class="paragraph">
<p>The generative testing underpinning of <strong>spec</strong> will leverage <code>test.check</code> and not reinvent it.
But spec users should not need to know anything about <code>test.check</code> until and unless they want to write their own
generators or supplement <strong>spec</strong>'s generated tests with further property-based tests of their own. There should be no
production runtime dependency on <code>test.check</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_features">Features</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview">Overview</h3>
<div class="sect3">
<h4 id="_predicative_specs">Predicative specs</h4>
<div class="paragraph">
<p>The basic idea is that specs are nothing more than a logical composition of predicates. At the bottom we are talking
about the simple boolean predicates you are used to like <code>int?</code> or <code>symbol?</code>, or expressions you build yourself
like <code>#(&lt; 42 % 66)</code>.
<strong>spec</strong> adds logical ops like <code>spec/and</code> and <code>spec/or</code> which combine specs in a logical way and offer deep reporting,
generation and conform support and, in the case of <code>spec/or</code>, tagged returns.</p>
</div>
</div>
<div class="sect3">
<h4 id="_maps">Maps</h4>
<div class="paragraph">
<p>Specs for map keysets provide for the specification of required and optional key sets. A spec for a map is
produced by calling <code>keys</code> with <code>:req</code> and <code>:opt</code> keyword arguments mapping to vectors of key names.</p>
</div>
<div class="paragraph">
<p><code>:req</code> keys support the logical operators <code>and</code> and <code>or</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(spec/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])</code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the most visible differences between <strong>spec</strong> and other systems is that there is no place in that map spec for
specifying the <em>values</em> e.g. <code>::x</code> can take. It is the (enforced) opinion of <strong>spec</strong> that the specification of values
associated with a namespaced keyword, like <code>:my.ns/k</code>, should be registered under that keyword itself,
and applied in any map in which that keyword appears. There are a number of advantages to this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It ensures consistency for all uses of that keyword in an application where all uses should share a semantic</p>
</li>
<li>
<p>It similarly ensures consistency between a library and its consumers</p>
</li>
<li>
<p>It reduces redundancy, since otherwise many map specs would need to make matching declarations about k</p>
</li>
<li>
<p>Namespaced keyword specs can be checked even when no map spec declares those keys</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This last point is vital when dynamically building up, composing, or generating maps. Creating a spec for every map
subset/union/intersection is unworkable. It also facilitates fail-fast detection of bad data - when it is introduced
vs when it is consumed.</p>
</div>
<div class="paragraph">
<p>Of course, many existing map-based interfaces take non-namespaced keys. To support connecting them to properly
namespaced and reusable specs, <code>keys</code> supports <code>-un</code> variants of <code>:req</code> and <code>:opt</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(spec/keys :req-un [:my.ns/a :my.ns/b])</code></pre>
</div>
</div>
<div class="paragraph">
<p>This specs a map that requires the unqualified keys <code>:a</code> and <code>:b</code> but validates and generates them using specs
(when defined) named <code>:my.ns/a</code> and <code>:my.ns/b</code> respectively. Note that this cannot convey the same power
to unqualified keywords as have namespaced keywords - the resulting maps are not self-describing.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sequences">Sequences</h4>
<div class="paragraph">
<p>Specs for sequences/vectors use a set of standard regular expression operators, with the standard semantics of
regular expressions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cat</code> - a concatenation of predicates/patterns</p>
</li>
<li>
<p><code>alt</code> - a choice of one among a set of predicates/patterns</p>
</li>
<li>
<p><code>*</code> - zero or more occurrences of a predicate/pattern</p>
</li>
<li>
<p><code>+</code> - one or more</p>
</li>
<li>
<p><code>?</code> - one or none</p>
</li>
<li>
<p><code>&amp;</code> - takes a regex op and further constrains it with one or more predicates</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These nest arbitrarily to form complex expressions.</p>
</div>
<div class="paragraph">
<p>Note that <code>cat</code> and <code>alt</code> require all of their components be labeled, and the return value of each is a map with
the keys corresponding to the matched components. In this way <strong>spec</strong> regexes act as destructuring and parsing tools.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user=&gt; (require '[clojure.spec.alpha :as s])
(s/def ::even? (s/and integer? even?))
(s/def ::odd? (s/and integer? odd?))
(s/def ::a integer?)
(s/def ::b integer?)
(s/def ::c integer?)
(def s (s/cat :forty-two #{42}
              :odds (s/+ ::odd?)
              :m (s/keys :req-un [::a ::b ::c])
              :oes (s/* (s/cat :o ::odd? :e ::even?))
              :ex (s/alt :odd ::odd? :even ::even?)))
user=&gt; (s/conform s [42 11 13 15 {:a 1 :b 2 :c 3} 1 2 3 42 43 44 11])
{:forty-two 42,
 :odds [11 13 15],
 :m {:a 1, :b 2, :c 3},
 :oes [{:o 1, :e 2} {:o 3, :e 42} {:o 43, :e 44}],
 :ex {:odd 11}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_conform_explain">conform/explain</h4>
<div class="paragraph">
<p>As you can see above, the basic operation for using specs is <code>conform</code>, which takes a spec and a value and
returns the conformed value or <code>:clojure.spec.alpha/invalid</code> if the value did not conform. When the value does not conform
you can call <code>explain</code> or <code>explain-data</code> to find out why it didn&#8217;t.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_specs">Defining specs</h3>
<div class="paragraph">
<p>The primary operations for defining specs are s/def, s/and, s/or, s/keys and the regex ops. There is a <code>spec</code> function
that can take
a predicate function or expression, a set, or a regex op, and can also take an optional generator which would override
the generator implied by the predicate(s).</p>
</div>
<div class="paragraph">
<p>Note however, that <code>def, and, or, keys</code> spec fns and the regex ops can all take and use predicate functions and sets directly -
and do not need them to be wrapped by <code>spec</code>. <code>spec</code> should only be needed when you want to override a generator or to
specify that a nested regex starts anew, vs being included in the same pattern.</p>
</div>
<div class="sect3">
<h4 id="_data_spec_registration">Data spec registration</h4>
<div class="paragraph">
<p>In order for a spec to be reusable by name, it has to be registered via <code>def</code>.
<code>def</code> takes a namespace-qualified keyword/symbol and a spec/predicate expression. By convention, specs for data should
be registered under
keywords and attribute values should be registered under their attribute name keyword. Once registered, the name can
be used anywhere a spec/predicate is called for in any of the <strong>spec</strong> operations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_function_spec_registration">Function spec registration</h4>
<div class="paragraph">
<p>A function can be fully specified via three specs - one for the args, one for the return, and one for the operation of
the function relating the args to the return.</p>
</div>
<div class="paragraph">
<p>The args spec for a fn is always going to be a regex that specs the arguments as if they were a list, i.e. the
list one would pass to <code>apply</code> the function. In this way, a single spec can handle functions with multiple arities.</p>
</div>
<div class="paragraph">
<p>The return spec is an arbitrary spec of a single value.</p>
</div>
<div class="paragraph">
<p>The (optional) fn spec is a further specification of the relationship between the arguments and the return, i.e. the
function of the function. It will be passed (e.g. during testing) a map containing
<code>{:args conformed-args :ret conformed-ret}</code> and will generally contain predicates that relate those values - e.g. it
could ensure that all keys of an input map are present in the returned map.</p>
</div>
<div class="paragraph">
<p>You can fully specify all three specs of a function in a single call to <code>fdef</code>, and recall the specs via <code>fn-specs</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_specs">Using specs</h3>
<div class="sect3">
<h4 id="_documentation">Documentation</h4>
<div class="paragraph">
<p>Functions specs defined via <code>fdef</code> will appear when you call <code>doc</code> on the fn name. You can call <code>describe</code>
on specs to get descriptions as forms.</p>
</div>
</div>
<div class="sect3">
<h4 id="_parsing_destructuring">Parsing/destructuring</h4>
<div class="paragraph">
<p>You can use <code>conform</code> directly in your implementations to get its destructuring/parsing/error-checking.
<code>conform</code> can be used e.g. in macro implementations and at I/O boundaries.</p>
</div>
</div>
<div class="sect3">
<h4 id="_during_development">During development</h4>
<div class="paragraph">
<p>You can selectively instrument functions and namespaces with <code>instrument</code>, which swaps out
the fn var with a wrapped version of the fn that tests the <code>:args</code> spec. <code>unstrument</code> returns a fn to its
original version. You can generate data for interactive testing with <code>gen/sample</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_for_testing">For testing</h4>
<div class="paragraph">
<p>You can run a suite of spec-generative tests on an entire ns with <code>check</code>. You can get a test.check compatible generator
for a spec by calling <code>gen</code>. There are built-in associations between many of the <code>clojure.core</code> data predicates and corresponding
generators, and the composite ops of <strong>spec</strong> know how to build generators atop those. If you call <code>gen</code> on a spec and it is
unable to construct a generator for some subtree, it will throw an exception that describes where. You can pass generator-returning fns to
<code>spec</code> in order to supply generators for things spec does not know about, and you can pass an override map to <code>gen</code> in order to supply
alternative generators for one or more subpaths of a spec.</p>
</div>
</div>
<div class="sect3">
<h4 id="_at_runtime">At runtime</h4>
<div class="paragraph">
<p>In addition to the destructuring use cases above, you can make calls to <code>conform</code> or <code>valid?</code> anywhere you want
runtime checking, and can make lighter-weight internal-only specs for tests you intend to run in production.</p>
</div>
<div class="paragraph">
<p>Please see the <a href="xref/../../../guides/spec">spec Guide</a> and <a href="https://clojure.github.io/clojure/branch-master/clojure.spec-api.html">API docs</a> for more examples and usage information.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_glossary">Glossary</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_predicates">predicates</h3>
<div class="paragraph">
<p>Many parts of the spec API call for 'predicates' or 'preds'. These arguments can be satisfied by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>predicate (boolean) fns</p>
</li>
<li>
<p>sets</p>
</li>
<li>
<p>registered names of specs</p>
</li>
<li>
<p>specs (the return values of <code>spec</code>, <code>and</code>, <code>or</code>, <code>keys</code>)</p>
</li>
<li>
<p>regex ops (the return values of <code>cat</code>, <code>alt</code>, <code>*</code>, <code>+</code>, <code>?</code>, <code>&amp;</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that if you want to nest an independent regex predicate within a regex you will have to wrap it in a call to <code>spec</code>,
else  it will be considered a nested pattern.</p>
</div>
</div>
<div class="sect2">
<h3 id="_specs">specs</h3>
<div class="paragraph">
<p>The return values of <code>spec</code>, <code>and</code>, <code>or</code> and <code>keys</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_regex_ops">regex ops</h3>
<div class="paragraph">
<p>The return values of <code>cat</code>, <code>alt</code>, <code>*</code>, <code>+</code>, <code>?</code>, <code>&amp;</code>. When nested these form a single expression.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conform">conform</h3>
<div class="paragraph">
<p><code>conform</code> is the basic operation for consuming specs, and does both validation and conforming/destructuring.
Note that conforming is 'deep' and flows through all of the spec and regex operations, map specs etc.
Since <code>nil</code> and <code>false</code> are legitimate conformed values, conform returns the distinguished <code>:clojure.spec.alpha/invalid</code>
when a value cannot be made to conform. <code>valid</code>? can be used instead as a fully-boolean predicate.</p>
</div>
</div>
<div class="sect2">
<h3 id="_explain">explain</h3>
<div class="paragraph">
<p>When a value fails to conform to a spec you can call <code>explain</code> or <code>explain-data</code> with the same spec+value to
find out why. These explanations are not produced during <code>conform</code> because they might perform additional work and there
is no reason to incur that cost for non-failing inputs or when no report is desired. An important component of
explanations is the <em>path</em>. <code>explain</code> extends the path as it navigates through e.g. nested maps or regex patterns,
so you get better information than just the entire or leaf value. <code>explain-data</code> will return a map of paths to problems.</p>
</div>
</div>
<div class="sect2">
<h3 id="_paths">paths</h3>
<div class="paragraph">
<p>Due to the fact that all <em>branching</em> points in specs are labeled, i.e. map <code>keys</code>, choices in <code>or</code> and <code>alt</code>, and
(possibly elided) elements of <code>cat</code>, every subexpression in a spec can be referred to via a <em>path</em> (vector of keys) naming the parts.
These paths are used in <code>explain</code>, <code>gen</code> overrides and various error reporting.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prior_art">Prior Art</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Almost nothing about spec is novel. See all the libraries mentioned above, <a href="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">RDF</a>,
as well as all the work done on various
contract systems, such as <a href="https://docs.racket-lang.org/guide/contracts.html">Racket&#8217;s contracts</a>.</p>
</div>
<div class="paragraph">
<p><strong>I hope you find spec useful and powerful.</strong></p>
</div>
<div class="paragraph">
<p>Rich Hickey</p>
</div>
</div>
</div></p>

<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>

  </body>
</html>