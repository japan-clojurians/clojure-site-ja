<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>Clojure - Clojureを学ぼう - ハッシュ化されたコレクション</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clojure の日本語ドキュメントです">
    <meta name="author" content="Japan Clojurians">
    <meta name="keywords" content="Clojure 日本語">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../css/normalize.css" rel="stylesheet">
    <link href="../../css/webflow.css" rel="stylesheet">
    <link href="../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" type="image/x-icon" href="../../images/clojure-logo-icon-32.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">Clojure</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../../about/rationale">概要</a></li>
            <li><a href="../../reference/documentation">リファレンス</a></li>
            <!-- <li><a href="../../api/api">API</a></li>
              <li><a href="../../community/downloads">リリース</a></li> -->
              <li><a href="../../guides/guides">ガイド</a></li>
            <!-- <li><a href="../../community/resources">コミュニティ</a></li>
              <li><a href="../../news/news">ニュース</a></li>
              <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
              <li><a href="#">Action</a></li>
              <li><a href="#">Another action</a></li>
              <li><a href="#">Something else here</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Nav header</li>
              <li><a href="#">Separated link</a></li>
              <li><a href="#">One more separated link</a></li>
              </ul>
              </li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

<div class="page-header">
  <h1>Clojureを学ぼう - ハッシュ化されたコレクション</h1>
</div>

<p><em></em></p>

<p><div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_セット">セット</a>
<ul class="sectlevel2">
<li><a href="#_セットに追加する">セットに追加する</a></li>
<li><a href="#_セットから取り除く">セットから取り除く</a></li>
<li><a href="#_含まれていることを確認する">含まれていることを確認する</a></li>
<li><a href="#_ソート済みセット">ソート済みセット</a></li>
<li><a href="#_into"><code>into</code></a></li>
</ul>
</li>
<li><a href="#_マップ">マップ</a>
<ul class="sectlevel2">
<li><a href="#_リテラルのマップを作る">リテラルのマップを作る</a></li>
<li><a href="#_新たなキー_値のペアを追加する">新たなキー-値のペアを追加する</a></li>
<li><a href="#_キー_値のペアを取り除く">キー-値のペアを取り除く</a></li>
<li><a href="#_キーでルックアップする">キーでルックアップする</a></li>
<li><a href="#_デフォルトとともにルックアップする">デフォルトとともにルックアップする</a></li>
<li><a href="#_含まれていることを確認する_2">含まれていることを確認する</a></li>
<li><a href="#_キーもしくは値">キーもしくは値</a></li>
<li><a href="#_マップを構築する">マップを構築する</a></li>
<li><a href="#_マップを組み合わせる">マップを組み合わせる</a></li>
<li><a href="#_ソート済みマップ">ソート済みマップ</a></li>
</ul>
</li>
<li><a href="#_アプリケーションドメインの情報を表現する">アプリケーションドメインの情報を表現する</a>
<ul class="sectlevel2">
<li><a href="#_フィールドアクセッサ">フィールドアクセッサ</a></li>
<li><a href="#_フィールドを更新する">フィールドを更新する</a></li>
<li><a href="#_フィールドを取り除く">フィールドを取り除く</a></li>
<li><a href="#_ネストしたエントリ">ネストしたエントリ</a></li>
<li><a href="#_レコード">レコード</a></li>
</ul>
</li>
</ul>
</div>
<div class="paragraph">
<p>前のセクションで説明したように、Clojureのコレクション型には重要なものが4種類ある:
ベクター、リスト、セット、マップだ。4種類のコレクション型のうち、セットとマップはハッシュ化された(hashed)コレクションであり、要素を効率的にルックアップするために設計されている。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_セット"><a class="anchor" href="#_セット"></a>セット</h2>
<div class="sectionbody">
<div class="paragraph">
<p>セットは数学的な集合(set)のようなものだ――順序付けられておらず重複がない。セットはコレクションが要素を含んでいるかどうかを効率的に確かめたり任意の要素を取り除いたりするのに最適だ。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(def players #{"Alice", "Bob", "Kelly"})</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_セットに追加する"><a class="anchor" href="#_セットに追加する"></a>セットに追加する</h3>
<div class="paragraph">
<p>ベクターやリストと同様に、 <code>conj</code> が要素を追加するために使われる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (conj players "Fred")
#{"Alice" "Fred" "Bob" "Kelly"}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_セットから取り除く"><a class="anchor" href="#_セットから取り除く"></a>セットから取り除く</h3>
<div class="paragraph">
<p><code>disj</code> ("disjoin")関数はセットから1個以上の要素を取り除くために使われる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (disj players "Bob" "Sal")
#{"Alice" "Kelly"}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_含まれていることを確認する"><a class="anchor" href="#_含まれていることを確認する"></a>含まれていることを確認する</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (contains? players "Kelly")
true</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ソート済みセット"><a class="anchor" href="#_ソート済みセット"></a>ソート済みセット</h3>
<div class="paragraph">
<p>ソート済み(sorted)セットは2つの要素を比較可能なコンパレータ関数に従ってソートされている。デフォルトではClojureの <code>compare</code>
関数が使われ、数値や文字列などの「自然な」順序でソートされる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (conj (sorted-set) "Bravo" "Charlie" "Sigma" "Alpha")
#{"Alpha" "Bravo" "Charlie" "Sigma"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>カスタムのコンパレータも <code>sorted-set-by</code> で使うことができる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_into"><a class="anchor" href="#_into"></a><code>into</code></h3>
<div class="paragraph">
<p><code>into</code> はあるコレクションを別のコレクションの中に入れるのに使われる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (def players #{"Alice" "Bob" "Kelly"})
user=&gt; (def new-players ["Tim" "Sue" "Greg"])
user=&gt; (into players new-players)
#{"Alice" "Greg" "Sue" "Bob" "Tim" "Kelly"}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>into</code> は最初の引数と同じ型のコレクションを返す。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_マップ"><a class="anchor" href="#_マップ"></a>マップ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>マップは一般に2通りの目的で使われる――キーから値への関連付けを管理するためとドメインのアプリケーションデータを表現するためだ。最初のユースケースは他の言語ではディクショナリやハッシュマップと呼ばれることが多い。</p>
</div>
<div class="sect2">
<h3 id="_リテラルのマップを作る"><a class="anchor" href="#_リテラルのマップを作る"></a>リテラルのマップを作る</h3>
<div class="paragraph">
<p>マップは交互に並んだキーと値が <code>{</code> と <code>}</code> に囲まれて表現される。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(def scores {"Fred"  1400
             "Bob"   1240
             "Angela" 1024})</code></pre>
</div>
</div>
<div class="paragraph">
<p>ClojureがREPLでマップを出力する際には、個々のキー/値のペアの間に <code>,</code>
を入れる。これは純粋に可読性のために使われている――Clojureではカンマは空白として扱われる。役に立つ場合には自由に使おう!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; 先ほどのものと同じ!
(def scores {"Fred" 1400, "Bob" 1240, "Angela" 1024})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_新たなキー_値のペアを追加する"><a class="anchor" href="#_新たなキー_値のペアを追加する"></a>新たなキー-値のペアを追加する</h3>
<div class="paragraph">
<p>新たな値は <code>assoc</code> ("associate"の略)関数でマップに追加される:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (assoc scores "Sally" 0)
{"Angela" 1024, "Bob" 1240, "Fred" 1400, "Sally" 0}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>assoc</code> で使われているキーがすでに存在すると、その値は置き換えられる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (assoc scores "Bob" 0)
{"Angela" 1024, "Bob" 0, "Fred" 1400}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_キー_値のペアを取り除く"><a class="anchor" href="#_キー_値のペアを取り除く"></a>キー-値のペアを取り除く</h3>
<div class="paragraph">
<p>キー-値のペアを取り除くための相補的な操作は <code>dissoc</code>("dissociate")だ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (dissoc scores "Bob")
{"Angela" 1024, "Fred" 1400}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_キーでルックアップする"><a class="anchor" href="#_キーでルックアップする"></a>キーでルックアップする</h3>
<div class="paragraph">
<p>マップの値をルックアップする方法はいくつかある。最も明白な方法は関数 <code>get</code> だ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (get scores "Angela")
1024</code></pre>
</div>
</div>
<div class="paragraph">
<p>問題のマップが定数のルックアップテーブルとして扱われている場合には、マップそのものを関数として扱って呼び出すのが一般的だ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (def directions {:north 0
                        :east 1
                        :south 2
                        :west 3})
#'user/directions

user=&gt; (directions :north)
0</code></pre>
</div>
</div>
<div class="paragraph">
<p>マップが非nilであることが保証できない限りマップを直接呼び出すべきではない。:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (def bad-lookup-map nil)
#'user/bad-lookup-map

user=&gt; (bad-lookup-map :foo)
NullPointerException</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_デフォルトとともにルックアップする"><a class="anchor" href="#_デフォルトとともにルックアップする"></a>デフォルトとともにルックアップする</h3>
<div class="paragraph">
<p>ルックアップをしてキーが見つからない場合にデフォルト値にフォールバックしたい場合には、追加の引数としてデフォルトを指定する:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (get scores "Sam" 0)
0
​
user=&gt; (directions :northwest -1)
-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>デフォルトを使うことは、キーがないことと存在するキーに対応するのが <code>nil</code> 値であることとを区別するのにも役に立つ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_含まれていることを確認する_2"><a class="anchor" href="#_含まれていることを確認する_2"></a>含まれていることを確認する</h3>
<div class="paragraph">
<p>マップにエントリが含まれているかどうかを確認するのに便利な関数が他に2つある。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (contains? scores "Fred")
true

user=&gt; (find scores "Fred")
["Fred" 1400]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>contains?</code> 関数は含まれていることを確認するための述語だ。 <code>find</code> 関数はマップから値だけでなくキー/値のエントリを見つけ出す。</p>
</div>
</div>
<div class="sect2">
<h3 id="_キーもしくは値"><a class="anchor" href="#_キーもしくは値"></a>キーもしくは値</h3>
<div class="paragraph">
<p>マップのキーだけ、もしくは値だけを得ることもできる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (keys scores)
("Fred" "Bob" "Angela")

user=&gt; (vals scores)
(1400 1240 1024)</code></pre>
</div>
</div>
<div class="paragraph">
<p>マップは順序付けられていないが、マップを「シーケンス」の順序でたどるkeys、vals、その他の関数は特定のマップインスタンスのエントリを常に同一の順序でたどるという保証がある。</p>
</div>
</div>
<div class="sect2">
<h3 id="_マップを構築する"><a class="anchor" href="#_マップを構築する"></a>マップを構築する</h3>
<div class="paragraph">
<p><code>zipmap</code> 関数は2つのシーケンス(キーと値)をジッパーを閉じるようにまとめ("zip")てマップにするのに使うことができる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (def players #{"Alice" "Bob" "Kelly"})
#'user/players

user=&gt; (zipmap players (repeat 0))
{"Kelly" 0, "Bob" 0, "Alice" 0}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Clojureのシーケンス関数を使ってマップを構築するには他にも様々な方法がある(まだ述べていないが)。これにはあとで戻ってこよう!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; map と into で
(into {} (map (fn [player] [player 0]) players))

;; reduce で
(reduce (fn [m player]
          (assoc m player 0))
        {} ; 初期値
        players)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_マップを組み合わせる"><a class="anchor" href="#_マップを組み合わせる"></a>マップを組み合わせる</h3>
<div class="paragraph">
<p><code>merge</code> 関数は複数のマップを単一のマップに組み合わせるのに使うことができる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (def new-scores {"Angela" 300 "Jeff" 900})
#'user/new-scores

user=&gt; (merge scores new-scores)
{"Fred" 1400, "Bob" 1240, "Jeff" 900, "Angela" 300}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは2つのマップをマージしたが、より多くのマップを渡すこともできる。</p>
</div>
<div class="paragraph">
<p>両方のマップが同じキーを含んでいると、最も右のマップが勝つ。あるいは衝突があった場合に呼び出される関数を与える <code>merge-with</code>
を使うこともできる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (def new-scores {"Fred" 550 "Angela" 900 "Sam" 1000})
#'user/new-scores

user=&gt; (merge-with + scores new-scores)
{"Sam" 1000, "Fred" 1950, "Bob" 1240, "Angela" 1924}</code></pre>
</div>
</div>
<div class="paragraph">
<p>衝突があった場合には、両者の値に対してその関数が呼び出されて新たな値が得られる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ソート済みマップ"><a class="anchor" href="#_ソート済みマップ"></a>ソート済みマップ</h3>
<div class="paragraph">
<p>ソート済みセットと同様に、ソート済み(sorted)マップではコンパレータに基づいてキーがソート済みの順序で維持され、デフォルトのコンパレータ関数としては
<code>compare</code> が使われる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (def sm (sorted-map
         "Bravo" 204
         "Alfa" 35
         "Sigma" 99
         "Charlie" 100))
{"Alfa" 35, "Bravo" 204, "Charlie" 100, "Sigma" 99}

user=&gt; (keys sm)
("Alfa" "Bravo" "Charlie" "Sigma")

user=&gt; (vals sm)
(35 204 100 99)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_アプリケーションドメインの情報を表現する"><a class="anchor" href="#_アプリケーションドメインの情報を表現する"></a>アプリケーションドメインの情報を表現する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>事前に分かっている同一のフィールドの集合で多くのドメイン情報を表現する必要がある場合には、キーワードをキーとするマップを使うことができる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(def person
  {:first-name "Kelly"
   :last-name "Keen"
   :age 32
   :occupation "Programmer"})</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_フィールドアクセッサ"><a class="anchor" href="#_フィールドアクセッサ"></a>フィールドアクセッサ</h3>
<div class="paragraph">
<p>これはマップなので、すでに述べたキーで値をルックアップするための方法も機能する:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (get person :occupation)
"Programmer"

user=&gt; (person :occupation)
"Programmer"</code></pre>
</div>
</div>
<div class="paragraph">
<p>しかし実は、この用途でフィールドの値を得る最も一般的な方法はキーワードを呼び出すことによるものだ。マップやセットと同じようにキーワードもまた関数だ。キーワードが呼び出されると、渡された連想的(associative)なデータ構造からキーワード自身をルックアップする。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (:occupation person)
"Programmer"</code></pre>
</div>
</div>
<div class="paragraph">
<p>キーワード呼び出しはオプションでデフォルト値もとる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (:favorite-color person "beige")
"beige"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_フィールドを更新する"><a class="anchor" href="#_フィールドを更新する"></a>フィールドを更新する</h3>
<div class="paragraph">
<p>これはマップなので、フィールドを追加したり変更したりするのに単に <code>assoc</code> を使うことができる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (assoc person :occupation "Baker")
{:age 32, :last-name "Keen", :first-name "Kelly", :occupation "Baker"}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_フィールドを取り除く"><a class="anchor" href="#_フィールドを取り除く"></a>フィールドを取り除く</h3>
<div class="paragraph">
<p>フィールドを取り除くにはdissocを使う:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (dissoc person :age)
{:last-name "Keen", :first-name "Kelly", :occupation "Programmer"}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ネストしたエントリ"><a class="anchor" href="#_ネストしたエントリ"></a>ネストしたエントリ</h3>
<div class="paragraph">
<p>他のエントリにネストしたエントリを目にすることも一般的だ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(def company
  {:name "WidgetCo"
   :address {:street "123 Main St"
             :city "Springfield"
             :state "IL"}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>ネストしたエントリ内の任意のレベルにあるフィールドにアクセスするために <code>get-in</code> を使うことができる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (get-in company [:address :city])
"Springfield"</code></pre>
</div>
</div>
<div class="paragraph">
<p>ネストしたエントリを変更するために <code>assoc-in</code> や <code>update-in</code> を使うこともできる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (assoc-in company [:address :street] "303 Broadway")
{:name "WidgetCo",
 :address
 {:state "IL",
  :city "Springfield",
  :street "303 Broadway"}}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_レコード"><a class="anchor" href="#_レコード"></a>レコード</h3>
<div class="paragraph">
<p>マップを使うことの代替手段は「レコード」を作ることだ。レコードは特にこのユースケースのために設計されており、一般にパフォーマンスが優れている。加えて、レコードには名前付きの「型」があり、ポリモーフィックな振る舞いのために使うことができる(詳しくは後ほど)。</p>
</div>
<div class="paragraph">
<p>レコードは、レコードインスタンスのフィールド名のリストとともに定義される。このフィールド名は個々のレコードインスタンスでキーワードのキーとして扱われる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; レコード構造を定義する
(defrecord Person [first-name last-name age occupation])

;; 位置引数によるコンストラクタ――自動生成される
(def kelly (-&gt;Person "Kelly" "Keen" 32 "Programmer"))

;; マップによるコンストラクタ――自動生成される
(def kelly (map-&gt;Person
             {:first-name "Kelly"
              :last-name "Keen"
              :age 32
              :occupation "Programmer"}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>レコードはマップとほとんど全く同じように使えるが、マップのように関数として呼び出すことはできないことに注意が必要だ。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (:occupation kelly)
"Programmer"</code></pre>
</div>
</div>
</div>
</div>
</div></p>

<div class="clja-prev-next-container">
  <a href="sequential_colls" class="clja-prev-link"><span class="clja-prevnext-link-icon">←</span>&nbsp;Sequential Collections</a>
  <a href="flow" class="clja-next-link">Flow Control&nbsp;<span class="clja-prevnext-link-icon">→</span></a>
</div>

<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../js/jquery-1.11.1.min.js"></script>
    <script src="../../js/bootstrap.min.js"></script>
    <script src="../../js/prettify.js"></script>

  </body>
</html>