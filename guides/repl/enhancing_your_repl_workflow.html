<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>Clojure - Programming at the REPL: Enhancing your REPL workflow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clojure の日本語ドキュメントです">
    <meta name="author" content="Japan Clojurians">
    <meta name="keywords" content="Clojure 日本語">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../css/normalize.css" rel="stylesheet">
    <link href="../../css/webflow.css" rel="stylesheet">
    <link href="../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" type="image/x-icon" href="../../images/clojure-logo-icon-32.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">Clojure</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../../about/rationale">概要</a></li>
            <li><a href="../../reference/documentation">リファレンス</a></li>
            <!-- <li><a href="../../api/api">API</a></li>
              <li><a href="../../community/downloads">リリース</a></li> -->
              <li><a href="../../guides/guides">ガイド</a></li>
            <!-- <li><a href="../../community/resources">コミュニティ</a></li>
              <li><a href="../../news/news">ニュース</a></li>
              <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
              <li><a href="#">Action</a></li>
              <li><a href="#">Another action</a></li>
              <li><a href="#">Something else here</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Nav header</li>
              <li><a href="#">Separated link</a></li>
              <li><a href="#">One more separated link</a></li>
              </ul>
              </li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

<div class="page-header">
  <h1>Programming at the REPL: Enhancing your REPL workflow</h1>
</div>

<p><em></em></p>

<p><div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#editor-integrations">Editor integrations</a>
<ul class="sectlevel2">
<li><a href="#_what_to_expect_from_an_in_editor_repl_integration">What to expect from an in-editor REPL integration?</a></li>
</ul>
</li>
<li><a href="#debugging-tools-and-techniques">Debugging tools and techniques</a>
<ul class="sectlevel2">
<li><a href="#_printing_in_flight_values_with_prn">Printing in-flight values with <code>prn</code></a></li>
<li><a href="#_intercepting_and_saving_values_on_the_fly">Intercepting and saving values on-the-fly</a></li>
<li><a href="#_reproducing_the_context_of_an_expression">Reproducing the context of an expression</a></li>
<li><a href="#_community_resources_about_repl_debugging">Community resources about REPL debugging</a></li>
</ul>
</li>
<li><a href="#writing-repl-friendly-programs">Writing REPL-friendly programs</a></li>
</ul>
</div>
<div class="paragraph">
<p>At this point, you know enough to understand how the REPL works; we&#8217;ll now focus on giving
you a more streamlined development experience with the REPL. There is a variety of things
you may want to improve:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>Switching between my editor and the REPL is tedious.</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Most Clojure programmers don&#8217;t use the terminal-based REPL for everyday development:
instead, they use a REPL integration in their editor, which enables them to write expressions
directly in their editor buffer and have them evaluated in the REPL with one hotkey.
See the <a href="#editor-integrations">Editor integrations</a> section below for more details.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>I want to do small experiments in Clojure, but it&#8217;s painful to write code in the default CLI tool.</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>As mentioned above, one solution could be to use an <a href="#editor-integrations">Editor integration</a>;
Note that some editors such as <strong><a href="https://sekao.net/nightcode/">Nightcode</a></strong> are designed specifically to
provide a 'batteries-included' experience for Clojure.</p>
</div>
<div class="paragraph">
<p>However, if setting up an editor is too heavy for your taste, there also exist more ergonomic terminal REPL clients:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><a href="https://github.com/bhauman/rebel-readline">rebel-readline</a></strong> is a terminal readline library made by Bruce Hauman.
If you have already installed the <a href="xref/../../deps_and_cli">Clojure CLI tools</a>, you can launch it in <a href="https://github.com/bhauman/rebel-readline#quick-try">one line at the terminal</a>
without any additional installation steps.</p>
</li>
<li>
<p><strong><a href="https://github.com/Unrepl/unravel">Unravel</a></strong> by Paulus Esterhazy is another option, based on the <a href="https://github.com/Unrepl/unrepl">unrepl</a> communication protocol.</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>I need to debug a program I&#8217;m running from the REPL.</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>The REPL can definitely help you do that: see the <a href="#debugging-tools-and-techniques">Debugging Tools and Techniques</a> section below.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>I find myself repeating a lot of manual steps at the REPL for running my development environment.</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Consider creating a 'dev' namespace in your project (e.g <code>myproject.dev</code>) in which you define functions
for automating common development tasks (for example: starting a local web server, running a database query,
turning on/off email sending, etc.)</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>When I make changes to my code, it&#8217;s often difficult to reflect that change in my running program:
I have to do a lot of manual work in the REPL to make it happen..</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Depending on the choices you make when writing your programs, interacting with them at the REPL will
become more or less practical. See the <a href="#writing-repl-friendly-programs">Writing REPL-friendly programs</a> section below.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>I would like to save my REPL sessions in a 'notebook' format.</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><a href="http://gorilla-repl.org/">Gorilla REPL</a> was made for this very purpose.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>I want better data visualization than what the REPL provides.</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>You may get improved visualization features from a specialized Clojure editor:
 see the <a href="#editor-integrations">Editor Integrations</a> section below.</p>
</div>
<div class="paragraph">
<p>Having said that, keep in mind that the REPL is a full-feature execution environment: in particular, you can use it
to launch special-purpose visualization tools (including ones that you develop yourself).
For instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><a href="https://github.com/metasoarous/oz">oz</a></strong> is a Clojure library for displaying numerical charts;</p>
</li>
<li>
<p><strong><a href="https://github.com/eggsyntax/datawalk">datawalk</a></strong> is a Clojure library for interactively exploring complex
Clojure data structures.</p>
</li>
<li>
<p><strong><a href="https://github.com/walmartlabs/system-viz">system-viz</a></strong> is a Clojure library for visualizing the components of a running
Clojure system.</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>I want to customize my REPL.</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>You can usually customize how your REPL reads, evaluates and prints, but the method to do it
depends on your toolchain. For instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when using a REPL started from <a href="xref/../../../reference/repl_and_main">clojure.main</a> - as is the case when using the <code>clj</code> tool,
you can customize the REPL by launching a 'sub-REPL': see <a href="https://clojure.github.io/clojure/clojure.main-api.html#clojure.main/repl">clojure.main/repl</a>.</p>
</li>
<li>
<p>when using <a href="https://github.com/clojure/tools.nrepl">nREPL</a>.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>, this can be done by writing custom <a href="https://github.com/clojure/tools.nrepl#middleware">middleware</a>.</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><em>I want to use the REPL to connect to a live production system.</em></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>The Clojure <a href="xref/../../../reference/repl_and_main#launching_a_socket_server">Socket Server</a> feature can be used
to that end. Tools like <strong><a href="https://github.com/clojure/tools.nrepl">tools.nrepl</a></strong> and <strong><a href="https://github.com/Unrepl/unrepl">unrepl</a></strong>
can be used to provide a richer experience.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong><em>NOTE: You may not need all of this!</em></strong></p>
</div>
<div class="paragraph">
<p>Depending on your projects and personal taste, you will most likely use only a fraction of the tools and techniques presented in this section.
It&#8217;s important to know that these options exist, but don&#8217;t try to adopt all of them at once!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="editor-integrations"><a class="anchor" href="#editor-integrations"></a>Editor integrations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All <a href="xref/../../../community/resources#_clojure_tools">major Clojure editors</a> support a way of evaluating code in the REPL without leaving
the current code buffer, which reduces the amount of context switching a programmer has to do.
Here&#8217;s what it looks like (the editor used in this example is <a href="https://cursive-ide.com/userguide/repl.html">Cursive</a>):</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/images/content/guides/repl/cursive-repl-demo.gif" alt="Editor REPL integration"></span></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>TIP:</strong> You can wrap some expressions in a <code>(<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/comment">comment</a> &#8230;&#8203;)</code>
block so that they don&#8217;t get evaluated by accident when the file is loaded:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; you would NOT want this function to get called by accident.
(defn transfer-money!
  [from-accnt to-accnt amount]
  ...)

(comment
  (transfer-money! "accnt243251" "accnt324222" 12000)
  )</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_what_to_expect_from_an_in_editor_repl_integration"><a class="anchor" href="#_what_to_expect_from_an_in_editor_repl_integration"></a>What to expect from an in-editor REPL integration?</h3>
<div class="paragraph">
<p>Here are some common editor commands provided by REPL integrations. All major Clojure
editors support a majority of them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Send form before caret to REPL:</strong> evaluate the expression before the cursor in the REPL,
in the namespace of the current file. Useful for experimenting in the context of the current namespace.</p>
</li>
<li>
<p><strong>Send top-level form to REPL:</strong> evaluate the biggest expression in which the cursor is currently contained
-typically a <code>(defn &#8230;&#8203;)</code> or <code>(def &#8230;&#8203;)</code> expression-in the namespace of the current file.
Useful for defining or re-defining Vars in a namespace.</p>
</li>
<li>
<p><strong>Load the current file in the REPL.</strong> Useful to avoid <a href="#_working_with_libs">loading libs manually</a>.</p>
</li>
<li>
<p><strong>Switch the REPL&#8217;s namespace to current file:</strong> useful to avoid typing <code>(in-ns '&#8230;&#8203;)</code>.</p>
</li>
<li>
<p><strong>Show evaluation inline:</strong> displays the evaluation of the current expression next to it.</p>
</li>
<li>
<p><strong>Replace expression with its evaluation:</strong> replaces the current expression in the editor with its evaluation (as printed by the REPL).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging-tools-and-techniques"><a class="anchor" href="#debugging-tools-and-techniques"></a>Debugging tools and techniques</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While traditional debuggers can be used with Clojure, the REPL itself is a powerful debugging environment,
because it lets you inspect and alter the flow of a running program. In this section, we&#8217;ll study some
tools and techniques to leverage the REPL for debugging.</p>
</div>
<div class="sect2">
<h3 id="_printing_in_flight_values_with_prn"><a class="anchor" href="#_printing_in_flight_values_with_prn"></a>Printing in-flight values with <code>prn</code></h3>
<div class="paragraph">
<p><code>(<a href="https://clojuredocs.org/clojure.core/prn">prn</a> &#8230;&#8203;)</code> expressions can be added in strategic places in your code to print intermediary values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">(defn average
  "a buggy function for computing the average of some numbers."
  [numbers]
  (let [sum (first numbers)
        n (count numbers)]
    (prn sum) ;; HERE printing an intermediary value
    (/ sum n)))
#'user/average
user=&gt; (average [12 14])
12 ## HERE
6</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>TIP:</strong> you can combine prn with the <code>(<a href="https://clojuredocs.org/clojure.core/doto">doto</a> &#8230;&#8203;)</code> macro, i.e <code>(doto MY-EXPR prn)</code>,
to make adding <code>prn</code> calls less invasive:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn average
  "a buggy function for computing the average of some numbers."
  [numbers]
  (let [sum (first numbers)
        n (count numbers)]
    (/
      (doto sum prn) ;; HERE
      n)))</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_going_further_spying_macros"><a class="anchor" href="#_going_further_spying_macros"></a>Going further: 'spying' macros</h4>
<div class="paragraph">
<p>Some Clojure libraries provide 'enhanced' versions of <code>prn</code> that are more informative, by also printing information
about the wrapped expression. For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <strong><a href="https://github.com/clojure/tools.logging">tools.logging</a></strong> logging library
provides a <a href="http://clojure.github.io/tools.logging/#clojure.tools.logging/spy">spy</a> macro to log an expression&#8217;s code along
with its value</p>
</li>
<li>
<p>the <strong><a href="https://github.com/dgrnbrg/spyscope">spyscope</a></strong> library lets you to insert these printing calls with very
lightweight syntax.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_going_further_tracing_libraries"><a class="anchor" href="#_going_further_tracing_libraries"></a>Going further: tracing libraries</h4>
<div class="paragraph">
<p><em>Tracing</em> libraries such as <strong><a href="https://github.com/clojure/tools.trace">tools.trace</a></strong> and <strong><a href="http://bpiel.github.io/sayid/">Sayid</a></strong>
can help you instrument larger portions of your code, for example by automatically printing all the function calls in a
given namespace, or all intermediary values in a given expression.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_intercepting_and_saving_values_on_the_fly"><a class="anchor" href="#_intercepting_and_saving_values_on_the_fly"></a>Intercepting and saving values on-the-fly</h3>
<div class="paragraph">
<p>Sometimes you want to do more with intermediary values than just print them:
you want to save them to conduct further experiments on them at the REPL.
This can be done by inserting a <code>(def &#8230;&#8203;)</code> call inside the expression where the value appears:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn average
  [numbers]
  (let [sum (apply + numbers)
        n (count numbers)]
    (def n n) ;; FIXME remove when you're done debugging
    (/ sum n)))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; (average [1 2 3])
2
user=&gt; n
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>This 'inline-def' technique is described in more depth in <a href="https://blog.michielborkent.nl/blog/2017/05/25/inline-def-debugging/">this blog post by Michiel Borkent</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reproducing_the_context_of_an_expression"><a class="anchor" href="#_reproducing_the_context_of_an_expression"></a>Reproducing the context of an expression</h3>
<div class="paragraph">
<p>When debugging at the REPL, we often want to reproduce manually something that our program did automatically,
that is evaluating some expressions inside a function body. To do that, we need to recreate the context
of the expressions of interest: one trick to achieve that is to define Vars (using <code>def</code>) with the same names
and values as the locals used by the expressions. The 'physics' example below illustrates this approach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(def G 6.67408e-11)
(def earth-radius 6.371e6)
(def earth-mass 5.972e24)

(defn earth-gravitational-force
  "Computes (an approximation of) the gravitational force between Earth and an object
  of mass `m`, at distance `r` of Earth's center."
  [m r]
  (/
    (*
      G
      m
      (if (&gt;= r earth-radius)
        earth-mass
        (*
          earth-mass
          (Math/pow (/ r earth-radius) 3.0))))
    (* r r)))

;;;; calling our function for an object of 80kg at distance 5000km.
(earth-gravitational-force 80 5e6) ; =&gt; 616.5217226636292

;;;; recreating the context of our call
(def m 80)
(def r 5e6)
;; note: the same effect could be achieved using the 'inline-def' technique described in the previous section.

;;;; we can now directly evaluate any expression in the function body:
    (* r r) ; =&gt; 2.5E13

          (&gt;= r earth-radius) ; =&gt; false

          (Math/pow (/ r earth-radius) 3.0) ; =&gt; 0.48337835316173317</code></pre>
</div>
</div>
<div class="paragraph">
<p>This technique is described in more depth in Stuart Halloway&#8217;s article
<a href="http://blog.cognitect.com/blog/2017/6/5/repl-debugging-no-stacktrace-required">REPL Debugging: No Stacktrace Required</a>.
The <strong><a href="https://github.com/vvvvalvalval/scope-capture">scope-capture</a></strong> library was made to automate
the manual task of saving and re-creating the context of an expression.</p>
</div>
</div>
<div class="sect2">
<h3 id="_community_resources_about_repl_debugging"><a class="anchor" href="#_community_resources_about_repl_debugging"></a>Community resources about REPL debugging</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.clojure-toolbox.com/">The Clojure Toolbox</a> provides a list a Clojure libraries for debugging.</p>
</li>
<li>
<p><a href="https://cambium.consulting/articles/2018/2/8/the-power-of-clojure-debugging">The Power of Clojure: debugging</a>
is an article by Cambium Consulting which provides a list of techniques for debugging at the REPL.</p>
</li>
<li>
<p><em>Clojure From the Ground Up</em> by Aphyr contains a <a href="https://aphyr.com/posts/319-clojure-from-the-ground-up-debugging">chapter about debugging</a>,
presenting techniques for debugging Clojure in particular and a principled approach to debugging in general.</p>
</li>
<li>
<p>In his article <a href="http://blog.cognitect.com/blog/2017/6/5/repl-debugging-no-stacktrace-required">REPL Debugging: No Stacktrace Required</a>,
Stuart Halloway demonstrates how the quick feedback loop at the REPL can be used to narrow down the cause of a bug
without using error information at all.</p>
</li>
<li>
<p>Eli Bendersky has written some <a href="https://eli.thegreenplace.net/2017/notes-on-debugging-clojure-code/#id3">Notes on debugging Clojure code</a>.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=FihU5JxmnBg">Debugging with the Scientific Method</a> is a conference talk by Stuart Halloway
promoting a scientific approach to debugging in general.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="writing-repl-friendly-programs"><a class="anchor" href="#writing-repl-friendly-programs"></a>Writing REPL-friendly programs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While interactive development at the REPL gives a lot of power to programmers,
it also adds new challenges: programs must be designed so that they lend themselves
well to REPL interaction, which is a new constraint to be vigilant of when writing code.<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p>
</div>
<div class="paragraph">
<p>Covering this topic extensively would take us too far for the scope of this guide,
so we will merely provide some tips and resources to guide your own research and problem-solving.</p>
</div>
<div class="paragraph">
<p><strong><em>REPL-friendly code can be re-defined.</em></strong> Code is more easily redefined when it is called via a Var
(defined e.g via <code>(def &#8230;&#8203;)</code> or <code>(defn &#8230;&#8203;)</code>), because a Var can be redefined without touching the code that calls it.
This is illustrated in the following example, which prints some numbers at a regular time interval:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; Each of these 4 code examples start a loop in another thread
;; which prints numbers at a regular time interval.

;;;; 1. NOT REPL-friendly
;; We won't be able to change the way numbers are printed without restarting the REPL.
(future
  (run!
    (fn [i]
      (println i "green bottles, standing on the wall. ♫")
      (Thread/sleep 1000))
    (range)))

;;;; 2. REPL-friendly
;; We can easily change the way numbers are printed by re-defining print-number-and-wait.
;; We can even stop the loop by having print-number-and-wait throw an Exception.
(defn print-number-and-wait
  [i]
  (println i "green bottles, standing on the wall. ♫")
  (Thread/sleep 1000))

(future
  (run!
    (fn [i] (print-number-and-wait i))
    (range)))

;;;; 3. NOT REPL-friendly
;; Unlike the above example, the loop can't be altered by re-defining print-number-and-wait,
;; because the loop uses the value of print-number-and-wait, not the #'print-number-and-wait Var.
(defn print-number-and-wait
  [i]
  (println i "green bottles, standing on the wall. ♫")
  (Thread/sleep 1000))

(future
  (run!
    print-number-and-wait
    (range)))

;;;; 4. REPL-friendly
;; The following works because a Clojure Var is (conveniently) also a function,
;; which consist of looking up its value (presumably a function) and calling it.
(defn print-number-and-wait
  [i]
  (println i "green bottles, standing on the wall. ♫")
  (Thread/sleep 1000))

(future
  (run!
    #'print-number-and-wait ;; mind the #' - the expression evaluates to the #'print-number-and-wait Var, not its value.
    (range)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><em>Beware of derived Vars.</em></strong> If Var <code>b</code> is defined in terms of the value of Var <code>a</code>,
then you will need to re-define <code>b</code> each time you re-define <code>a</code>; it may be better to define
<code>b</code> as a 0-arity function which uses <code>a</code>. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;;; NOT REPL-friendly
;; if you re-define `solar-system-planets`, you have to think of re-defining `n-planets` too.
(def solar-system-planets
  "The set of planets which orbit the Sun."
  #{"Mercury" "Venus" "Earth" "Mars" "Jupiter" "Saturn" "Uranus" "Neptune"})

(def n-planets
  "The number of planets in the solar system"
  (count solar-system-planets))


;;;; REPL-friendly
;; if you re-define `solar-system-planets`, the behaviour of `n-planets` will change accordingly.
(def solar-system-planets
  "The set of planets which orbit the Sun."
  #{"Mercury" "Venus" "Earth" "Mars" "Jupiter" "Saturn" "Uranus" "Neptune"})

(defn n-planets
  "The number of planets in the solar system"
  []
  (count solar-system-planets))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><em>REPL-friendly code can be reloaded.</em></strong> Make sure that reloading a namespace will not alter the
behaviour of the running program. If a Var needs to be defined exactly once (which should be very rare),
consider defining it with <code><a href="https://clojuredocs.org/clojure.core/defonce">defonce</a></code>.</p>
</div>
<div class="paragraph">
<p>When dealing with a codebase with many namespaces, reloading the appropriate namespaces in the correct
order can become difficult: the <strong><a href="https://github.com/clojure/tools.namespace">tools.namespace</a></strong> library
was made to assist the programmer in this task.</p>
</div>
<div class="paragraph">
<p><strong><em>Program state and source code should be kept in sync.</em></strong> You usually want to make sure
that your program state reflects your source code and vice-versa, but this is not automatic.
Reloading the code is often not enough: you also need to transform the program state accordingly.
Stuart Sierra has expounded on this problem in his article <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">My Clojure Workflow, Reloaded</a>
and his talk <a href="https://www.youtube.com/watch?v=13cmHf_kt-Q">Components Just Enough Structure</a>.</p>
</div>
<div class="paragraph">
<p>This has motivated the creation of <strong><em>state management libraries:</em></strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><a href="https://github.com/stuartsierra/component">Component</a></strong>, which promotes a representation of program state
as a managed map of Clojure records called a <strong>system</strong>.</p>
</li>
<li>
<p><strong><a href="https://github.com/danielsz/system">System</a></strong> is a library on top of <a href="https://github.com/stuartsierra/component">Component</a>
which provides a set of ready-made components.</p>
</li>
<li>
<p><strong><a href="https://github.com/tolitius/mount">Mount</a></strong> takes a radically different approach as Component, choosing to
use Vars and namespaces as the supporting infrastructure for state.<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup></p>
</li>
<li>
<p><strong><a href="https://github.com/weavejester/integrant">Integrant</a></strong> is a more recent library which shares Component&#8217;s approach
while addressing some of its perceived limitations.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. At the time of writing (March 2018), <a href="https://github.com/clojure/tools.nrepl">nREPL</a> is the most popular toolchain for REPL-editor integration
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. A similar phenomenon happens with the well-known technique of <a href="https://en.wikipedia.org/wiki/Software_testing">automated testing</a>: while testing can bring a lot of value to programmers, it requires extra care to write code that is 'testable'. Just like tests, the REPL should not be an afterthought when writing Clojure code.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. At the time of writing, there is controversy in the Clojure community regarding the relative merits of both approaches.
</div>
</div></p>

<div class="clja-prev-next-container">
  <a href="navigating_namespaces" class="clja-prev-link"><span class="clja-prevnext-link-icon">←</span>&nbsp;Navigating Namespaces</a>
  <a href="annex_community_resources" class="clja-next-link">Annex: Community resources about the REPL&nbsp;<span class="clja-prevnext-link-icon">→</span></a>
</div>

<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../js/jquery-1.11.1.min.js"></script>
    <script src="../../js/bootstrap.min.js"></script>
    <script src="../../js/prettify.js"></script>

  </body>
</html>