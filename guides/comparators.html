<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>Clojure - Comparators Guide</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clojure の日本語ドキュメントです">
    <meta name="author" content="Japan Clojurians">
    <meta name="keywords" content="Clojure 日本語">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/normalize.css" rel="stylesheet">
    <link href="../css/webflow.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" type="image/x-icon" href="../images/clojure-logo-icon-32.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">Clojure</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../about/rationale">概要</a></li>
            <li><a href="../reference/documentation">リファレンス</a></li>
            <!-- <li><a href="../api/api">API</a></li>
              <li><a href="../community/downloads">リリース</a></li> -->
              <li><a href="../guides/guides">ガイド</a></li>
            <!-- <li><a href="../community/resources">コミュニティ</a></li>
              <li><a href="../news/news">ニュース</a></li>
              <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
              <li><a href="#">Action</a></li>
              <li><a href="#">Another action</a></li>
              <li><a href="#">Something else here</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Nav header</li>
              <li><a href="#">Separated link</a></li>
              <li><a href="#">One more separated link</a></li>
              </ul>
              </li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

<div class="page-header">
  <h1>Comparators Guide</h1>
</div>

<p><em></em></p>

<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Note: This document describes Clojure 1.7 and Java 6, but applies to most other versions as well.</em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary"><a class="anchor" href="#_summary"></a>Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A comparator is a function that takes two arguments <em>x</em> and <em>y</em> and returns a value indicating
the relative order in which <em>x</em> and <em>y</em> should be sorted. It can be a 3-way comparator returning
an integer, or a 2-way comparator returning a boolean.
See the DOs below for what the return values should be, depending upon the order of <em>x</em> and <em>y</em>.</p>
</div>
<div class="paragraph">
<p>In Clojure you need comparators for sorting a collection of values, or for maintaining a collection
of values in a desired sorted order, e.g a
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-map">sorted-map</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-set">sorted-set</a>, or
<a href="https://clojure.github.io/data.priority-map/#clojure.data.priority-map/priority-map">priority-map</a>
(also known as a priority queue).</p>
</div>
<div class="paragraph">
<p>The default comparator <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/compare">compare</a>
works well for sorting numbers in increasing order, or strings, keywords, or symbols,
in <a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographic</a> (i.e dictionary) order,
and a few other cases. See <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/compare">compare</a>
for examples and more details.</p>
</div>
<div class="paragraph">
<p>If <code>compare</code> does not do what you want, you must provide your own comparator that does. Each of the
recommendations below is explained in more detail later in this document.</p>
</div>
<div class="paragraph">
<p>DOs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensure that your comparators are based on a <a href="https://en.wikipedia.org/wiki/Total_order">total order</a> over
the values you want to compare. It should be able to compare any pair of values that can appear in your
data set, and determine which value should come first (or that they are equal).</p>
</li>
<li>
<p>Write either a 3-way comparator or a boolean comparator:</p>
<div class="ulist">
<ul>
<li>
<p>A 3-way comparator takes 2 values, <em>x</em> and <em>y</em>, and returns a Java 32-bit <em>int</em> that is negative if
<em>x</em> comes before <em>y</em>, positive if <em>x</em> comes after <em>y</em>, or 0 if they are equal. Use values -1, 0, and 1
if you have no reason to prefer other return values.</p>
</li>
<li>
<p>A boolean comparator takes 2 values, <em>x</em> and <em>y</em>, and returns true if <em>x</em> comes before <em>y</em>, or
false otherwise (including if <em>x</em> and <em>y</em> are equal). <code>&lt;</code> and <code>&gt;</code> are good examples. <code>&lt;=</code>
and <code>&gt;=</code> are not. Performance note: your boolean comparator may be called twice to distinguish
between the "comes after" or "equals" cases.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Reverse the sort by reversing the order that you give the arguments to an existing comparator.</p>
</li>
<li>
<p>Compare equal-length Clojure vectors containing "sort keys" in order to do a multi-field comparison
between values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>DO NOTs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Do not write a boolean comparator that returns true if the values are equal. Such a comparator is
inconsistent. It will cause sorted collections to behave incorrectly, and sorting to give unpredictable
orders.</p>
</li>
<li>
<p>Do not use comparators for sorted sets and maps that treat two values as equal, unless you want
at most one of those two values to appear in the sorted collection.</p>
</li>
<li>
<p>Do not use subtraction when writing a 3-way comparator, unless you really know what you are doing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See also: <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/compare">compare</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sort">sort</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sort-by">sort-by</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-set">sorted-set</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-set-by">sorted-set-by</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-map">sorted-map</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-map-by">sorted-map-by</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/subseq">subseq</a>,
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rsubseq">rsubseq</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here we briefly describe the default sorting order provided by the function <code>compare</code>.
After that we give examples of other comparators, with some guidelines to follow and
mistakes to avoid when writing your own.</p>
</div>
<div class="paragraph">
<p>If you do not specify your own comparator, sorting is done by a built-in function <code>compare</code>.
<code>compare</code> works for many types of values, ordering them in one particular way: increasing
numeric order for numbers; <a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographic order</a>
(aka dictionary order) for strings, symbols, and keywords; shortest-to-longest order by Clojure
vectors, with lexicographic ordering among equal length vectors. All Java types implement
the <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</a>
interface such as characters, booleans, File, URI, and UUID are compared via their
<code>compareTo</code> methods. Finally, <code>nil</code> can be compared to all values described earlier, and
is considered less than everything else.
See <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/compare">compare</a>
for examples and more details.</p>
</div>
<div class="paragraph">
<p>If this built-in sorting order does not meet your needs, or does not work at all for values
of type you wish to sort, you can write your own comparator and use that instead.
There are a few rules to follow when writing a comparator that works correctly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_off_the_shelf_comparators"><a class="anchor" href="#_off_the_shelf_comparators"></a>Off-the-shelf comparators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First consider using well-tested comparators developed by others, especially if they are complex.</p>
</div>
<div class="paragraph">
<p>A perfect example of this would be sorting Unicode strings in different languages in orders
specific to different locales. The Java <a href="http://docs.oracle.com/javase/6/docs/api/java/text/Collator.html">Collator</a>
class and <a href="http://site.icu-project.org/home#TOC-What-is-ICU-">ICU</a> (International Components for Unicode) provide
libraries for this.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_your_own_comparators"><a class="anchor" href="#_writing_your_own_comparators"></a>Writing your own comparators</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_reverse_order"><a class="anchor" href="#_reverse_order"></a>Reverse order</h3>
<div class="paragraph">
<p>To sort numbers in decreasing order, simply write a comparator that calls <code>compare</code> with the arguments
in the opposite order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user&gt; (sort [4 2 3 1])
(1 2 3 4)

user&gt; (defn reverse-cmp [a b]
        (compare b a))
#'user/reverse-cmp

user&gt; (sort reverse-cmp [4 3 2 1])
(4 3 2 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such short functions are often written using Clojure&#8217;s #() notation, where the two arguments
are %1 and %2, in that order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user&gt; (sort #(compare %2 %1) [4 3 2 1])</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>reverse-cmp</code> will also work for all other types <code>compare</code> works for.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_field_comparators"><a class="anchor" href="#_multi_field_comparators"></a>Multi-field comparators</h3>
<div class="paragraph">
<p>Because equal-length Clojure vectors are compared lexicographically, they can be used to do multi-field
sorting on values like maps or records. This only works if the fields are already sorted by <code>compare</code>
in the order you wish (or the reverse of that).</p>
</div>
<div class="paragraph">
<p>First we will show a way to do it that does not compare vectors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(def john1 {:name "John", :salary 35000.00, :company "Acme"})
(def mary  {:name "Mary", :salary 35000.00, :company "Mars Inc"})
(def john2 {:name "John", :salary 40000.00, :company "Venus Co"})
(def john3 {:name "John", :salary 30000.00, :company "Asteroids-R-Us"})
(def people [john1 mary john2 john3])

(defn by-salary-name-co [x y]
  ;; :salary values sorted in decreasing order because x and y
  ;; swapped in this compare.
  (let [c (compare (:salary y) (:salary x))]
    (if (not= c 0)
      c
      ;; :name and :company are sorted in increasing order
      (let [c (compare (:name x) (:name y))]
        (if (not= c 0)
          c
          (let [c (compare (:company x) (:company y))]
            c))))))

user&gt; (pprint (sort by-salary-name-co people))
({:name "John", :salary 40000.0, :company "Venus Co"}
 {:name "John", :salary 35000.0, :company "Acme"}
 {:name "Mary", :salary 35000.0, :company "Mars Inc"}
 {:name "John", :salary 30000.0, :company "Asteroids-R-Us"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is the shorter way, by comparing Clojure vectors. It behaves exactly the same as above. Note that
as above, the field :salary is sorted in descending order because <em>x</em> and <em>y</em> are swapped.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn by-salary-name-co2 [x y]
    (compare [(:salary y) (:name x) (:company x)]
             [(:salary x) (:name y) (:company y)]))

user&gt; (pprint (sort by-salary-name-co2 people))
({:name "John", :salary 40000.0, :company "Venus Co"}
 {:name "John", :salary 35000.0, :company "Acme"}
 {:name "Mary", :salary 35000.0, :company "Mars Inc"}
 {:name "John", :salary 30000.0, :company "Asteroids-R-Us"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above is fine for key values that are inexpensive to compute from the values being sorted.
If the key values are expensive to compute, it is better to calculate them once for each value.
See the "decorate-sort-undecorate" technique described in the documentation for
<a href="https://github.com/jafingerhut/thalia/blob/master/doc/project-docs/clojure.core-1.5.1/clojure.core/sort-by.md">sort-by</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_boolean_comparators"><a class="anchor" href="#_boolean_comparators"></a>Boolean comparators</h3>
<div class="paragraph">
<p>Java comparators are all 3-way, meaning they return a negative, 0, or positive integer depending upon whether
the first argument should be considered less than, equal to, or greater than the second argument.</p>
</div>
<div class="paragraph">
<p>In Clojure, you may also use boolean comparators that return <code>true</code> if the first argument should come before
the second argument, or <code>false</code> otherwise (i.e. should come after, or it is equal).
The function <code>&lt;</code> is a perfect example, as long as you only need to compare numbers. <code>&gt;</code> works for sorting
numbers in decreasing order.
Behind the scenes, when such a Clojure function <code>bool-cmp-fn</code> is "called as a comparator",
Clojure runs code that works like this to return an <em>int</em> instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(if (bool-cmp-fn x y)
  -1     ; x &lt; y
  (if (bool-cmp-fn y x)  ; note the reversed argument order
    1    ; x &gt; y
    0))  ; x = y</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see this by calling the compare method of any Clojure function.
Below is an example with a custom version <code>my-&lt;</code> of <code>&lt;</code> that prints its arguments when it is called,
so you can see the cases where it is called more than once:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user&gt; (defn my-&lt; [a b]
        (println "(my-&lt;" a b ") returns " (&lt; a b))
        (&lt; a b))
#'user/my-&lt;

;; (. o (compare a b)) calls the method named compare for object
;; o, with arguments a and b.  In this case the object is the
;; Clojure function my-&lt;
user&gt; (. my-&lt; (compare 1 2))
(my-&lt; 1 2 ) returns  true
-1
user&gt; (. my-&lt; (compare 2 1))
(my-&lt; 2 1 ) returns  false
(my-&lt; 1 2 ) returns  true
1
user&gt; (. my-&lt; (compare 1 1))
(my-&lt; 1 1 ) returns  false
(my-&lt; 1 1 ) returns  false
0

;; Calling a Clojure function in the normal way uses its invoke
;; method, not compare.
user&gt; (. my-&lt; (invoke 2 1))
(my-&lt; 2 1 ) returns  false
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>See Clojure source file
<a href="https://github.com/clojure/clojure/blob/clojure-1.7.0/src/jvm/clojure/lang/AFunction.java#L46">src/jvm/clojure/lang/AFunction.java</a>
method <code>compare</code> if you want all the details.</p>
</div>
</div>
<div class="sect2">
<h3 id="_general_rules_for_comparators"><a class="anchor" href="#_general_rules_for_comparators"></a>General rules for comparators</h3>
<div class="paragraph">
<p>Any comparator, whether 3-way or boolean, should return answers consistent with a
<a href="https://en.wikipedia.org/wiki/Total_order">total order</a> on the values
you want to compare.</p>
</div>
<div class="paragraph">
<p>A total order is simply an ordering of all values from smallest to largest, where some groups of
values can all be equal to each other. Every pair of values must be comparable to each other
(i.e. no "I do not know how to compare them" answers from the comparator).</p>
</div>
<div class="paragraph">
<p>For example, you can order all fractions written in the form <em>m/n</em> for integers m and n from smallest
to largest, in the usual way this is done in mathematics. Many of the fractions would be equal to each
other, e.g. <em>1/2 = 2/4 = 3/6</em>. A comparator implementing that total order should behave as if
they are all the same.</p>
</div>
<div class="paragraph">
<p>A 3-way comparator <code>(cmp a b)</code> should return a negative, positive, or 0 <em>int</em> if <em>a</em> is before, after,
or is considered equal to b in the total order, respectively.</p>
</div>
<div class="paragraph">
<p>A boolean comparator <code>(cmp a b)</code> should return true if <em>a</em> is before <em>b</em> in the total order, or false
if <em>a</em> is after or considered equal to <em>b</em>. That is, it should work like <code>&lt;</code> does for numbers.
As explained later, it should not behave like <code>&lt;=</code> for numbers
(see section "Comparators for sorted sets and maps are easy to get wrong").</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mistakes_to_avoid"><a class="anchor" href="#_mistakes_to_avoid"></a>Mistakes to avoid</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_comparators_for_sorted_sets_and_maps_are_easy_to_get_wrong"><a class="anchor" href="#_comparators_for_sorted_sets_and_maps_are_easy_to_get_wrong"></a>Comparators for sorted sets and maps are easy to get wrong</h3>
<div class="paragraph">
<p>This is just as accurately stated as "comparators are easy to get wrong", but it is often more noticeable
when you use a bad comparator for sorted sets and maps. If you write the kinds of bad comparators in this
section and use them to call <code>sort</code>, usually little or nothing will go wrong (although inconsistent comparators
are not good for sorting, either). With sorted sets and maps, these bad comparators can cause values not to be
added to your sorted collections, or to be added but not be found when you search for them.</p>
</div>
<div class="paragraph">
<p>Suppose you want a sorted set containing vectors of two elements, where each is a string followed by a
number, e.g. <code>["a" 5]</code>. You want the set sorted by the number, and to allow multiple vectors with the same
number but different strings. Your first try might be to write something like <code>by-2nd</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn by-2nd [a b]
  (compare (second a) (second b)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>But look what happens when you try to add multiple vectors with the same number.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user&gt; (sorted-set-by by-2nd ["a" 1] ["b" 1] ["c" 1])
#{["a" 1]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only one element is in the set, because <code>by-2nd</code> treats all three of the vectors as equal. Sets should not contain duplicate elements,
so the other elements are not added.</p>
</div>
<div class="paragraph">
<p>A common thought in such a case is to use a boolean comparator function based on <code>&lt;=</code> instead of <code>&lt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn by-2nd-&lt;= [a b]
  (&lt;= (second a) (second b)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The boolean comparator <code>by-2nd-&lt;=</code> seems to work correctly on the first step of creating the set,
but fails when testing whether elements are in the set.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user&gt; (def sset (sorted-set-by by-2nd-&lt;= ["a" 1] ["b" 1] ["c" 1]))
#'user/sset
user&gt; sset
#{["c" 1] ["b" 1] ["a" 1]}
user&gt; (sset ["c" 1])
nil
user&gt; (sset ["b" 1])
nil
user&gt; (sset ["a" 1])
nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem here is that <code>by-2nd-&lt;=</code> gives inconsistent answers. If you ask it whether <code>["c" 1]</code> comes before <code>["b" 1]</code>,
it returns true (which Clojure&#8217;s boolean-to-int comparator conversion turns into -1).
f you ask it whether <code>["b" 1]</code> comes before <code>["c" 1]</code>, again it returns true (again converted into -1 by Clojure).
One cannot reasonably expect an implementation of a sorted data structure to provide any kind of guarantees on
its behavior if you give it an inconsistent comparator.</p>
</div>
<div class="paragraph">
<p>The techniques described in "Multi-field comparators" above provide correct comparators for this example.
In general, be wary of comparing only parts of values to each other. Consider having some kind of tie-breaking
condition after all of the fields of interest to you have been compared.</p>
</div>
<div class="paragraph">
<p>Aside: If you do not want multiple vectors in your set with the same number, <code>by-2nd</code> is the comparator you should use.
It gives exactly the behavior you want. (TBD: Are there any caveats here? Will <code>sorted-set</code> ever use <code>=</code> to compare elements
for any reason, or only the supplied comparator function?)</p>
</div>
</div>
<div class="sect2">
<h3 id="_beware_using_subtraction_in_a_comparator"><a class="anchor" href="#_beware_using_subtraction_in_a_comparator"></a>Beware using subtraction in a comparator</h3>
<div class="paragraph">
<p>Java comparators return a negative int value if the first argument is to be treated as less than the second,
a positive int value if the first argument is to be treated as greater than the second, and 0 if they are equal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user&gt; (compare 10 20)
-1
user&gt; (compare 20 10)
1
user&gt; (compare 20 20)
0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because of this, you might be tempted to write a comparator by subtracting one numeric value from another, like so.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user&gt; (sort #(- %1 %2) [4 2 3 1])
(1 2 3 4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>While this works in many cases, think twice (or three times) before using this technique.
It is less error-prone to use explicit conditional checks and return -1, 0, or 1, or to use boolean comparators.</p>
</div>
<div class="paragraph">
<p>Why? Java comparators must return a 32-bit <em>int</em> type, so when a Clojure function is used as a comparator
and it returns any type of number, that number is converted to an <em>int</em> behind the scenes using the Java method
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Number.html#intValue%28%29">intValue</a>.
See Clojure source file
<a href="https://github.com/clojure/clojure/blob/clojure-1.7.0/src/jvm/clojure/lang/AFunction.java#L46">src/jvm/clojure/lang/AFunction.java</a>
method <code>compare</code> if you want the details.</p>
</div>
<div class="paragraph">
<p>For comparing floating point numbers and ratios, this causes numbers differing by less than 1 to be treated as equal,
because a return value between -1 and 1 is truncated to the <em>int</em> 0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; This gives the correct answer
user&gt; (sort #(- %1 %2) [10.0 9.0 8.0 7.0])
(7.0 8.0 9.0 10.0)

;; but this does not, because all values are treated as equal by
;; the bad comparator.
user&gt; (sort #(- %1 %2) [1.0 0.9 0.8 0.7])
(1.0 0.9 0.8 0.7)

;; .intValue converts all values between -1.0 and 1.0 to 0
user&gt; (map #(.intValue %) [-1.0 -0.99 -0.1 0.1 0.99 1.0])
(-1 0 0 0 0 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This also leads to bugs when comparing integer values that differ by amounts that change sign when you
truncate it to a 32-bit <em>int</em> (by discarding all but its least significant 32 bits).
About half of all pairs of long values are compared incorrectly by using subtraction as a comparator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; This looks good
user&gt; (sort #(- %1 %2) [4 2 3 1])
(1 2 3 4)

;; What the heck?
user&gt; (sort #(- %1 %2) [2147483650 2147483651 2147483652 4 2 3 1])
(3 4 2147483650 2147483651 2147483652 1 2)

user&gt; [Integer/MIN_VALUE Integer/MAX_VALUE]
[-2147483648 2147483647]

;; How .intValue truncates a few selected values.  Note especially
;; the first and last ones.
user&gt; (map #(.intValue %) [-2147483649 -2147483648 -1 0 1
                            2147483647  2147483648])
(2147483647 -2147483648 -1 0 1 2147483647 -2147483648)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java itself uses a subtraction comparator for strings and characters, among others.
This does not cause any problems, because the result of subtracting an arbitrary pair of 16-bit characters
converted to ints is guaranteed to fit within an <em>int</em> without wrapping around.
If your comparator is not guaranteed to be given such restricted inputs, better not to risk it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comparators_that_work_between_different_types"><a class="anchor" href="#_comparators_that_work_between_different_types"></a>Comparators that work between different types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes you might wish to sort a collection of values by some key, but that key is not unique.
You want the values with the same key to be sorted in some predictable, repeatable order,
but you do not care much what that order is.</p>
</div>
<div class="paragraph">
<p>As a toy example, you might have a collection of vectors, each with two elements,
where the first element is always a string and the second is always a number.
You want to sort them by the number value in increasing order, but you know your data can contain more
than one vector with the same number. You want to break ties in some way,
consistently across multiple sorts.</p>
</div>
<div class="paragraph">
<p>This case is easily implemented using a multi-field comparator as described in an earlier section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn by-number-then-string [[a-str a-num] [b-str b-num]]
  (compare [a-num a-str]
           [b-num b-str]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the entire vector values can be compared with <code>compare</code>, because all vectors are equal length,
and the type of each corresponding elements can be compared to each other with <code>compare</code>,
then you can also do this, using the entire vector values as the final tie-breaker:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn by-number-then-whatever [a-vec b-vec]
  (compare [(second a-vec) a-vec]
           [(second b-vec) b-vec]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, that will throw an exception if some element position in the vectors contain types too different
for <code>compare</code> to work on, and those vectors have the same second element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; compare throws exception if you try to compare a string and a
;; keyword
user&gt; (sort by-number-then-whatever [["a" 2] ["c" 3] [:b 2]])
ClassCastException java.lang.String cannot be cast to clojure.lang.Keyword  clojure.lang.Keyword.compareTo (Keyword.java:109)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cc-cmp</code> ("cross class compare") below may be useful in such cases.
It can compare values of different types, which it orders based on a string that represents the type of the value.
It is not simply <code>(class x)</code>, because then numbers like <code>Integer</code> and <code>Long</code> would not be sorted in numeric order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">;; comparison-class throws exceptions for some types that might be
;; useful to include.

(defn comparison-class [x]
  (cond (nil? x) ""
        ;; Lump all numbers together since Clojure's compare can
        ;; compare them all to each other sensibly.
        (number? x) "java.lang.Number"

        ;; sequential? includes lists, conses, vectors, and seqs of
        ;; just about any collection, although it is recommended not
        ;; to use this to compare seqs of unordered collections like
        ;; sets or maps (vectors should be OK).  This should be
        ;; everything we would want to compare using cmp-seq-lexi
        ;; below.  TBD: Does it leave anything out?  Include anything
        ;; it should not?
        (sequential? x) "clojure.lang.Sequential"

        (set? x) "clojure.lang.IPersistentSet"
        (map? x) "clojure.lang.IPersistentMap"
        (.isArray (class x)) "java.util.Arrays"

        ;; Comparable includes Boolean, Character, String, Clojure
        ;; refs, and many others.
        (instance? Comparable x) (.getName (class x))
        :else (throw
               (ex-info (format "cc-cmp does not implement comparison of values with class %s"
                                (.getName (class x)))
                        {:value x}))))

(defn cmp-seq-lexi
  [cmpf x y]
  (loop [x x
         y y]
    (if (seq x)
      (if (seq y)
        (let [c (cmpf (first x) (first y))]
          (if (zero? c)
            (recur (rest x) (rest y))
            c))
        ;; else we reached end of y first, so x &gt; y
        1)
      (if (seq y)
        ;; we reached end of x first, so x &lt; y
        -1
        ;; Sequences contain same elements.  x = y
        0))))

;; The same result can be obtained by calling cmp-seq-lexi on two
;; vectors, but cmp-vec-lexi should allocate less memory comparing
;; vectors.
(defn cmp-vec-lexi
  [cmpf x y]
  (let [x-len (count x)
        y-len (count y)
        len (min x-len y-len)]
    (loop [i 0]
      (if (== i len)
        ;; If all elements 0..(len-1) are same, shorter vector comes
        ;; first.
        (compare x-len y-len)
        (let [c (cmpf (x i) (y i))]
          (if (zero? c)
            (recur (inc i))
            c))))))

(defn cmp-array-lexi
  [cmpf x y]
  (let [x-len (alength x)
        y-len (alength y)
        len (min x-len y-len)]
    (loop [i 0]
      (if (== i len)
        ;; If all elements 0..(len-1) are same, shorter array comes
        ;; first.
        (compare x-len y-len)
        (let [c (cmpf (aget x i) (aget y i))]
          (if (zero? c)
            (recur (inc i))
            c))))))


(defn cc-cmp
  [x y]
  (let [x-cls (comparison-class x)
        y-cls (comparison-class y)
        c (compare x-cls y-cls)]
    (cond (not= c 0) c  ; different classes

          ;; Compare sets to each other as sequences, with elements in
          ;; sorted order.
          (= x-cls "clojure.lang.IPersistentSet")
          (cmp-seq-lexi cc-cmp (sort cc-cmp x) (sort cc-cmp y))

          ;; Compare maps to each other as sequences of [key val]
          ;; pairs, with pairs in order sorted by key.
          (= x-cls "clojure.lang.IPersistentMap")
          (cmp-seq-lexi cc-cmp
                        (sort-by key cc-cmp (seq x))
                        (sort-by key cc-cmp (seq y)))

          (= x-cls "java.util.Arrays")
          (cmp-array-lexi cc-cmp x y)

          ;; Make a special check for two vectors, since cmp-vec-lexi
          ;; should allocate less memory comparing them than
          ;; cmp-seq-lexi.  Both here and for comparing sequences, we
          ;; must use cc-cmp recursively on the elements, because if
          ;; we used compare we would lose the ability to compare
          ;; elements with different types.
          (and (vector? x) (vector? y)) (cmp-vec-lexi cc-cmp x y)

          ;; This will compare any two sequences, if they are not both
          ;; vectors, e.g. a vector and a list will be compared here.
          (= x-cls "clojure.lang.Sequential")
          (cmp-seq-lexi cc-cmp x y)

          :else (compare x y))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a quick example demonstrating `cc-cmp&#8217;s ability to compare values of different types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user&gt; (pprint (sort cc-cmp [true false nil Double/MAX_VALUE 10
                            Integer/MIN_VALUE :a "b" 'c (ref 5)
                            [5 4 3] '(5 4) (seq [5]) (cons 6 '(1))
                            #{1 2 3} #{2 1}
                            {:a 1, :b 2} {:a 1, :b -2}
                            (object-array [1 2 3 4])]))
(nil
 {:a 1, :b -2}
 {:a 1, :b 2}
 #{1 2}
 #{1 2 3}
 :a
 #&lt;Ref@1493d9b3: 5&gt;
 (5)
 (5 4)
 [5 4 3]
 (6 1)
 c
 false
 true
 -2147483648
 10
 1.7976931348623157E308
 "b"
 [1, 2, 3, 4])
nil</code></pre>
</div>
</div>
</div>
</div></p>

<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>

  </body>
</html>