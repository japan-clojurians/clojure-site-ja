# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2017-06-01 09:26+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: en/content/reference/metadata.adoc:4 en/content/reference/protocols.adoc:4
#: en/content/reference/sequences.adoc:4
#: en/content/reference/multimethods.adoc:4 en/content/reference/libs.adoc:4
#: en/content/reference/transients.adoc:4
#: en/content/reference/compilation.adoc:4
#: en/content/reference/other_libraries.adoc:4
#: en/content/reference/documentation.adoc:4 en/content/reference/macros.adoc:4
#: en/content/reference/transducers.adoc:4 en/content/reference/refs.adoc:4
#: en/content/reference/lazy.adoc:4 en/content/reference/namespaces.adoc:4
#: en/content/reference/lisps.adoc:4 en/content/reference/evaluation.adoc:4
#: en/content/reference/other_functions.adoc:4
#: en/content/reference/reducers.adoc:4
#: en/content/reference/data_structures.adoc:4
#: en/content/reference/atoms.adoc:4 en/content/reference/repl_and_main.adoc:4
#: en/content/reference/agents.adoc:4 en/content/reference/datatypes.adoc:4
#: en/content/community/libraries.adoc:4 en/content/community/license.adoc:4
#: en/content/community/downloads_older.adoc:4
#: en/content/community/downloads.adoc:4 en/content/community/swag.adoc:4
#: en/content/404.adoc:4 en/content/privacy.adoc:4 en/content/search.adoc:4
#: en/content/about/spec.adoc:4 en/content/about/concurrent_programming.adoc:4
#: en/content/about/lisp.adoc:4 en/content/about/jvm_hosted.adoc:4
#: en/content/about/runtime_polymorphism.adoc:4 en/content/about/dynamic.adoc:4
#: en/content/about/features.adoc:4 en/content/about/rationale.adoc:4
#: en/content/about/state.adoc:4 en/content/about/clojurescript.adoc:4
#: en/content/about/functional_programming.adoc:4
#: en/content/about/clojureclr.adoc:4
msgid "Rich Hickey 2015-01-01"
msgstr ""

#. type: Plain text
#: en/content/reference/metadata.adoc:15 en/content/reference/protocols.adoc:15
#: en/content/reference/sequences.adoc:15
#: en/content/reference/multimethods.adoc:15 en/content/reference/libs.adoc:16
#: en/content/reference/transients.adoc:16
#: en/content/reference/compilation.adoc:16
#: en/content/reference/other_libraries.adoc:16
#: en/content/reference/macros.adoc:15 en/content/reference/transducers.adoc:15
#: en/content/reference/refs.adoc:15 en/content/reference/lazy.adoc:12
#: en/content/reference/reader.adoc:13
#: en/content/reference/special_forms.adoc:15
#: en/content/reference/namespaces.adoc:15
#: en/content/reference/java_interop.adoc:15
#: en/content/reference/other_functions.adoc:17
#: en/content/reference/vars.adoc:16 en/content/reference/reducers.adoc:15
#: en/content/reference/data_structures.adoc:16
#: en/content/reference/repl_and_main.adoc:16
#: en/content/reference/agents.adoc:16 en/content/reference/datatypes.adoc:16
#: en/content/guides/spec.adoc:11 en/content/guides/reader_conditionals.adoc:10
#: en/content/guides/destructuring.adoc:11 en/content/guides/faq.adoc:11
#: en/content/about/spec.adoc:16 en/content/about/dynamic.adoc:16
#: en/content/about/rationale.adoc:13 en/content/about/state.adoc:16
#: en/content/about/functional_programming.adoc:15
msgid "toc::[]"
msgstr ""

#. type: Title ==
#: en/content/reference/libs.adoc:64 en/content/reference/refs.adoc:73
#: en/content/reference/namespaces.adoc:24
#: en/content/reference/other_functions.adoc:41
#: en/content/reference/other_functions.adoc:65
#: en/content/reference/vars.adoc:85
#: en/content/reference/data_structures.adoc:70
#: en/content/reference/data_structures.adoc:90
#: en/content/reference/data_structures.adoc:98
#: en/content/reference/data_structures.adoc:107
#: en/content/reference/data_structures.adoc:116
#: en/content/reference/data_structures.adoc:162
#: en/content/reference/data_structures.adoc:174
#: en/content/reference/data_structures.adoc:188
#: en/content/reference/data_structures.adoc:223
#: en/content/reference/repl_and_main.adoc:159
#: en/content/reference/agents.adoc:64
#, no-wrap
msgid "Related functions"
msgstr ""

#. type: Title ==
#: en/content/reference/reader.adoc:24
#: en/content/reference/data_structures.adoc:111
#, no-wrap
msgid "Symbols"
msgstr ""

#. type: Title ==
#: en/content/reference/reader.adoc:99
#: en/content/reference/data_structures.adoc:235
#, no-wrap
msgid "Sets"
msgstr ""

#. type: Title =
#: en/content/reference/data_structures.adoc:1
#, no-wrap
msgid "Data Structures"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:18
msgid ""
"Clojure has a rich set of data structures. They share a set of properties:"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:20
msgid "They are immutable"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:21
msgid "They are read-able"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:22
msgid ""
"They support proper value equality semantics in their implementation of "
"equals"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:23
msgid "They provide good hash values"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:30
msgid ""
"In addition, the collections: ** Are manipulated via interfaces.  ** Support "
"sequencing ** Support persistent manipulation.  ** Support metadata ** "
"Implement java.lang.Iterable ** Implement the non-optional (read-only) "
"portion of java.util.Collection"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:32
#, no-wrap
msgid "nil"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:35
msgid ""
"nil is a possible value of any data type in Clojure. nil has the same value "
"as Java null. The Clojure conditional system is based around nil and false, "
"with nil and false representing the values of logical falsity in conditional "
"tests - anything else is logical truth. In addition, nil is used as the end-"
"of-sequence sentinel value in the sequence protocol."
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:37
#, no-wrap
msgid "Numbers"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:40
msgid ""
"Clojure provides full support for JVM primitive values by default, allowing "
"high performance, idiomatic Clojure code for numeric applications."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:42
msgid ""
"Clojure also supports the Java boxed number types derived from java.lang."
"Number, including BigInteger and BigDecimal, plus its own Ratio type. There "
"is some special handling:"
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:43
#, no-wrap
msgid "Longs"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:46
msgid ""
"By default Clojure operates with natural numbers as instances of Java's long "
"primitive type. When a primitive integer operation results in a value that "
"too large to be contained in a primitive value, a java.lang."
"ArithmeticException is thrown. Clojure provides a set of alternative math "
"operators suffixed with an apostrophe: +', -', *', inc', and dec'. These "
"operators auto-promote to BigInt upon overflow, but are less efficient than "
"the regular math operators."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:47
#, no-wrap
msgid "Ratio"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:50
msgid ""
"Represents a ratio between integers. Division of integers that can't be "
"reduced to an integer yields a ratio, i.e. 22/7 = 22/7, rather than a "
"floating point or truncated value."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:51
#, no-wrap
msgid "Contagion"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:54
msgid ""
"BigInts and floating point types are \"contagious\" across operations. That "
"is, any integer operation involving a BigInt will result in a BigInt, and "
"any operation involving a double or float will result in a double."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:55
#, no-wrap
msgid "BigInt and BigDecimal literals"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:58
msgid ""
"Numeric literals for BigInt and BigDecimal are specified using a postfix N "
"and M respectively."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:69
msgid ""
"|=== | Example expression | Return value | `(== 1 1.0 1M)` | `true` | `(/ 2 "
"3)` | `2/3` | `(/ 2.0 3)` | `0.6666666666666666` | `(map #(Math/abs %) "
"(range -3 3))` | `(3 2 1 0 1 2)` | `(class 36786883868216818816N)` | "
"`clojure.lang.BigInt` | `(class 3.14159265358M)` | `java.math.BigDecimal` |"
"==="
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:79
msgid ""
"Computation: https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/%2B[\\+] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/%2D[-] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/%2A[\\*] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/%2F[/] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/inc[inc] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/dec[dec] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/quot[quot] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/rem[rem] https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/min[min] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/max[max] Auto-promoting "
"computation: https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/%2B%27[+'] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/%2D%27[-'] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/%2A%27[*'] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/inc%27[inc'] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/dec%27[dec'] Comparison: https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/%3D%3D[==] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/%3C[<] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/%3C%3D[<=] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%3E[>] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%3E"
"%3D[>=] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"zero%3F[zero?] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/pos%3F[pos?] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/neg%3F[neg?] Bitwise operations: https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/bit-and[bit-and] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/bit-"
"or[bit-or] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/bit-xor[bit-xor] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/bit-not[bit-not] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/bit-shift-right[bit-shift-right] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/bit-shift-left[bit-"
"shift-left] Ratios: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/numerator[numerator] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/denominator[denominator] Coercions: "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"int[int] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/bigdec[bigdec] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/bigint[bigint] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/double[double] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/float[float] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/long[long] https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/num[num] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/short[short]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:81
#, no-wrap
msgid "Strings"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:84
msgid ""
"Clojure strings are Java Strings. See also <<other_functions#printing#,"
"Printing>>."
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:88
#, no-wrap
msgid ""
"user=> (map (fn [x] (.toUpperCase x)) (.split \"Dasher Dancer Prancer\" \" \"))\n"
"(\"DASHER\" \"DANCER\" \"PRANCER\")\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:93
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"str[str] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/string?[string?] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/pr-str[pr-str] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/prn-str[prn-str] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/print-str[print-str] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/println-"
"str[println-str] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/with-out-str[with-out-str]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:95
#, no-wrap
msgid "Characters"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:97
msgid "Clojure characters are Java Characters."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:100
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"char[char] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/char-name-string[char-name-string] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/char-escape-string[char-escape-string]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:102
#, no-wrap
msgid "Keywords"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:104
msgid ""
"Keywords are symbolic identifiers that evaluate to themselves. They provide "
"very fast equality tests. Like Symbols, they have names and optional "
"<<namespaces#,namespaces>>, both of which are strings. The leading ':' is "
"not part of the namespace or name."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:106
msgid ""
"Keywords implement IFn for invoke() of one argument (a map) with an optional "
"second argument (a default value). For example `(:mykey my-hash-map :none)` "
"means the same as `(get my-hash-map :mykey :none)`. See https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/get[get]."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:109
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"keyword[keyword] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/keyword?[keyword?]"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:113
msgid ""
"Symbols are identifiers that are normally used to refer to something else. "
"They can be used in program forms to refer to function parameters, let "
"bindings, class names and global vars. They have names and optional "
"<<namespaces#,namespaces>>, both of which are strings. Symbols can have "
"metadata (see https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/with-meta[with-meta])."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:115
msgid ""
"Symbols, just like Keywords, implement IFn for invoke() of one argument (a "
"map) with an optional second argument (a default value). For example "
"`('mysym my-hash-map :none)` means the same as `(get my-hash-map 'mysym :"
"none)`. See https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/get[get]."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:118
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"symbol[symbol] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/symbol?[symbol?] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/genysm[gensym] (see also the \\#-suffix <<reader#,"
"reader>> macro)"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:120
#: en/content/guides/spec.adoc:418
#, no-wrap
msgid "Collections"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:123
msgid ""
"All of the Clojure collections are immutable and http://en.wikipedia.org/"
"wiki/Persistent_data_structure[persistent]. In particular, the Clojure "
"collections support efficient creation of 'modified' versions, by utilizing "
"structural sharing, and make all of their performance bound guarantees for "
"persistent use. The collections are efficient and inherently thread-safe. "
"Collections are represented by abstractions, and there may be one or more "
"concrete realizations. In particular, since 'modification' operations yield "
"new collections, the new collection might not have the same concrete type as "
"the source collection, but will have the same logical (interface) type."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:125
msgid ""
"All the collections support https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/count[count] for getting the size of the collection, "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"conj[conj] for 'adding' to the collection, and https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/seq[seq] to get a sequence that "
"can walk the entire collection, though their specific behavior is slightly "
"different for different types of collections."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:127
msgid ""
"Because collections support the https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/seq[seq] function, all of the <<sequences#,"
"sequence functions>> can be used with any collection."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:129
#, no-wrap
msgid "Java collection hashes"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:131
msgid ""
"The Java collection interfaces specify algorithms for http://docs.oracle.com/"
"javase/7/docs/api/java/util/List.html#hashCode()[Lists], http://docs.oracle."
"com/javase/7/docs/api/java/util/Set.html#hashCode()[Sets], and http://docs."
"oracle.com/javase/7/docs/api/java/util/Map.html#hashCode()[Maps] in "
"calculating hashCode() values. All Clojure collections conform to these "
"specifications in their hashCode() implementations."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:132
#, no-wrap
msgid "Clojure collection hashes"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:134
msgid ""
"Clojure provides its own hash computations that provide better hash "
"properties for collections (and other types), known as the _hasheq_ value."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:136
msgid ""
"The `IHashEq` interface marks collections that provide the `hasheq()` "
"function to obtain the hasheq value. In Clojure, the https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/hash[hash] function can be "
"used to compute the hasheq value."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:138
msgid ""
"Ordered collections (vector, list, seq, etc) must use the following "
"algorithm for calculating hasheq (where hash computes hasheq). Note that "
"unchecked-add-int and unchecked-multiply-int are used to get integer "
"overflow calculations."
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:147
#, no-wrap
msgid ""
"(defn hash-ordered [collection]\n"
"  (-> (reduce (fn [acc e] (unchecked-add-int\n"
"                            (unchecked-multiply-int 31 acc)\n"
"                            (hash e)))\n"
"              1\n"
"              collection)\n"
"      (mix-collection-hash (count collection))))\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:149
msgid ""
"Unordered collections (maps, sets) must use the following algorithm for "
"calculating hasheq. A map entry is treated as an ordered collection of key "
"and value. Note that unchecked-add-int is used to get integer overflow "
"calculations."
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:154
#, no-wrap
msgid ""
"(defn hash-unordered [collection]\n"
"  (-> (reduce unchecked-add-int 0 (map hash collection))\n"
"      (mix-collection-hash (count collection))))\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:156
msgid ""
"The https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mix-"
"collection-hash[mix-collection-hash] algorithm is an implementation detail "
"subject to change."
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:158
#, no-wrap
msgid "Lists (IPersistentList)"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:161
msgid ""
"Lists are collections. They implement the ISeq interface directly (except "
"for the empty list, which is not a valid seq). https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/count[count] is O(1). https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/conj[conj] puts "
"the item at the front of the list."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:168
msgid ""
"Create a list: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/list[list] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/list*[list*] Treat a list like a stack: https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/peek[peek] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"pop[pop] Examine a list: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/list?[list?]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:170
#, no-wrap
msgid "Vectors (IPersistentVector)"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:173
msgid ""
"A Vector is a collection of values indexed by contiguous integers. Vectors "
"support access to items by index in log32N hops. https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/count[count] is O(1). https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/conj[conj] puts "
"the item at the end of the vector. Vectors also support https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/rseq[rseq], which "
"returns the items in reverse order. Vectors implement IFn, for invoke() of "
"one argument, which they presume is an index and look up in themselves as if "
"by nth, i.e. vectors are functions of their indices. Vectors are compared "
"first by length, then each element is compared in order."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:180
msgid ""
"Create a vector: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/vector[vector] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/vec[vec] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/vector-of[vector-of] Examine a vector: "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"get[get] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/nth[nth] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/peek[peek] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/rseq[rseq] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/vector?[vector?] 'change' a vector: https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/assoc[assoc] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"pop[pop] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/subvec[subvec] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/replace[replace]"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:182
msgid "See also <<other_libraries#,zippers>>"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:184
#, no-wrap
msgid "Maps (IPersistentMap)"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:187
msgid ""
"A Map is a collection that maps keys to values. Two different map types are "
"provided - hashed and sorted. Hash maps require keys that correctly support "
"hashCode and equals. Sorted maps require keys that implement Comparable, or "
"an instance of Comparator. Hash maps provide faster access (log32N hops) vs "
"(logN hops), but sorted maps are, well, sorted. https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/count[count] is O(1). https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/conj[conj] "
"expects another (possibly single entry) map as the item, and returns a new "
"map which is the old map plus the entries from the new, which may overwrite "
"entries of the old. https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/conj[conj] also accepts a MapEntry or a vector of two "
"items (key and value). https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/seq[seq] returns a sequence of map entries, which are key/"
"value pairs. Sorted map also supports https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/rseq[rseq], which returns the entries in "
"reverse order. Maps implement IFn, for invoke() of one argument (a key) with "
"an optional second argument (a default value), i.e. maps are functions of "
"their keys. nil keys and values are ok."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:195
msgid ""
"Create a new map: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/hash-map[hash-map] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/sorted-map[sorted-map] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/sorted-map-by[sorted-"
"map-by] 'change' a map: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/assoc[assoc] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/dissoc[dissoc] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/select-keys[select-keys] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/merge[merge] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/merge-"
"with[merge-with] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/zipmap[zipmap] Examine a map: https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/get[get] https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/contains?[contains?] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/find[find] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"keys[keys] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/vals[vals] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/map?[map?] Examine a map entry: https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/key[key] https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/val[val]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:197
#, no-wrap
msgid "StructMaps"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:201
msgid ""
"Most uses of StructMaps would now be better served by <<datatypes#,records>>."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:203
msgid ""
"Often many map instances have the same base set of keys, for instance when "
"maps are used as structs or objects would be in other languages. StructMaps "
"support this use case by efficiently sharing the key information, while also "
"providing optional enhanced-performance accessors to those keys. StructMaps "
"are in all ways maps, supporting the same set of functions, are "
"interoperable with all other maps, and are persistently extensible (i.e. "
"struct maps are not limited to their base keys). The only restriction is "
"that you cannot dissociate a struct map from one of its base keys. A struct "
"map will retain its base keys in order."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:205
msgid ""
"StructMaps are created by first creating a structure basis object using "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/create-"
"struct[create-struct] or https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/defstruct[defstruct], then creating instances with https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/struct-"
"map[struct-map] or https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/struct[struct]."
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:221
#, no-wrap
msgid ""
"(defstruct desilu :fred :ricky)\n"
"(def x (map (fn [n]\n"
"              (struct-map desilu\n"
"                :fred n\n"
"                :ricky 2\n"
"                :lucy 3\n"
"                :ethel 4))\n"
"             (range 100000)))\n"
"(def fred (accessor desilu :fred))\n"
"(reduce (fn [n y] (+ n (:fred y))) 0 x)\n"
" -> 4999950000\n"
"(reduce (fn [n y] (+ n (fred y))) 0 x)\n"
" -> 4999950000\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:228
msgid ""
"StructMap setup: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/create-struct[create-struct] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/defstruct[defstruct] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"accessor[accessor] Create individual struct: https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/struct-map[struct-map] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/struct[struct]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:230
#, no-wrap
msgid "ArrayMaps"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:233
msgid ""
"When doing code form manipulation it is often desirable to have a map which "
"maintains key order. An array map is such a map - it is simply implemented "
"as an array of key val key val... As such, it has linear lookup performance, "
"and is only suitable for _very small_ maps. It implements the full map "
"interface. New ArrayMaps can be created with the https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/array-map[array-map] function. "
"Note that an array map will only maintain sort order when un-'modified'. "
"Subsequent assoc-ing will eventually cause it to 'become' a hash-map."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:237
msgid "Sets are collections of unique values."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:239
msgid "There is literal support for hash-sets:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:244
#, no-wrap
msgid ""
"#{:a :b :c :d}\n"
"-> #{:d :a :b :c}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:247
msgid ""
"You can create sets with the https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/hash-set[hash-set] and https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/sorted-set[sorted-set] functions:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:252
#, no-wrap
msgid ""
"(hash-set :a :b :c :d)\n"
"-> #{:d :a :b :c}\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:255
#, no-wrap
msgid ""
"(sorted-set :a :b :c :d)\n"
"-> #{:a :b :c :d}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:258
msgid ""
"You can also get a set of the values in a collection using the https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/set[set] "
"function:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:263
#, no-wrap
msgid ""
"(set [1 2 3 2 1 2 3])\n"
"-> #{1 2 3}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:266
msgid "Sets are collections:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:271
#, no-wrap
msgid ""
"(def s #{:a :b :c :d})\n"
"(conj s :e)\n"
"-> #{:d :a :b :e :c}\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:274
#, no-wrap
msgid ""
"(count s)\n"
"-> 4\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:277
#, no-wrap
msgid ""
"(seq s)\n"
"-> (:d :a :b :c)\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:280
#, no-wrap
msgid ""
"(= (conj s :e) #{:a :b :c :d :e})\n"
"-> true\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:283
msgid ""
"Sets support 'removal' with https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/disj[disj], as well as _**contains?**_ and _**get**_, "
"the latter returning the object that is held in the set which compares equal "
"to the key, if found:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:288
#, no-wrap
msgid ""
"(disj s :d)\n"
"-> #{:a :b :c}\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:291
#, no-wrap
msgid ""
"(contains? s :b)\n"
"-> true\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:294
#, no-wrap
msgid ""
"(get s :a)\n"
"-> :a\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:297
msgid "Sets are functions of their members, using _**get**_:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:301
#, no-wrap
msgid ""
"(s :b)\n"
"-> :b\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:304
#, no-wrap
msgid ""
"(s :k)\n"
"-> nil\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:306
msgid ""
"Clojure provides basic set operations like https://clojure.github.io/clojure/"
"clojure.set-api.html#clojure.set/union[union] / https://clojure.github.io/"
"clojure/clojure.set-api.html#clojure.set/difference[difference] / https://"
"clojure.github.io/clojure/clojure.set-api.html#clojure.set/"
"intersection[intersection], as well as some pseudo-relational algebra "
"support for 'relations', which are simply sets of maps - https://clojure."
"github.io/clojure/clojure.set-api.html#clojure.set/select[select] / https://"
"clojure.github.io/clojure/clojure.set-api.html#clojure.set/index[index] / "
"https://clojure.github.io/clojure/clojure.set-api.html#clojure.set/"
"rename[rename] / https://clojure.github.io/clojure/clojure.set-api."
"html#clojure.set/join[join]."
msgstr ""
