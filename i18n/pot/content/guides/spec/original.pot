# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2019-07-25 20:54+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ==
#: en/content/reference/data_structures.adoc:120
#: en/content/guides/spec.adoc:433
#, no-wrap
msgid "Collections"
msgstr ""

#. type: Title ==
#: en/content/reference/macros.adoc:1 en/content/guides/spec.adoc:777
#: en/content/guides/destructuring.adoc:539
#, no-wrap
msgid "Macros"
msgstr ""

#. type: Title ====
#: en/content/reference/sequences.adoc:1 en/content/guides/spec.adoc:511
#: en/content/about/spec.adoc:234
#, no-wrap
msgid "Sequences"
msgstr ""

#. type: Title =
#: en/content/guides/spec.adoc:1
#, no-wrap
msgid "spec Guide"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:4
msgid "Alex Miller 2016-05-24"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:12
#, no-wrap
msgid "Getting started"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:15
msgid ""
"The <<xref/../../../about/spec#,spec>> library specifies the structure of "
"data, validates or conforms it, and can generate data based on the spec."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:17
msgid "To use spec, declare a dependency on Clojure 1.9.0 or higher:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:21
#, no-wrap
msgid "[org.clojure/clojure \"1.10.0\"]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:24
msgid ""
"To start working with spec, require the `clojure.spec.alpha` namespace at "
"the REPL:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:28
#, no-wrap
msgid "(require '[clojure.spec.alpha :as s])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:31
msgid "Or include spec in your namespace:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:36
#, no-wrap
msgid ""
"(ns my.ns\n"
"  (:require [clojure.spec.alpha :as s]))\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:38
#, no-wrap
msgid "Predicates"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:41
msgid ""
"Each spec describes a set of allowed values. There are several ways to build "
"specs and all of them can be composed to build more sophisticated specs."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:43
msgid ""
"Any existing Clojure function that takes a single argument and returns a "
"truthy value is a valid predicate spec. We can check whether a particular "
"data value conforms to a spec using https://clojure.github.io/spec.alpha/"
"clojure.spec.alpha-api.html#clojure.spec.alpha/conform[`conform`]:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:48
#, no-wrap
msgid ""
"(s/conform even? 1000)\n"
";;=> 1000\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:51
msgid ""
"The `conform` function takes something that can be a spec and a data value. "
"Here we are passing a predicate which is implicitly converted into a spec. "
"The return value is \"conformed\". Here, the conformed value is the same as "
"the original value - we'll see later where that starts to deviate. If the "
"value does not conform to the spec, the special value `:clojure.spec.alpha/"
"invalid` is returned."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:53
msgid ""
"If you don't want to use the conformed value or check for `:clojure.spec."
"alpha/invalid`, the helper https://clojure.github.io/spec.alpha/clojure.spec."
"alpha-api.html#clojure.spec.alpha/valid?[`valid?`] can be used instead to "
"return a boolean."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:58
#, no-wrap
msgid ""
"(s/valid? even? 10)\n"
";;=> true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:61
msgid ""
"Note that again `valid?` implicitly converts the predicate function into a "
"spec. The spec library allows you to leverage all of the functions you "
"already have - there is no special dictionary of predicates. Some more "
"examples:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:66
#, no-wrap
msgid ""
"(s/valid? nil? nil)  ;; true\n"
"(s/valid? string? \"abc\")  ;; true\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:69
#, no-wrap
msgid ""
"(s/valid? #(> % 5) 10) ;; true\n"
"(s/valid? #(> % 5) 0) ;; false\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:72
#, no-wrap
msgid ""
"(import java.util.Date)\n"
"(s/valid? inst? (Date.))  ;; true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:75
msgid ""
"Sets can also be used as predicates that match one or more literal values:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:80
#, no-wrap
msgid ""
"(s/valid? #{:club :diamond :heart :spade} :club) ;; true\n"
"(s/valid? #{:club :diamond :heart :spade} 42) ;; false\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:82
#, no-wrap
msgid "(s/valid? #{42} 42) ;; true\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:84
#, no-wrap
msgid "Registry"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:87
msgid ""
"Until now, we've been using specs directly. However, spec provides a central "
"registry for globally declaring reusable specs. The registry associates a "
"namespaced keyword with a specification. The use of namespaces ensures that "
"we can define reusable non-conflicting specs across libraries or "
"applications."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:89
msgid ""
"Specs are registered using https://clojure.github.io/spec.alpha/clojure.spec."
"alpha-api.html#clojure.spec.alpha/def[`def`]. It's up to you to register the "
"specification in a namespace that makes sense (typically a namespace you "
"control)."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:94
#, no-wrap
msgid ""
"(s/def ::date inst?)\n"
"(s/def ::suit #{:club :diamond :heart :spade})\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:97
msgid ""
"A registered spec identifier can be used in place of a spec definition in "
"the operations we've seen so far - `conform` and `valid?`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:104
#, no-wrap
msgid ""
"(s/valid? ::date (java.util.Date.))\n"
";;=> true\n"
"(s/conform ::suit :club)\n"
";;=> :club\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:107
msgid ""
"You will see later that registered specs can (and should) be used anywhere "
"we compose specs."
msgstr ""

#. type: Block title
#: en/content/guides/spec.adoc:108
#, no-wrap
msgid "Spec Names"
msgstr ""

#. type: delimited block *
#: en/content/guides/spec.adoc:111
msgid ""
"In this guide we will often use auto-resolved keywords like `::date`. The "
"Clojure reader resolves these to a fully-qualified keyword using the current "
"namespace. You may also see some cases where a fully-qualified keyword like "
"`:animal/dog` is used to name a spec."
msgstr ""

#. type: delimited block *
#: en/content/guides/spec.adoc:113
msgid ""
"Generally, Clojure code should use keyword namespaces that are sufficiently "
"unique such that they will not conflict with other spec users. If you are "
"writing a library for public use, spec namespaces should include the project "
"name, url, or organization such that you will not conflict. Within a private "
"organization, you may be able to use shorter names - the important thing is "
"that they are sufficiently unique to avoid conflicts."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:116
msgid ""
"Once a spec has been added to the registry, `doc` knows how to find it and "
"print it as well:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:120
#, no-wrap
msgid "(doc ::date)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:124
#, no-wrap
msgid ""
":user/date\n"
"Spec\n"
"  inst?\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:126
msgid "(doc ::suit)"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:130
#, no-wrap
msgid ""
":user/suit\n"
"Spec\n"
"  #{:spade :heart :diamond :club}\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:132
#, no-wrap
msgid "Composing predicates"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:135
msgid ""
"The simplest way to compose specs is with https://clojure.github.io/spec."
"alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/and[`and`] and https://"
"clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/"
"or[`or`]. Let's create a spec that combines several predicates into a "
"composite spec with `s/and`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:142
#, no-wrap
msgid ""
"(s/def ::big-even (s/and int? even? #(> % 1000)))\n"
"(s/valid? ::big-even :foo) ;; false\n"
"(s/valid? ::big-even 10) ;; false\n"
"(s/valid? ::big-even 100000) ;; true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:145
msgid "We can also use `s/or` to specify two alternatives:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:153
#, no-wrap
msgid ""
"(s/def ::name-or-id (s/or :name string? \n"
"                          :id   int?))\n"
"(s/valid? ::name-or-id \"abc\") ;; true\n"
"(s/valid? ::name-or-id 100) ;; true\n"
"(s/valid? ::name-or-id :foo) ;; false\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:156
msgid ""
"This `or` spec is the first case we've seen that involves a choice during "
"validity checking. Each choice is annotated with a tag (here, between `:"
"name` and `:id`) and those tags give the branches names that can be used to "
"understand or enrich the data returned from `conform` and other spec "
"functions."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:158
msgid ""
"When an `or` is conformed, it returns a vector with the tag name and "
"conformed value:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:165
#, no-wrap
msgid ""
"(s/conform ::name-or-id \"abc\")\n"
";;=> [:name \"abc\"]\n"
"(s/conform ::name-or-id 100)\n"
";;=> [:id 100]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:168
msgid ""
"Many predicates that check an instance's type do not allow `nil` as a valid "
"value (`string?`, `number?`, `keyword?`, etc). To include `nil` as a valid "
"value, use the provided function https://clojure.github.io/spec.alpha/"
"clojure.spec.alpha-api.html#clojure.spec.alpha/nilable[`nilable`] to make a "
"spec:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:175
#, no-wrap
msgid ""
"(s/valid? string? nil)\n"
";;=> false\n"
"(s/valid? (s/nilable string?) nil)\n"
";;=> true\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:177
#, no-wrap
msgid "Explain"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:180
msgid ""
"https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/explain[`explain`] is another high-level operation in spec that "
"can be used to report (to `pass:[*out*]`) why a value does not conform to a "
"spec. Let's see what explain says about some non-conforming examples we've "
"seen so far."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:190
#, no-wrap
msgid ""
"(s/explain ::suit 42)\n"
";; 42 - failed: #{:spade :heart :diamond :club} spec: :user/suit\n"
"(s/explain ::big-even 5)\n"
";; 5 - failed: even? spec: :user/big-even\n"
"(s/explain ::name-or-id :foo)\n"
";; :foo - failed: string? at: [:name] spec: :user/name-or-id\n"
";; :foo - failed: int? at: [:id] spec: :user/name-or-id\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:193
msgid ""
"Let's examine the output of the final example more closely. First note that "
"there are two errors being reported - spec will evaluate all possible "
"alternatives and report errors on every path. The parts of each error are:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:195
msgid "val - the value in the user's input that does not match"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:196
msgid "spec - the spec that was being evaluated"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:197
msgid ""
"at - a path (a vector of keywords) indicating the location within the spec "
"where the error occurred - the tags in the path correspond to any tagged "
"part in a spec (the alternatives in an `or` or `alt`, the parts of a `cat`, "
"the keys in a map, etc)"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:198
msgid "predicate - the actual predicate that was not satisfied by val"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:199
msgid ""
"in - the key path through a nested data val to the failing value. In this "
"example, the top-level value is the one that is failing so this is "
"essentially an empty path and is omitted."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:201
msgid ""
"For the first reported error we can see that the value `:foo` did not "
"satisfy the predicate `string?` at the path `:name` in the spec `::name-or-"
"id`. The second reported error is similar but fails on the `:id` path "
"instead. The actual value is a keyword so neither is a match."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:203
msgid ""
"In addition to `explain`, you can use https://clojure.github.io/spec.alpha/"
"clojure.spec.alpha-api.html#clojure.spec.alpha/explain-str[`explain-str`] to "
"receive the error messages as a string or https://clojure.github.io/spec."
"alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/explain-data[`explain-"
"data`] to receive the errors as data."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:218
#, no-wrap
msgid ""
"(s/explain-data ::name-or-id :foo)\n"
";;=> #:clojure.spec.alpha{\n"
";;     :problems ({:path [:name], \n"
";;                 :pred string?,\n"
";;                 :val :foo,\n"
";;                 :via [:spec.examples.guide/name-or-id],\n"
";;                 :in []}\n"
";;                {:path [:id],\n"
";;                 :pred int?,\n"
";;                 :val :foo,\n"
";;                 :via [:spec.examples.guide/name-or-id],\n"
";;                 :in []})}\n"
msgstr ""

#. type: delimited block =
#: en/content/guides/spec.adoc:223
msgid ""
"This result also demonstrates the namespace map literal syntax added in "
"Clojure 1.9. Maps may be prefixed with `\\#:` or `#::` (for autoresolve) to "
"specify a default namespace for all keys in the map. In this example, this "
"is equivalent to `{:clojure.spec.alpha/problems ...}`"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:225
#, no-wrap
msgid "Entity Maps"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:230
msgid ""
"Clojure programs rely heavily on passing around maps of data. A common "
"approach in other libraries is to describe each entity type, combining both "
"the keys it contains and the structure of their values. Rather than define "
"attribute (key+value) specifications in the scope of the entity (the map), "
"specs assign meaning to individual attributes, then collect them into maps "
"using set semantics (on the keys). This approach allows us to start "
"assigning (and sharing)  semantics at the attribute level across our "
"libraries and applications."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:232
msgid ""
"For example, most Ring middleware functions modify the request or response "
"map with unqualified keys. However, each middleware could instead use "
"namespaced keys with registered semantics for those keys. The keys could "
"then be checked for conformance, creating a system with greater "
"opportunities for collaboration and consistency."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:234
msgid ""
"Entity maps in spec are defined with https://clojure.github.io/spec.alpha/"
"clojure.spec.alpha-api.html#clojure.spec.alpha/keys[`keys`]:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:240
#, no-wrap
msgid ""
"(ns my.domain (:require [clojure.spec.alpha :as s]))\n"
"(def email-regex #\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}$\")\n"
"(s/def ::email-type (s/and string? #(re-matches email-regex %)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:245
#, no-wrap
msgid ""
"(s/def ::acctid int?)\n"
"(s/def ::first-name string?)\n"
"(s/def ::last-name string?)\n"
"(s/def ::email ::email-type)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:248
#, no-wrap
msgid ""
"(s/def ::person (s/keys :req [::first-name ::last-name ::email]\n"
"                        :opt [::phone]))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:251
msgid ""
"This registers a `::person` spec with the required keys `::first-name`, `::"
"last-name`, and `::email`, with optional key `::phone`. The map spec never "
"specifies the value spec for the attributes, only what attributes are "
"required or optional."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:253
msgid ""
"When conformance is checked on a map, it does two things - checking that the "
"required attributes are included, and checking that every registered key has "
"a conforming value. We'll see later where optional attributes can be useful. "
"Also note that ALL attributes are checked via `keys`, not just those listed "
"in the `:req` and `:opt` keys. Thus a bare `(s/keys)` is valid and will "
"check all attributes of a map without checking which keys are required or "
"optional."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:261
#, no-wrap
msgid ""
"(s/valid? ::person\n"
"  {::first-name \"Bugs\"\n"
"   ::last-name \"Bunny\"\n"
"   ::email \"bugs@example.com\"})\n"
";;=> true\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:269
#, no-wrap
msgid ""
";; Fails required key check\n"
"(s/explain ::person\n"
"  {::first-name \"Bugs\"})\n"
";; #:my.domain{:first-name \"Bugs\"} - failed: (contains? % :my.domain/last-name) \n"
";;   spec: :my.domain/person\n"
";; #:my.domain{:first-name \"Bugs\"} - failed: (contains? % :my.domain/email)\n"
";;   spec: :my.domain/person\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:277
#, no-wrap
msgid ""
";; Fails attribute conformance\n"
"(s/explain ::person\n"
"  {::first-name \"Bugs\"\n"
"   ::last-name \"Bunny\"\n"
"   ::email \"n/a\"})\n"
";; \"n/a\" - failed: (re-matches email-regex %) in: [:my.domain/email]\n"
";;   at: [:my.domain/email] spec: :my.domain/email-type\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:280
msgid ""
"Let's take a moment to examine the explain error output on that final "
"example:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:282
msgid ""
"in - the path within the data to the failing value (here, a key in the "
"person instance)"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:283
msgid "val - the failing value, here `\"n/a\"`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:284
msgid "spec - the spec that failed, here `:my.domain/email-type`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:285
msgid "at - the path in the spec where the failing value is located"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:286
msgid ""
"predicate - the predicate that failed, here `(re-matches email-regex %)`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:288
msgid ""
"Much existing Clojure code does not use maps with namespaced keys and so "
"`keys` can also specify `:req-un` and `:opt-un` for required and optional "
"unqualified keys. These variants specify namespaced keys used to find their "
"specification, but the map only checks for the unqualified version of the "
"keys."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:290
msgid ""
"Let's consider a person map that uses unqualified keys but checks "
"conformance against the namespaced specs we registered earlier:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:296
#, no-wrap
msgid ""
"(s/def :unq/person \n"
"  (s/keys :req-un [::first-name ::last-name ::email]\n"
"          :opt-un [::phone]))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:302
#, no-wrap
msgid ""
"(s/conform :unq/person\n"
"  {:first-name \"Bugs\"\n"
"   :last-name \"Bunny\"\n"
"   :email \"bugs@example.com\"})\n"
";;=> {:first-name \"Bugs\", :last-name \"Bunny\", :email \"bugs@example.com\"}\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:309
#, no-wrap
msgid ""
"(s/explain :unq/person\n"
"  {:first-name \"Bugs\"\n"
"   :last-name \"Bunny\"\n"
"   :email \"n/a\"})\n"
";; \"n/a\" - failed: (re-matches email-regex %) in: [:email] at: [:email] \n"
";;   spec: :my.domain/email-type\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:314
#, no-wrap
msgid ""
"(s/explain :unq/person\n"
"  {:first-name \"Bugs\"})\n"
";; {:first-name \"Bugs\"} - failed: (contains? % :last-name) spec: :unq/person\n"
";; {:first-name \"Bugs\"} - failed: (contains? % :email) spec: :unq/person\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:317
msgid "Unqualified keys can also be used to validate record attributes:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:321
#, no-wrap
msgid "(defrecord Person [first-name last-name email phone])\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:326
#, no-wrap
msgid ""
"(s/explain :unq/person\n"
"           (->Person \"Bugs\" nil nil nil))\n"
";; nil - failed: string? in: [:last-name] at: [:last-name] spec: :my.domain/last-name\n"
";; nil - failed: string? in: [:email] at: [:email] spec: :my.domain/email-type\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:331
#, no-wrap
msgid ""
"(s/conform :unq/person\n"
"  (->Person \"Bugs\" \"Bunny\" \"bugs@example.com\" nil))\n"
";;=> #my.domain.Person{:first-name \"Bugs\", :last-name \"Bunny\", \n"
";;=>                   :email \"bugs@example.com\", :phone nil}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:334
msgid ""
"One common occurrence in Clojure is the use of \"keyword args\" where "
"keyword keys and values are passed in a sequential data structure as "
"options. Spec provides special support for this pattern with the regex op "
"https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/keys*[`keys*`]. `keys*` has the same syntax and semantics as "
"`keys` but can be embedded inside a sequential regex structure."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:343
#, no-wrap
msgid ""
"(s/def ::port number?)\n"
"(s/def ::host string?)\n"
"(s/def ::id keyword?)\n"
"(s/def ::server (s/keys* :req [::id ::host] :opt [::port]))\n"
"(s/conform ::server [::id :s1 ::host \"example.com\" ::port 5555])\n"
";;=> {:my.domain/id :s1, :my.domain/host \"example.com\", :my.domain/port 5555}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:345
msgid ""
"Sometimes it will be convenient to declare entity maps in parts, either "
"because there are different sources for requirements on an entity map or "
"because there is a common set of keys and variant-specific parts. The `s/"
"merge` spec can be used to combine multiple `s/keys` specs into a single "
"spec that combines their requirements. For example consider two `keys` specs "
"that define common animal attributes and some dog-specific ones. The dog "
"entity itself can be described as a `merge` of those two attribute sets:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:361
#, no-wrap
msgid ""
"(s/def :animal/kind string?)\n"
"(s/def :animal/says string?)\n"
"(s/def :animal/common (s/keys :req [:animal/kind :animal/says]))\n"
"(s/def :dog/tail? boolean?)\n"
"(s/def :dog/breed string?)\n"
"(s/def :animal/dog (s/merge :animal/common\n"
"                            (s/keys :req [:dog/tail? :dog/breed])))\n"
"(s/valid? :animal/dog\n"
"  {:animal/kind \"dog\"\n"
"   :animal/says \"woof\"\n"
"   :dog/tail? true\n"
"   :dog/breed \"retriever\"})\n"
";;=> true\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:363
#, no-wrap
msgid "multi-spec"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:366
msgid ""
"One common occurrence in Clojure is to use maps as tagged entities and a "
"special field that indicates the \"type\" of the map where type indicates a "
"potentially open set of types, often with shared attributes across the types."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:368
msgid ""
"As previously discussed, the attributes for all types are well-specified "
"using attributes stored in the registry by namespaced keyword. Attributes "
"shared across entity types automatically gain shared semantics. However, we "
"also want to be able to specify the required keys per entity type and for "
"that spec provides https://clojure.github.io/spec.alpha/clojure.spec.alpha-"
"api.html#clojure.spec.alpha/multi-spec[`multi-spec`] which leverages a "
"multimethod to provide for the specification of an open set of entity types "
"based on a type tag."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:370
msgid ""
"For example, imagine an API that received event objects which shared some "
"common fields but also had type-specific shapes. First we would register the "
"event attributes:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:378
#, no-wrap
msgid ""
"(s/def :event/type keyword?)\n"
"(s/def :event/timestamp int?)\n"
"(s/def :search/url string?)\n"
"(s/def :error/message string?)\n"
"(s/def :error/code int?)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:381
msgid ""
"We then need a multimethod that defines a dispatch function for choosing the "
"selector (here our `:event/type` field) and returns the appropriate spec "
"based on the value:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:389
#, no-wrap
msgid ""
"(defmulti event-type :event/type)\n"
"(defmethod event-type :event/search [_]\n"
"  (s/keys :req [:event/type :event/timestamp :search/url]))\n"
"(defmethod event-type :event/error [_]\n"
"  (s/keys :req [:event/type :event/timestamp :error/message :error/code]))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:392
msgid ""
"The methods should ignore their argument and return the spec for the "
"specified type. Here we've fully spec'ed two possible events - a \"search\" "
"event and an \"error\" event."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:394
msgid ""
"And then finally we are ready to declare our `multi-spec` and try it out."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:398
#, no-wrap
msgid "(s/def :event/event (s/multi-spec event-type :event/type))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:421
#, no-wrap
msgid ""
"(s/valid? :event/event\n"
"  {:event/type :event/search\n"
"   :event/timestamp 1463970123000\n"
"   :search/url \"https://clojure.org\"})\n"
";=> true\n"
"(s/valid? :event/event\n"
"  {:event/type :event/error\n"
"   :event/timestamp 1463970123000\n"
"   :error/message \"Invalid host\"\n"
"   :error/code 500})\n"
";=> true\n"
"(s/explain :event/event\n"
"  {:event/type :event/restart})\n"
";; #:event{:type :event/restart} - failed: no method at: [:event/restart] \n"
";;   spec: :event/event\n"
"(s/explain :event/event\n"
"  {:event/type :event/search\n"
"   :search/url 200})\n"
";; 200 - failed: string? in: [:search/url] \n"
";;   at: [:event/search :search/url] spec: :search/url\n"
";; {:event/type :event/search, :search/url 200} - failed: (contains? % :event/timestamp) \n"
";;   at: [:event/search] spec: :event/event\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:424
msgid ""
"Let's take a moment to examine the explain error output on that final "
"example. There were two different kinds of failures detected. The first "
"failure is due to the missing required `:event/timestamp` key in the event. "
"The second is from the invalid `:search/url` value (a number instead of a "
"string). We see the same parts as prior explain errors:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:426
msgid ""
"in - the path within the data to the failing value. This is omitted on the "
"first error as it's at the root value but is the key in the map on the "
"second error."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:427
msgid ""
"val - the failing value, either the full map or the individual key in the map"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:428
msgid "spec - the actual spec that failed"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:429
msgid "at - the path in the spec where the failing value occurred"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:430
msgid "predicate - the actual predicate that failed"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:432
msgid ""
"The `multi-spec` approach allows us to create an *open* system for spec "
"validation, just like multimethods and protocols. New event types can be "
"added later by just extending the `event-type` multimethod."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:436
msgid ""
"A few helpers are provided for other special collection cases - https://"
"clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/"
"coll-of[`coll-of`], https://clojure.github.io/spec.alpha/clojure.spec.alpha-"
"api.html#clojure.spec.alpha/tuple[`tuple`], and https://clojure.github.io/"
"spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/map-of[`map-of`]."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:438
msgid ""
"For the special case of a homogenous collection of arbitrary size, you can "
"use `coll-of` to specify a collection of elements satisfying a predicate."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:445
#, no-wrap
msgid ""
"(s/conform (s/coll-of keyword?) [:a :b :c])\n"
";;=> [:a :b :c]\n"
"(s/conform (s/coll-of number?) #{5 10 2})\n"
";;=> #{2 5 10}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:448
msgid "Additionally, `coll-of` can be passed a number of keyword arg options:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:450
msgid ""
"`:kind` - a predicate or spec that the incoming collection must satisfy, "
"such as `vector?`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:451
msgid "`:count` - specifies exact expected count"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:452
msgid ""
"`:min-count`, `:max-count` - checks that collection has `(\\<= min-count "
"count max-count)`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:453
msgid "`:distinct` - checks that all elements are distinct"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:454
msgid ""
"`:into` - one of [], (), {}, or #{} for output conformed value. If `:into` "
"is not specified, the input collection type will be used."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:456
msgid ""
"Following is an example utilizing some of these options to spec a vector "
"containing three distinct numbers conformed as a set and some of the errors "
"for different kinds of invalid values:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:468
#, no-wrap
msgid ""
"(s/def ::vnum3 (s/coll-of number? :kind vector? :count 3 :distinct true :into #{}))\n"
"(s/conform ::vnum3 [1 2 3])\n"
";;=> #{1 2 3}\n"
"(s/explain ::vnum3 #{1 2 3})   ;; not a vector\n"
";; #{1 3 2} - failed: vector? spec: :user/vnum3\n"
"(s/explain ::vnum3 [1 1 1])    ;; not distinct\n"
";; [1 1 1] - failed: distinct? spec: :user/vnum3\n"
"(s/explain ::vnum3 [1 2 :a])   ;; not a number\n"
";; :a - failed: number? in: [2] spec: :user/vnum3\n"
msgstr ""

#. type: delimited block =
#: en/content/guides/spec.adoc:473
msgid ""
"Both `coll-of` and `map-of` will conform all of their elements, which may "
"make them unsuitable for large collections. In that case, consider https://"
"clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/"
"every[`every`] or for maps https://clojure.github.io/spec.alpha/clojure.spec."
"alpha-api.html#clojure.spec.alpha/every-kv[`every-kv`]."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:476
msgid ""
"While `coll-of` is good for homogenous collections of any size, another case "
"is a fixed-size positional collection with fields of known type at different "
"positions. For that we have `tuple`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:482
#, no-wrap
msgid ""
"(s/def ::point (s/tuple double? double? double?))\n"
"(s/conform ::point [1.5 2.5 -0.5])\n"
"=> [1.5 2.5 -0.5]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:485
msgid ""
"Note that in this case of a \"point\" structure with x/y/z values we "
"actually had a choice of three possible specs:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:487
msgid "Regular expression - `(s/cat :x double? :y double? :z double?)`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:488
msgid "Allows for matching nested structure (not needed here)"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:489
msgid "Conforms to map with named keys based on the `cat` tags"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:490
msgid "Collection - `(s/coll-of double?)`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:491
msgid "Designed for arbitrary size homogenous collections"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:492 en/content/guides/spec.adoc:495
msgid "Conforms to a vector of the values"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:493
msgid "Tuple - `(s/tuple double? double? double?)`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:494
msgid "Designed for fixed size with known positional \"fields\""
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:497
msgid ""
"In this example, `coll-of` will match other (invalid) values as well (like "
"`[1.0]` or `[1.0 2.0 3.0 4.0])`, so it is not a suitable choice - we want "
"fixed fields. The choice between a regular expression and tuple here is to "
"some degree a matter of taste, possibly informed by whether you expect "
"either the tagged return values or error output to be better with one or the "
"other."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:499
msgid ""
"In addition to the support for information maps via `keys`, spec also "
"provides `map-of` for maps with homogenous key and value predicates."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:505
#, no-wrap
msgid ""
"(s/def ::scores (s/map-of string? int?))\n"
"(s/conform ::scores {\"Sally\" 1000, \"Joe\" 500})\n"
";=> {\"Sally\" 1000, \"Joe\" 500}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:508
msgid ""
"By default `map-of` will validate but not conform keys because conformed "
"keys might create key duplicates that would cause entries in the map to be "
"overridden. If conformed keys are desired, pass the option `:conform-keys "
"true`."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:510
msgid ""
"You can also use the various count-related options on `map-of` that you have "
"with `coll-of`."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:514
msgid ""
"Sometimes sequential data is used to encode additional structure (typically "
"new syntax, often used in macros). spec provides the standard https://en."
"wikipedia.org/wiki/Regular_expression[regular expression] operators to "
"describe the structure of a sequential data value:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:516
msgid ""
"https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/cat[`cat`] - concatenation of predicates/patterns"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:517
msgid ""
"https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/alt[`alt`] - choice among alternative predicates/patterns"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:518
msgid ""
"https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/*[`pass:[*]`] - 0 or more of a predicate/pattern"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:519
msgid ""
"https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/%2B[`+`] - 1 or more of a predicate/pattern"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:520
msgid ""
"https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/%3F[`?`] - 0 or 1 of a predicate/pattern"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:522
msgid ""
"Like `or`, both `cat` and `alt` tag their \"parts\" - these tags are then "
"used in the conformed value to identify what was matched, to report errors, "
"and more."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:524
msgid ""
"Consider an ingredient represented by a vector containing a quantity "
"(number) and a unit (keyword). The spec for this data uses `cat` to specify "
"the right components in the right order. Like predicates, regex operators "
"are implicitly converted to specs when passed to functions like `conform`, "
"`valid?`, etc."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:530
#, no-wrap
msgid ""
"(s/def ::ingredient (s/cat :quantity number? :unit keyword?))\n"
"(s/conform ::ingredient [2 :teaspoon])\n"
";;=> {:quantity 2, :unit :teaspoon}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:533
msgid ""
"The data is conformed as a map with the tags as keys. We can use `explain` "
"to examine non-conforming data."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:539
#, no-wrap
msgid ""
";; pass string for unit instead of keyword\n"
"(s/explain ::ingredient [11 \"peaches\"])\n"
";; \"peaches\" - failed: keyword? in: [1] at: [:unit] spec: :user/ingredient\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:543
#, no-wrap
msgid ""
";; leave out the unit\n"
"(s/explain ::ingredient [2])\n"
";; () - failed: Insufficient input at: [:unit] spec: :user/ingredient\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:546
msgid "Let's now see the various occurrence operators `*`, `+`, and `?`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:554
#, no-wrap
msgid ""
"(s/def ::seq-of-keywords (s/* keyword?))\n"
"(s/conform ::seq-of-keywords [:a :b :c])\n"
";;=> [:a :b :c]\n"
"(s/explain ::seq-of-keywords [10 20])\n"
";; 10 - failed: keyword? in: [0] spec: :user/seq-of-keywords\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:563
#, no-wrap
msgid ""
"(s/def ::odds-then-maybe-even (s/cat :odds (s/+ odd?)\n"
"                                     :even (s/? even?)))\n"
"(s/conform ::odds-then-maybe-even [1 3 5 100])\n"
";;=> {:odds [1 3 5], :even 100}\n"
"(s/conform ::odds-then-maybe-even [1])\n"
";;=> {:odds [1]}\n"
"(s/explain ::odds-then-maybe-even [100])\n"
";; 100 - failed: odd? in: [0] at: [:odds] spec: :user/odds-then-maybe-even\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:568
#, no-wrap
msgid ""
";; opts are alternating keywords and booleans\n"
"(s/def ::opts (s/* (s/cat :opt keyword? :val boolean?)))\n"
"(s/conform ::opts [:silent? false :verbose true])\n"
";;=> [{:opt :silent?, :val false} {:opt :verbose, :val true}]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:571
msgid ""
"Finally, we can use `alt` to specify alternatives within the sequential "
"data. Like `cat`, `alt` requires you to tag each alternative but the "
"conformed data is a vector of tag and value."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:581
#, no-wrap
msgid ""
"(s/def ::config (s/* \n"
"                  (s/cat :prop string?\n"
"                         :val  (s/alt :s string? :b boolean?))))\n"
"(s/conform ::config [\"-server\" \"foo\" \"-verbose\" true \"-user\" \"joe\"])\n"
";;=> [{:prop \"-server\", :val [:s \"foo\"]}\n"
";;    {:prop \"-verbose\", :val [:b true]}\n"
";;    {:prop \"-user\", :val [:s \"joe\"]}]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:584
msgid ""
"If you need a description of a specification, use `describe` to retrieve "
"one. Let's try it on some of the specifications we've already defined:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:593
#, no-wrap
msgid ""
"(s/describe ::seq-of-keywords)\n"
";;=> (* keyword?)\n"
"(s/describe ::odds-then-maybe-even)\n"
";;=> (cat :odds (+ odd?) :even (? even?))\n"
"(s/describe ::opts)\n"
";;=> (* (cat :opt keyword? :val boolean?))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:596
msgid ""
"Spec also defines one additional regex operator, https://clojure.github.io/"
"spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/&[`&`], which "
"takes a regex operator and constrains it with one or more additional "
"predicates. This can be used to create regular expressions with additional "
"constraints that would otherwise require custom predicates. For example, "
"consider wanting to match only sequences with an even number of strings:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:604
#, no-wrap
msgid ""
"(s/def ::even-strings (s/& (s/* string?) #(even? (count %))))\n"
"(s/valid? ::even-strings [\"a\"])  ;; false\n"
"(s/valid? ::even-strings [\"a\" \"b\"])  ;; true\n"
"(s/valid? ::even-strings [\"a\" \"b\" \"c\"])  ;; false\n"
"(s/valid? ::even-strings [\"a\" \"b\" \"c\" \"d\"])  ;; true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:610
msgid ""
"When regex ops are combined, they describe a single sequence. If you need to "
"spec a nested sequential collection, you must use an explicit call to "
"https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/spec[`spec`] to start a new nested regex context. For example to "
"describe a sequence like `[:names [\"a\" \"b\"] :nums [1 2 3]]`, you need "
"nested regular expressions to describe the inner sequential data:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:620
#, no-wrap
msgid ""
"(s/def ::nested\n"
"  (s/cat :names-kw #{:names}\n"
"         :names (s/spec (s/* string?))\n"
"         :nums-kw #{:nums}\n"
"         :nums (s/spec (s/* number?))))\n"
"(s/conform ::nested [:names [\"a\" \"b\"] :nums [1 2 3]])\n"
";;=> {:names-kw :names, :names [\"a\" \"b\"], :nums-kw :nums, :nums [1 2 3]}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:623
msgid ""
"If the specs were removed this spec would instead match a sequence like `[:"
"names \"a\" \"b\" :nums 1 2 3]`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:633
#, no-wrap
msgid ""
"(s/def ::unnested\n"
"  (s/cat :names-kw #{:names}\n"
"         :names (s/* string?)\n"
"         :nums-kw #{:nums}\n"
"         :nums (s/* number?)))\n"
"(s/conform ::unnested [:names \"a\" \"b\" :nums 1 2 3])\n"
";;=> {:names-kw :names, :names [\"a\" \"b\"], :nums-kw :nums, :nums [1 2 3]}\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:635
#, no-wrap
msgid "Using spec for validation"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:638
msgid ""
"Now is a good time to step back and think about how spec can be used for "
"runtime data validation."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:640
msgid ""
"One way to use spec is to explicitly call `valid?` to verify input data "
"passed to a function. You can, for example, use the existing pre- and post-"
"condition support built into `defn`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:648
#, no-wrap
msgid ""
"(defn person-name\n"
"  [person]\n"
"  {:pre [(s/valid? ::person person)]\n"
"   :post [(s/valid? string? %)]}\n"
"  (str (::first-name person) \" \" (::last-name person)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:651
#, no-wrap
msgid ""
"(person-name 42)\n"
";;=> java.lang.AssertionError: Assert failed: (s/valid? :my.domain/person person)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:654
#, no-wrap
msgid ""
"(person-name {::first-name \"Bugs\" ::last-name \"Bunny\" ::email \"bugs@example.com\"})\n"
";; Bugs Bunny\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:657
msgid ""
"When the function is invoked with something that isn't valid `::person` "
"data, the pre-condition fails. Similarly, if there was a bug in our code and "
"the output was not a string, the post-condition would fail."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:659
msgid ""
"Another option is to use `s/assert` within your code to assert that a value "
"satisfies a spec. On success the value is returned and on failure an "
"assertion error is thrown. By default assertion checking is off - this can "
"be changed at the REPL with `s/check-asserts` or on startup by setting the "
"system property `clojure.spec.check-asserts=true`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:666
#, no-wrap
msgid ""
"(defn person-name\n"
"  [person]\n"
"  (let [p (s/assert ::person person)]\n"
"    (str (::first-name p) \" \" (::last-name p))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:671
#, no-wrap
msgid ""
"(s/check-asserts true)\n"
"(person-name 100)\n"
";; Execution error - invalid arguments to my.domain/person-name at (REPL:3).\n"
";; 100 - failed: map?\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:674
msgid ""
"A deeper level of integration is to call conform and use the return value "
"with destructuring to pull apart the input. This will be particularly useful "
"for complex inputs with alternate options."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:676
msgid "Here we conform using the config specification defined above:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:682
#, no-wrap
msgid ""
"(defn- set-config [prop val]\n"
"  ;; dummy fn\n"
"  (println \"set\" prop val))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:689
#, no-wrap
msgid ""
"(defn configure [input]\n"
"  (let [parsed (s/conform ::config input)]\n"
"    (if (= parsed ::s/invalid)\n"
"      (throw (ex-info \"Invalid input\" (s/explain-data ::config input)))\n"
"      (for [{prop :prop [_ val] :val} parsed]\n"
"        (set-config (subs prop 1) val)))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:691
#, no-wrap
msgid "(configure [\"-server\" \"foo\" \"-verbose\" true \"-user\" \"joe\"])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:694
msgid ""
"Here configure calls `conform` to produce data good for destructuring the "
"config input. The result is either the special `::s/invalid` value or an "
"annotated form of the result:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:700
#, no-wrap
msgid ""
"[{:prop \"-server\", :val [:s \"foo\"]} \n"
" {:prop \"-verbose\", :val [:b true]} \n"
" {:prop \"-user\", :val [:s \"joe\"]}]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:703
msgid ""
"In the success case, the parsed input is transformed into the desired shape "
"for further processing. In the error case, we call `explain-data` to "
"generate error message data. The explain data contains information about "
"what expression failed to conform, the path to that expression in the "
"specification, and the predicate it was attempting to match."
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:704
#, no-wrap
msgid "Spec'ing functions"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:707
msgid ""
"The pre- and post-condition example in the previous section hinted at an "
"interesting question - how do we define the input and output specifications "
"for a function or macro?"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:709
msgid ""
"Spec has explicit support for this using https://clojure.github.io/spec."
"alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/fdef[`fdef`], which "
"defines specifications for a function - the arguments and/or the return "
"value spec, and optionally a function that can specify a relationship "
"between args and return."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:711
msgid ""
"Let's consider a `ranged-rand` function that produces a random number in a "
"range:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:718
#, no-wrap
msgid ""
"(defn ranged-rand\n"
"  \"Returns random int in range start <= rand < end\"\n"
"  [start end]\n"
"  (+ start (long (rand (- end start)))))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:721
msgid "We can then provide a specification for that function:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:730
#, no-wrap
msgid ""
"(s/fdef ranged-rand\n"
"  :args (s/and (s/cat :start int? :end int?)\n"
"               #(< (:start %) (:end %)))\n"
"  :ret int?\n"
"  :fn (s/and #(>= (:ret %) (-> % :args :start))\n"
"             #(< (:ret %) (-> % :args :end))))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:733
msgid ""
"This function spec demonstrates a number of features. First the `:args` is a "
"compound spec that describes the function arguments. This spec is invoked "
"with the args in a list, as if they were passed to `(apply fn (arg-list))`. "
"Because the args are sequential and the args are positional fields, they are "
"almost always described using a regex op, like `cat`, `alt`, or `*`."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:735
msgid ""
"The second `:args` predicate takes as input the conformed result of the "
"first predicate and verifies that start < end. The `:ret` spec indicates the "
"return is also an integer. Finally, the `:fn` spec checks that the return "
"value is >= start and < end."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:737
msgid ""
"Once a spec has been created for a function, the `doc` for the function will "
"also include it:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:741
#, no-wrap
msgid "(doc ranged-rand)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:749
#, no-wrap
msgid ""
"user/ranged-rand\n"
"([start end])\n"
"  Returns random int in range start <= rand < end\n"
"Spec\n"
"  args: (and (cat :start int? :end int?) (< (:start %) (:end %)))\n"
"  ret: int?\n"
"  fn: (and (>= (:ret %) (-> % :args :start)) (< (:ret %) (-> % :args :end)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:752
#, no-wrap
msgid "We'll see later how we can use a function spec for development and testing.\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:753
#, no-wrap
msgid "Higher order functions"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:756
msgid ""
"Higher order functions are common in Clojure and spec provides https://"
"clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/"
"fspec[`fspec`] to support spec'ing them."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:758
msgid "For example, consider the `adder` function:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:760 en/content/guides/spec.adoc:784
#: en/content/guides/spec.adoc:806 en/content/guides/spec.adoc:878
#: en/content/guides/spec.adoc:923 en/content/guides/spec.adoc:971
#: en/content/guides/spec.adoc:1011 en/content/guides/spec.adoc:1071
#: en/content/guides/spec.adoc:1151 en/content/guides/spec.adoc:1192
#: en/content/guides/spec.adoc:1201 en/content/guides/spec.adoc:1225
#: en/content/guides/spec.adoc:1297
#: en/content/news/2012/05/15/anatomy-of-reducer.adoc:73
msgid "[source,clojure]"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:762
msgid "(defn adder [x] #(+ x %))"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:765
#, no-wrap
msgid "`adder` returns a function that adds x. We can declare a function spec for `adder` using `fspec` for the return value:\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:767 en/content/guides/spec.adoc:793
#: en/content/guides/spec.adoc:826 en/content/guides/spec.adoc:838
#: en/content/guides/spec.adoc:853 en/content/guides/spec.adoc:887
#: en/content/guides/spec.adoc:912 en/content/guides/spec.adoc:949
#: en/content/guides/spec.adoc:959 en/content/guides/spec.adoc:991
#: en/content/guides/spec.adoc:1024 en/content/guides/spec.adoc:1032
#: en/content/guides/spec.adoc:1044 en/content/guides/spec.adoc:1080
#: en/content/guides/spec.adoc:1089 en/content/guides/spec.adoc:1111
#: en/content/guides/spec.adoc:1122 en/content/guides/spec.adoc:1133
#: en/content/guides/spec.adoc:1160 en/content/guides/spec.adoc:1175
#: en/content/guides/spec.adoc:1208 en/content/guides/spec.adoc:1248
#: en/content/guides/spec.adoc:1258 en/content/guides/spec.adoc:1282
#: en/content/guides/spec.adoc:1312 en/content/guides/spec.adoc:1332
#: en/content/news/2012/05/15/anatomy-of-reducer.adoc:85
#, no-wrap
msgid "[source,clojure]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:773
#, no-wrap
msgid ""
"(s/fdef adder\n"
"  :args (s/cat :x number?)\n"
"  :ret (s/fspec :args (s/cat :y number?)\n"
"                :ret number?)\n"
"  :fn #(= (-> % :args :x) ((:ret %) 0)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:776
#, no-wrap
msgid "The `:ret` spec uses `fspec` to declare that the returning function takes and returns a number. Even more interesting, the `:fn` spec can state a general property that relates the `:args` (where we know x) and the result we get from invoking the function returned from `adder`, namely that adding 0 to it should return x.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:780
msgid ""
"As macros are functions that take code and produce code, they can also be "
"spec'ed like functions. One special consideration however is that you must "
"keep in mind that you are receiving code as data, not evaluated arguments, "
"and that you are most commonly producing new code as data, so often it's not "
"helpful to spec the :ret value of a macro (as it's just code)."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:782
msgid "For example, we could spec the `clojure.core/declare` macro like this:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:788
#, no-wrap
msgid ""
"(s/fdef clojure.core/declare\n"
"    :args (s/cat :names (s/* simple-symbol?))\n"
"    :ret any?)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:791
#, no-wrap
msgid "The Clojure macroexpander will look for and conform :args specs registered for macros at macro expansion time (not runtime!). If an error is detected, `explain` will be invoked to explain the error:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:797
msgid ""
"(declare 100)  ;; Syntax error macroexpanding clojure.core/declare at "
"(REPL:1:1).  ;; 100 - failed: simple-symbol? at: [:names]"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:800
#, no-wrap
msgid "Because macros are always checked during macro expansion, you do not need to call instrument for macro specs.\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:801
#, no-wrap
msgid "A game of cards"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:804
msgid "Here's a bigger set of specs to model a game of cards:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:810
msgid ""
"(def suit? #{:club :diamond :heart :spade})  (def rank? (into #{:jack :"
"queen :king :ace} (range 2 11)))  (def deck (for [suit suit? rank rank?] "
"[rank suit]))"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:813
msgid "(s/def ::card (s/tuple rank? suit?))  (s/def ::hand (s/* ::card))"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:817
msgid ""
"(s/def ::name string?)  (s/def ::score int?)  (s/def ::player (s/keys :req "
"[::name ::score ::hand]))"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:821
msgid ""
"(s/def ::players (s/* ::player))  (s/def ::deck (s/* ::card))  (s/def ::game "
"(s/keys :req [::players ::deck]))"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:824
#, no-wrap
msgid "We can validate a piece of this data against the schema:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:833
#, no-wrap
msgid ""
"(def kenny\n"
"  {::name \"Kenny Rogers\"\n"
"   ::score 100\n"
"   ::hand []})\n"
"(s/valid? ::player kenny)\n"
";;=> true\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:836
#, no-wrap
msgid "Or look at the errors we'll get from some bad data:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:846
#, no-wrap
msgid ""
"(s/explain ::game\n"
"  {::deck deck\n"
"   ::players [{::name \"Kenny Rogers\"\n"
"               ::score 100\n"
"               ::hand [[2 :banana]]}]})\n"
";; :banana - failed: suit? in: [:user/players 0 :user/hand 0 1] \n"
";;   at: [:user/players :user/hand 1] spec: :user/card\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:849
#, no-wrap
msgid "The error indicates the key path in the data structure down to the invalid value, the non-matching value, the spec part it's trying to match, the path in that spec, and the predicate that failed.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:851
#, no-wrap
msgid "If we have a function `deal` that doles out some cards to the players we can spec that function to verify the arg and return value are both suitable data values. We can also specify a `:fn` spec to verify that the count of cards in the game before the deal equals the count of cards after the deal.\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:857
#, no-wrap
msgid ""
"(defn total-cards [{:keys [::deck ::players] :as game}]\n"
"  (apply + (count deck)\n"
"    (map #(-> % ::hand count) players)))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:859
msgid "(defn deal [game] .... )"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:865
#, no-wrap
msgid ""
"(s/fdef deal\n"
"  :args (s/cat :game ::game)\n"
"  :ret ::game\n"
"  :fn #(= (total-cards (-> % :args :game))\n"
"          (total-cards (-> % :ret))))\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:867
#: en/content/guides/test_check_beginner.adoc:118
#, no-wrap
msgid "Generators"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:870
msgid ""
"A key design constraint of spec is that all specs are also designed to act "
"as generators of sample data that conforms to the spec (a critical "
"requirement for property-based testing)."
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:871
#, no-wrap
msgid "Project Setup"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:874
msgid ""
"spec generators rely on the Clojure property testing library https://github."
"com/clojure/test.check[test.check]. However, this dependency is dynamically "
"loaded and you can use the parts of spec other than `gen`, `exercise`, and "
"testing without declaring test.check as a runtime dependency. When you wish "
"to use these parts of spec (typically during testing), you will need to "
"declare a dev dependency on test.check."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:876
msgid "In Leiningen add this to project.clj:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:883
#, no-wrap
msgid "In Leiningen the dev profile dependencies are included during testing but not published as a dependency or included in uber jars.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:885
#, no-wrap
msgid "In Boot, add your dependency with test scope in your build.boot file (this is also possible in Leiningen but the approach above is preferred):\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:890
#, no-wrap
msgid ""
"(set-env!\n"
" :dependencies '[[org.clojure/test.check \"0.9.0\" :scope \"test\"]])\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:893
#, no-wrap
msgid "In Maven, declare your dependency as a test scope dependency:\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:895
#, no-wrap
msgid "[source,xml]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:907
#, no-wrap
msgid ""
"<project>\n"
"  ...\n"
"  <dependencies>\n"
"    <dependency>\n"
"      <groupId>org.clojure</groupId>\n"
"      <artifactId>test.check</artifactId>\n"
"      <version>0.9.0</version>\n"
"      <scope>test</scope>\n"
"    </dependency>\n"
"  </dependency>\n"
"</project>\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:910
#, no-wrap
msgid "In your code you also need to include the `clojure.spec.gen.alpha` namespace:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:914
msgid "(require '[clojure.spec.gen.alpha :as gen])"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:916
#, no-wrap
msgid "Sampling Generators"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:919
msgid ""
"The https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure."
"spec.alpha/gen[`gen`] function can be used to obtain the generator for any "
"spec."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:921
msgid ""
"Once you have obtained a generator with `gen`, there are several ways to use "
"it. You can generate a single sample value with https://clojure.github.io/"
"spec.alpha/clojure.spec.gen.alpha-api.html#clojure.spec.gen.alpha/"
"generate[`generate`] or a series of samples with https://clojure.github.io/"
"spec.alpha/clojure.spec.gen.alpha-api.html#clojure.spec.gen.alpha/"
"sample[`sample`]. Let's see some basic examples:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:932
msgid ""
"(gen/generate (s/gen int?))  ;;=> -959 (gen/generate (s/gen nil?))  ;;=> nil "
"(gen/sample (s/gen string?))  ;;=> (\"\" \"\" \"\" \"\" \"8\" \"W\" \"\" "
"\"G74SmCm\" \"K9sL9\" \"82vC\")  (gen/sample (s/gen #{:club :diamond :heart :"
"spade}))  ;;=> (:heart :diamond :heart :heart :heart :diamond :spade :spade :"
"spade :club)"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:944
msgid ""
"(gen/sample (s/gen (s/cat :k keyword? :ns (s/+ number?))))  ;;=> ((:D "
"-2.0)  ;;=> (:q4/c 0.75 -1)  ;;=> (:*!3/? 0)  ;;=> (:+k_?.p*K.*o!d/*V -3)  ;;"
"=> (:i -1 -1 0.5 -0.5 -4)  ;;=> (:?!/! 0.515625 -15 -8 0.5 0 0.75)  ;;=> (:"
"vv_z2.A??!377.+z1*gR.D9+G.l9+.t9/L34p -1.4375 -29 0.75 -1.25)  ;;=> (:-.!"
"pm8bS_+.Z2qB5cd.p.JI0?_2m.S8l.a_Xtu/+OM_34* -2.3125)  ;;=> (:Ci 6.0 -30 -3 "
"1.0)  ;;=> (:s?cw*8.t+G.OS.xh_z2!.cF-b!PAQ_.E98H4_4lSo/?_m0T*7i 4.4375 -3.5 "
"6.0 108 0.33203125 2 8 -0.517578125 -4))"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:947
#, no-wrap
msgid "What about generating a random player in our card game?\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:954
#, no-wrap
msgid ""
"(gen/generate (s/gen ::player))\n"
";;=> {:spec.examples.guide/name \"sAt8r6t\",\n"
";;    :spec.examples.guide/score 233843,\n"
";;    :spec.examples.guide/hand ([8 :spade] [5 :heart] [9 :club] [3 :heart])}\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:957
#, no-wrap
msgid "What about generating a whole game?\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:962
msgid ""
"(gen/generate (s/gen ::game))  ;; it works! but the output is really long, "
"so not including it here"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:965
#, no-wrap
msgid "So we can now start with a spec, extract a generator, and generate some data. All generated data will conform to the spec we used as a generator. For specs that have a conformed value different than the original value (anything using s/or, s/cat, s/alt, etc) it can be useful to see a set of generated samples plus the result of conforming that sample data. \n"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:966
#, no-wrap
msgid "Exercise"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:969
msgid ""
"For this we have https://clojure.github.io/spec.alpha/clojure.spec.alpha-api."
"html#clojure.spec.alpha/exercise[`exercise`], which returns pairs of "
"generated and conformed values for a spec. `exercise` by default produces 10 "
"samples (like `sample`) but you can pass both functions a number indicating "
"the number of samples to produce."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:979
msgid ""
"(s/exercise (s/cat :k keyword? :ns (s/+ number?)) 5)  ;;=> ;;([(:y -2.0) {:"
"k :y, :ns [-2.0]}] ;; [(:_/? -1.0 0.5) {:k :_/?, :ns [-1.0 0.5]}] ;; [(:-B 0 "
"3.0) {:k :-B, :ns [0 3.0]}] ;; [(:-!.gD*/W+ -3 3.0 3.75) {:k :-!.gD*/W+, :ns "
"[-3 3.0 3.75]}] ;; [(:_Y*+._?q-H/-3* 0 1.25 1.5) {:k :_Y*+._?q-H/-3*, :ns [0 "
"1.25 1.5]}])"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:986
#, no-wrap
msgid ""
"(s/exercise (s/or :k keyword? :s string? :n number?) 5)\n"
";;=> ([:H [:k :H]] \n"
";;    [:ka [:k :ka]]\n"
";;    [-1 [:n -1]] \n"
";;    [\"\" [:s \"\"]]\n"
";;    [-3.0 [:n -3.0]])\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:989
#, no-wrap
msgid "For spec'ed functions we also have https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/exercise-fn[`exercise-fn`], which generates sample args, invokes the spec'ed function and returns the args and the return value.\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1004
#, no-wrap
msgid ""
"(s/exercise-fn `ranged-rand)\n"
"=>\n"
"([(-2 -1)   -2]\n"
" [(-3 3)     0]\n"
" [(0 1)      0]\n"
" [(-8 -7)   -8]\n"
" [(3 13)     7]\n"
" [(-1 0)    -1]\n"
" [(-69 99) -41]\n"
" [(-19 -1)  -5]\n"
" [(-1 1)    -1]\n"
" [(0 65)     7])\n"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1006
#, no-wrap
msgid "Using `s/and` Generators"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1009
msgid ""
"All of the generators we've seen worked fine but there are a number of cases "
"where they will need some additional help. One common case is when the "
"predicate implicitly presumes values of a particular type but the spec does "
"not specify them:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1015
msgid ""
"(gen/generate (s/gen even?))  ;; Execution error (ExceptionInfo) at user/"
"eval1281 (REPL:1).  ;; Unable to construct gen at: [] for: clojure.core"
"$even_QMARK_@73ab3aac"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1018
#, no-wrap
msgid "In this case spec was not able to find a generator for the `even?` predicate. Most of the primitive generators in spec are mapped to the common type predicates (strings, numbers, keywords, etc).\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1020
#, no-wrap
msgid "However, spec is designed to support this case via `and` - the first predicate will determine the generator and subsequent branches will act as filters by applying the predicate to the produced values (using test.check's `such-that`). \n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1022
#, no-wrap
msgid "If we modify our predicate to use an `and` and a predicate with a mapped generator, the `even?` can be used as a filter for generated values instead:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1027
msgid "(gen/generate (s/gen (s/and int? even?)))  ;;=> -15161796"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1030
#, no-wrap
msgid "We can use many predicates to further refine the generated values. For example, say we only wanted to generate numbers that were positive multiples of 3:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1034
msgid "(defn divisible-by [n] #(zero? (mod % n)))"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1039
#, no-wrap
msgid ""
"(gen/sample (s/gen (s/and int?\n"
"                     #(> % 0)\n"
"                     (divisible-by 3))))\n"
";;=> (3 9 1524 3 1836 6 3 3 927 15027)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1042
#, no-wrap
msgid "However, it is possible to go too far with refinement and make something that fails to produce any values. The test.check https://clojure.github.io/test.check/clojure.test.check.generators.html#var-such-that[`such-that`] that implements the refinement will throw an error if the refinement predicate cannot be resolved within a relatively small number of attempts. For example, consider trying to generate strings that happen to contain the word \"hello\":\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1049
msgid ""
";; hello, are you the one I'm looking for? (gen/sample (s/gen (s/and string? "
"#(clojure.string/includes? % \"hello\"))))  ;; Error printing return value "
"(ExceptionInfo) at clojure.test.check.generators/such-that-helper "
"(generators.cljc:320).  ;; Couldn't satisfy such-that predicate after 100 "
"tries."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1052
#, no-wrap
msgid "Given enough time (maybe a lot of time), the generator probably would come up with a string like this, but the underlying `such-that` will make only 100 attempts to generate a value that passes the filter. This is a case where you will need to step in and provide a custom generator.\n"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1053
#, no-wrap
msgid "Custom Generators"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1056
msgid ""
"Building your own generator gives you the freedom to be either narrower and/"
"or be more explicit about what values you want to generate. Alternately, "
"custom generators can be used in cases where conformant values can be "
"generated more efficiently than using a base predicate plus filtering. Spec "
"does not trust custom generators and any values they produce will also be "
"checked by their associated spec to guarantee they pass conformance."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1058
msgid ""
"There are three ways to build up custom generators - in decreasing order of "
"preference:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1062
msgid ""
". Let spec create a generator based on a predicate/spec . Create your own "
"generator from the tools in clojure.spec.gen.alpha . Use test.check or other "
"test.check compatible libraries (like https://github.com/gfredericks/test."
"chuck[test.chuck])"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1067
msgid ""
"[WARNING] ==== The last option requires a runtime dependency on test.check "
"so the first two options are strongly preferred over using test.check "
"directly.  ===="
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1069
msgid ""
"First consider a spec with a predicate to specify keywords from a particular "
"namespace:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1073
msgid "(s/def ::kws (s/and keyword? #(= (namespace %) \"my.domain\")))"
msgstr ""

#. type: Labeled list
#: en/content/guides/spec.adoc:1073
#, no-wrap
msgid "(s/valid? ::kws :my.domain/name) "
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1074
msgid "true"
msgstr ""

#. type: Labeled list
#: en/content/guides/spec.adoc:1074
#, no-wrap
msgid "(gen/sample (s/gen ::kws)) "
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1075
msgid "unlikely we'll generate useful keywords this way"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1078
#, no-wrap
msgid "The simplest way to start generating values for this spec is to have spec create a generator from a fixed set of options. A set is a valid predicate spec so we can create one and ask for it's generator:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1084
msgid ""
"(def kw-gen (s/gen #{:my.domain/name :my.domain/occupation :my.domain/id}))  "
"(gen/sample kw-gen 5)  ;;=> (:my.domain/occupation :my.domain/occupation :my."
"domain/name :my.domain/id :my.domain/name)"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1087
#, no-wrap
msgid "To redefine our spec using this custom generator, use https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/with-gen[`with-gen`] which takes a spec and a replacement generator:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1092
#, no-wrap
msgid ""
"(s/def ::kws (s/with-gen (s/and keyword? #(= (namespace %) \"my.domain\"))\n"
"               #(s/gen #{:my.domain/name :my.domain/occupation :my.domain/id})))\n"
msgstr ""

#. type: Labeled list
#: en/content/guides/spec.adoc:1092
#, no-wrap
msgid "(s/valid? ::kws :my.domain/name)  "
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1095
msgid ""
"true (gen/sample (s/gen ::kws))  ;;=> (:my.domain/occupation :my.domain/"
"occupation :my.domain/name ...)"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1098
#, no-wrap
msgid "Note that `with-gen` (and other places that take a custom generator) take a no-arg function that returns the generator, allowing it to be lazily realized.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1100
#, no-wrap
msgid "One downside to this approach is we are missing what property testing is really good at: automatically generating data across a wide search space to find unexpected problems. \n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1102
#, no-wrap
msgid "The clojure.spec.gen.alpha namespace has a number of functions for generator \"primitives\" as well as \"combinators\" for combining them into more complicated generators. \n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1107
#, no-wrap
msgid ""
"[NOTE]\n"
"====\n"
"Nearly all of the functions in the clojure.spec.gen.alpha namespace are merely wrappers that dynamically load functions of the same name in test.check. You should refer to the documentation for https://clojure.github.io/test.check/[test.check] for more details on how all of the clojure.spec.gen.alpha generator functions work.\n"
"====\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1109
#, no-wrap
msgid "In this case we want our keyword to have open names but fixed namespaces. There are many ways to accomplish this but one of the simplest is to use https://clojure.github.io/spec.alpha/clojure.spec.gen.alpha-api.html#clojure.spec.gen.alpha/fmap[`fmap`] to build up a keyword based on generated strings:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1115
msgid ""
"(def kw-gen-2 (gen/fmap #(keyword \"my.domain\" %) (gen/string-"
"alphanumeric)))  (gen/sample kw-gen-2 5)  ;;=> (:my.domain/ :my.domain/ :my."
"domain/1 :my.domain/1O :my.domain/l9p2)"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1118
#, no-wrap
msgid "`gen/fmap` takes a function to apply and a generator. The function will be applied to each sample produced by the generator allowing us to build one generator on another.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1120
#, no-wrap
msgid "However, we can spot a problem in the example above - generators are often designed to return \"simpler\" values first and any string-oriented generator will often return an empty string which is not a valid keyword. We can make a slight adjustment to omit that particular value using https://clojure.github.io/spec.alpha/clojure.spec.gen.alpha-api.html#clojure.spec.gen.alpha/such-that[`such-that`] which lets us specify a filtering condition:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1128
#, no-wrap
msgid ""
"(def kw-gen-3 (gen/fmap #(keyword \"my.domain\" %)\n"
"               (gen/such-that #(not= % \"\")\n"
"                 (gen/string-alphanumeric))))\n"
"(gen/sample kw-gen-3 5)\n"
";;=> (:my.domain/O :my.domain/b :my.domain/ZH :my.domain/31 :my.domain/U)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1131
#, no-wrap
msgid "Returning to our \"hello\" example, we now have the tools to make that generator:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1140
#, no-wrap
msgid ""
"(s/def ::hello\n"
"  (s/with-gen #(clojure.string/includes? % \"hello\")\n"
"    #(gen/fmap (fn [[s1 s2]] (str s1 \"hello\" s2))\n"
"      (gen/tuple (gen/string-alphanumeric) (gen/string-alphanumeric)))))\n"
"(gen/sample (s/gen ::hello))\n"
";;=> (\"hello\" \"ehello3\" \"eShelloO1\" \"vhello31p\" \"hello\" \"1Xhellow\" \"S5bhello\" \"aRejhellorAJ7Yj\" \"3hellowPMDOgv7\" \"UhelloIx9E\")\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1143
#, no-wrap
msgid "Here we generate a tuple of a random prefix and random suffix strings, then insert \"hello\" between them.\n"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1144
#, no-wrap
msgid "Range Specs and Generators"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1147
msgid ""
"There are several cases where it's useful to spec (and generate) values in a "
"range and spec provides helpers for these cases."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1149
msgid ""
"For example, in the case of a range of integer values (for example, a "
"bowling roll), use https://clojure.github.io/spec.alpha/clojure.spec.alpha-"
"api.html#clojure.spec.alpha/int-in[`int-in`] to spec a range (end is "
"exclusive):"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1155
msgid ""
"(s/def ::roll (s/int-in 0 11))  (gen/sample (s/gen ::roll))  ;;=> (1 0 0 3 1 "
"7 10 1 5 0)"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1158
#, no-wrap
msgid "spec also includes https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/inst-in[`inst-in`] for a range of instants:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1168
#, no-wrap
msgid ""
"(s/def ::the-aughts (s/inst-in #inst \"2000\" #inst \"2010\"))\n"
"(drop 50 (gen/sample (s/gen ::the-aughts) 55))\n"
";;=> (#inst\"2005-03-03T08:40:05.393-00:00\"\n"
";;    #inst\"2008-06-13T01:56:02.424-00:00\"\n"
";;    #inst\"2000-01-01T00:00:00.610-00:00\"\n"
";;    #inst\"2006-09-13T09:44:40.245-00:00\"\n"
";;    #inst\"2000-01-02T10:18:42.219-00:00\")\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1171
#, no-wrap
msgid "Due to the generator implementation, it takes a few samples to get \"interesting\" so I skipped ahead a bit.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1173
#, no-wrap
msgid "Finally, https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/double-in[`double-in`] has support for double ranges and special options for checking special double values like `NaN` (not a number), `Infinity`, and `-Infinity`. \n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1183
msgid ""
"(s/def ::dubs (s/double-in :min -100.0 :max 100.0 :NaN? false :infinite? "
"false))  (s/valid? ::dubs 2.9)  ;;=> true (s/valid? ::dubs Double/"
"POSITIVE_INFINITY)  ;;=> false (gen/sample (s/gen ::dubs))  ;;=> (-1.0 -1.0 "
"-1.5 1.25 -0.5 -1.0 -3.125 -1.5625 1.25 -0.390625)"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1186
#, no-wrap
msgid "To learn more about generators, read the test.check https://clojure.github.io/test.check/intro.html[tutorial] or https://clojure.github.io/test.check/generator-examples.html[examples]. Do keep in mind that while clojure.spec.gen.alpha is a large subset of clojure.test.check.generators, not everything is included.\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:1187
#, no-wrap
msgid "Instrumentation and Testing"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1190
msgid ""
"spec provides a set of development and testing functionality in the `clojure."
"spec.test.alpha` namespace, which we can include with:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1194 en/content/guides/spec.adoc:1227
msgid "(require '[clojure.spec.test.alpha :as stest])"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1196
#: en/content/news/2017/12/08/clojure19.adoc:18 en/content/about/spec.adoc:100
#, no-wrap
msgid "Instrumentation"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1199
msgid ""
"Instrumentation validates that the `:args` spec is being invoked on "
"instrumented functions and thus provides validation for external uses of a "
"function. Let's turn on instrumentation for our previously spec'ed `ranged-"
"rand` function:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1203
msgid "(stest/instrument `ranged-rand)"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1206
#, no-wrap
msgid "Instrument takes a fully-qualified symbol so we use `pass:[`]` here to resolve it in the context of the current namespace. If the function is invoked with args that do not conform with the `:args` spec you will see an error like this:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1212
msgid ""
"(ranged-rand 8 5)  Execution error - invalid arguments to user/ranged-rand "
"at (REPL:1).  {:start 8, :end 5} - failed: (< (:start %) (:end %))"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1215
#, no-wrap
msgid "The error fails in the second args predicate that checks `(< start end)`. Note that the `:ret` and `:fn` specs are not checked with instrumentation as validating the implementation should occur at testing time.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1217
#, no-wrap
msgid "Instrumentation can be turned off using the complementary function `unstrument`. Instrumentation is likely to be useful at both development time and during testing to discover errors in calling code. It is not recommended to use instrumentation in production due to the overhead involved with checking args specs.\n"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1218
#, no-wrap
msgid "Testing"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1221
msgid ""
"We mentioned earlier that `clojure.spec.test.alpha` provides tools for "
"automatically testing functions. When functions have specs, we can use "
"https://clojure.github.io/spec.alpha/clojure.spec.test.alpha-api."
"html#clojure.spec.test.alpha/check[`check`], to automatically generate tests "
"that check the function using the specs."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1223
msgid ""
"`check` will generate arguments based on the `:args` spec for a function, "
"invoke the function, and check that the `:ret` and `:fn` specs were "
"satisfied."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1233
#, no-wrap
msgid ""
"(stest/check `ranged-rand)\n"
";;=> ({:spec #object[clojure.spec.alpha$fspec_impl$reify__13728 ...],\n"
";;     :clojure.spec.test.check/ret {:result true, :num-tests 1000, :seed 1466805740290},\n"
";;     :sym spec.examples.guide/ranged-rand,\n"
";;     :result true})\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1242
#, no-wrap
msgid ""
"[NOTE]\n"
"====\n"
"A keen observer will notice that `ranged-rand` contains a subtle bug. If the difference between start\n"
"and end is very large (larger than is representable by `Long/MAX_VALUE`), then `ranged-rand` will\n"
"produce an IntegerOverflowException. If you run `check` several times you will eventually\n"
"cause this case to occur.\n"
"====\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1244
#, no-wrap
msgid "`check` also takes a number of options that can be passed to test.check to influence the test run, as well as the option to override generators for parts of the spec, by either name or path.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1246
#, no-wrap
msgid "Imagine instead that we made an error in the ranged-rand code and swapped start and end:\n"
msgstr ""

#. type: Labeled list
#: en/content/guides/spec.adoc:1249
#, no-wrap
msgid "(defn ranged-rand  "
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1250
msgid "BROKEN!"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1253
msgid ""
"\"Returns random int in range start <= rand < end\" [start end] (+ start "
"(long (rand (- start end)))))"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1256
#, no-wrap
msgid "This broken function will still create random integers, just not in the expected range. Our `:fn` spec will detect the problem when checking the var:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1275
#, no-wrap
msgid ""
"(stest/abbrev-result (first (stest/check `ranged-rand)))\n"
";;=> {:spec (fspec\n"
";;            :args (and (cat :start int? :end int?) (fn* [p1__3468#] (< (:start p1__3468#) (:end p1__3468#))))\n"
";;            :ret int?\n"
";;            :fn (and\n"
";;                  (fn* [p1__3469#] (>= (:ret p1__3469#) (-> p1__3469# :args :start)))\n"
";;                  (fn* [p1__3470#] (< (:ret p1__3470#) (-> p1__3470# :args :end))))),\n"
";;     :sym spec.examples.guide/ranged-rand,\n"
";;     :result {:clojure.spec.alpha/problems [{:path [:fn],\n"
";;                                             :pred (>= (:ret %) (-> % :args :start)),\n"
";;                                             :val {:args {:start -3, :end 0}, :ret -5},\n"
";;                                             :via [],\n"
";;                                             :in []}],\n"
";;              :clojure.spec.test.alpha/args (-3 0),\n"
";;              :clojure.spec.test.alpha/val {:args {:start -3, :end 0}, :ret -5},\n"
";;              :clojure.spec.alpha/failure :test-failed}}\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1278
#, no-wrap
msgid "`check` has reported an error in the `:fn` spec. We can see the arguments passed were -3 and 0 and the return value was -5, which is out of the expected range.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1280
#, no-wrap
msgid "To test all of the spec'ed functions in a namespace (or multiple namespaces), use https://clojure.github.io/spec.alpha/clojure.spec.test.alpha-api.html#clojure.spec.test.alpha/enumerate-namespace[`enumerate-namespace`] to generate the set of symbols naming vars in the namespace:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1284
msgid "(-> (stest/enumerate-namespace 'user) stest/check)"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1287
#, no-wrap
msgid "And you can check all of the spec'ed functions by calling `stest/check` without any arguments.\n"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1288
#, no-wrap
msgid "Combining `check` and `instrument`"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1291
msgid ""
"While both `instrument` (for enabling `:args` checking) and `check` (for "
"generating tests of a function) are useful tools, they can be combined to "
"provide even deeper levels of test coverage."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1293
msgid ""
"`instrument` takes a number of options for changing the behavior of "
"instrumented functions, including support for swapping in alternate "
"(narrower) specs, stubbing functions (by using the `:ret` spec to generate "
"results), or replacing functions with an alternate implementation."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1295
msgid ""
"Consider the case where we have a low-level function that invokes a remote "
"service and a higher-level function that calls it."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1299
msgid ";; code under test"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1303
#, no-wrap
msgid ""
"(defn invoke-service [service request]\n"
"  ;; invokes remote service\n"
"  )\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1307
#, no-wrap
msgid ""
"(defn run-query [service query]\n"
"  (let [{::keys [result error]} (invoke-service service {::query query})]\n"
"    (or result error)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1310
#, no-wrap
msgid "We can spec these functions using the following specs:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1319
#, no-wrap
msgid ""
"(s/def ::query string?)\n"
"(s/def ::request (s/keys :req [::query]))\n"
"(s/def ::result (s/coll-of string? :gen-max 3))\n"
"(s/def ::error int?)\n"
"(s/def ::response (s/or :ok (s/keys :req [::result])\n"
"                    :err (s/keys :req [::error])))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1323
#, no-wrap
msgid ""
"(s/fdef invoke-service\n"
"  :args (s/cat :service any? :request ::request)\n"
"  :ret ::response)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1327
#, no-wrap
msgid ""
"(s/fdef run-query\n"
"  :args (s/cat :service any? :query string?)\n"
"  :ret (s/or :ok ::result :err ::error))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1330
#, no-wrap
msgid "And then we want to test the behavior of `run-query` while stubbing out `invoke-service` with `instrument` so that the remote service is not invoked:\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1341
msgid ""
"(stest/instrument `invoke-service {:stub #{`invoke-service}})  ;;=> [spec."
"examples.guide/invoke-service] (invoke-service nil {::query \"test\"})  ;;=> "
"#:spec.examples.guide{:error -11} (invoke-service nil {::query \"test\"})  ;;"
"=> #:spec.examples.guide{:result [\"kq0H4yv08pLl4QkVH8\" "
"\"in6gH64gI0ARefv3k9Z5Fi23720gc\"]} (stest/summarize-results (stest/check "
"`run-query))  ;;=> {:total 1, :check-passed 1}"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1344
#, no-wrap
msgid "The first call here instruments and stubs `invoke-service`. The second and third calls demonstrate that calls to `invoke-service` now return generated results (rather than hitting a service). Finally, we can use `check` on the higher level function to test that it behaves properly based on the generated stub results returned from `invoke-service`.\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:1345
#, no-wrap
msgid "Wrapping Up"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1347
msgid ""
"In this guide we have covered most of the features for designing and using "
"specs and generators. We expect to add some more advanced generator "
"techniques and help on testing in a future update."
msgstr ""
