# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2019-07-25 20:54+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ==
#: en/content/reference/transients.adoc:75 en/content/guides/equality.adoc:14
#: en/content/guides/comparators.adoc:12
#: en/content/news/2017/01/31/state-of-clojure-2016.adoc:83
#: en/content/news/2012/05/08/reducers.adoc:164
#: en/content/news/2012/05/15/anatomy-of-reducer.adoc:194
#: en/content/about/state.adoc:74
#, no-wrap
msgid "Summary"
msgstr ""

#. type: Title ==
#: en/content/guides/test_check_beginner.adoc:11
#: en/content/guides/equality.adoc:128 en/content/guides/comparators.adoc:73
#: en/content/guides/reader_conditionals.adoc:11
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: Title =
#: en/content/guides/comparators.adoc:1
#, no-wrap
msgid "Comparators Guide"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:4
msgid "Andy Fingerhut 2016-02-22"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:11
msgid ""
"_Note: This document describes Clojure 1.10 and Java 8, but applies to most "
"other versions as well._"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:18
msgid ""
"A comparator is a function that takes two arguments _x_ and _y_ and returns "
"a value indicating the relative order in which _x_ and _y_ should be sorted. "
"It can be a 3-way comparator returning an integer, or a 2-way comparator "
"returning a boolean.  See the DOs below for what the return values should "
"be, depending upon the order of _x_ and _y_."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:25
msgid ""
"In Clojure you need comparators for sorting a collection of values, or for "
"maintaining a collection of values in a desired sorted order, e.g a https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-"
"map[sorted-map], https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/sorted-set[sorted-set], or https://clojure.github.io/data."
"priority-map/#clojure.data.priority-map/priority-map[priority-map] (also "
"known as a priority queue)."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:30
msgid ""
"The default comparator https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/compare[compare] works well for sorting numbers in "
"increasing order, or strings, keywords, or symbols, in https://en.wikipedia."
"org/wiki/Lexicographical_order[lexicographic] (i.e dictionary) order, and a "
"few other cases. See below for examples and more details."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:33
msgid ""
"If `compare` does not do what you want, you must provide your own comparator "
"that does. Each of the recommendations below is explained in more detail "
"later in this document."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:35
msgid "DOs:"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:39
msgid ""
"Ensure that your comparators are based on a https://en.wikipedia.org/wiki/"
"Total_order[total order] over the values you want to compare. It should be "
"able to compare any pair of values that can appear in your data set, and "
"determine which value should come first (or that they are equal)."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:40
msgid "Write either a 3-way comparator or a boolean comparator:"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:41
msgid ""
"A 3-way comparator takes 2 values, _x_ and _y_, and returns a Java 32-bit "
"_int_ that is negative if"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:43
msgid ""
"_x_ comes before _y_, positive if _x_ comes after _y_, or 0 if they are "
"equal. Use values -1, 0, and 1 if you have no reason to prefer other return "
"values."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:44
msgid ""
"A boolean comparator takes 2 values, _x_ and _y_, and returns true if _x_ "
"comes before _y_, or"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:47
msgid ""
"false otherwise (including if _x_ and _y_ are equal). `<` and `>` are good "
"examples. `\\<=` and `>=` are not. Performance note: your boolean comparator "
"may be called twice to distinguish between the \"comes after\" or \"equals\" "
"cases."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:48
msgid ""
"Reverse the sort by reversing the order that you give the arguments to an "
"existing comparator."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:50
msgid ""
"Compare equal-length Clojure vectors containing \"sort keys\" in order to do "
"a multi-field comparison between values."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:53
msgid ""
"Remove or replace occurrences of \"Not a Number\" (`pass:[##NaN]`)  from "
"your data before sorting a collection, and avoid using them as parts of keys "
"in a sorted collection."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:55
msgid "DO NOTs:"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:59
msgid ""
"Do not write a boolean comparator that returns true if the values are equal. "
"Such a comparator is inconsistent. It will cause sorted collections to "
"behave incorrectly, and sorting to give unpredictable orders."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:61
msgid ""
"Do not use comparators for sorted sets and maps that treat two values as "
"equal, unless you want at most one of those two values to appear in the "
"sorted collection."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:62
msgid ""
"Do not use subtraction when writing a 3-way comparator, unless you really "
"know what you are doing."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:72
msgid ""
"See also: https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/compare[compare], https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/sort[sort], https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/sort-by[sort-by], https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/sorted-set[sorted-set], https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/sorted-set-by[sorted-"
"set-by], https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/sorted-map[sorted-map], https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/sorted-map-by[sorted-map-by], https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/subseq[subseq], https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/rsubseq[rsubseq]"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:78
msgid ""
"Here we describe the default sorting order provided by the function "
"`compare`.  After that we give examples of other comparators, with some "
"guidelines to follow and mistakes to avoid when writing your own."
msgstr ""

#. type: Title ==
#: en/content/guides/comparators.adoc:79
#, no-wrap
msgid "Clojure's default comparator"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:83
msgid ""
"If you do not specify your own comparator, sorting is done by a built-in "
"function `compare`.  `compare` works for many types of values, ordering them "
"in one particular way:"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:89
msgid ""
"numbers are sorted in increasing numeric order, returning 0 if two numbers "
"are numerically equal by `==`, even if `=` returns false.  Exception: Even "
"though `pass:[(== ##NaN x)]` is false for all numbers _x_, even `pass:"
"[##NaN]`, `(compare ##NaN x)` is 0 for all numbers _x_, including `pass:"
"[##NaN]`."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:94
msgid ""
"strings are sorted in http://en.wikipedia.org/wiki/"
"Lexicographical_order[lexicographic order] (aka dictionary order) by their "
"representation as sequences of UTF-16 code units.  This is alphabetical "
"order (case-sensitive)  for strings restricted to the ASCII subset."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:99
msgid ""
"symbols are sorted first by their namespace, if they have one, and if they "
"have the same namespace, then by their name.  Both the namespace and names "
"are compared as their string representations would be, lexicographically.  "
"All symbols that do not have a namespace are sorted before any symbol with a "
"namespace."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:101
msgid ""
"keywords are sorted the same way as symbols, but an exception is thrown if "
"you attempt to compare a keyword to a symbol."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:104
msgid ""
"vectors are sorted from fewest elements to most elements, with http://en."
"wikipedia.org/wiki/Lexicographical_order[lexicographic ordering] among equal "
"length vectors."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:105
msgid "Clojure refs are sorted in the order that they were created."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:109
msgid ""
"All Java types implementing the https://docs.oracle.com/javase/8/docs/api/"
"java/lang/Comparable.html[Comparable] interface such as characters, "
"booleans, File, URI, and UUID are compared via their `compareTo` methods."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:111
msgid ""
"`nil`: can be compared to all values above, and is considered less than "
"anything else."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:116
msgid ""
"`compare` throws an exception if given two values whose types are \"too "
"different\", e.g. it can compare integers, longs, and doubles to each other, "
"but not strings to keywords or keywords to symbols.  It cannot compare "
"lists, sequences, sets, or maps."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:119
msgid ""
"The examples below with `sort`, `sorted-set`, and `sorted-map` all use the "
"default comparator."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:124
#, no-wrap
msgid ""
"user> (sort [22/7 2.71828 ##-Inf 1 55 3N])\n"
"(##-Inf 1 2.71828 3N 22/7 55)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:127
#, no-wrap
msgid ""
"user> (sorted-set \"aardvark\" \"boo\" \"a\" \"Antelope\" \"bar\")\n"
"#{\"Antelope\" \"a\" \"aardvark\" \"bar\" \"boo\"}\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:130
#, no-wrap
msgid ""
"user> (sorted-set 'user/foo 'clojure.core/pprint 'bar 'clojure.core/apply 'user/zz)\n"
"#{bar clojure.core/apply clojure.core/pprint user/foo user/zz}\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:133
#, no-wrap
msgid ""
"user> (sorted-map :map-key 10, :amp [3 2 1], :blammo \"kaboom\")\n"
"{:amp [3 2 1], :blammo \"kaboom\", :map-key 10}\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:136
#, no-wrap
msgid ""
"user> (sort [[-8 2 5] [-5 -1 20] [1 2] [1 -5] [10000]])\n"
"([10000] [1 -5] [1 2] [-8 2 5] [-5 -1 20])\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:139
#, no-wrap
msgid ""
"user> (import '(java.util UUID))\n"
"java.util.UUID\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:144
#, no-wrap
msgid ""
"user> (sort [(UUID. 0xa 0) (UUID. 5 0x11) (UUID. 5 0xb)])\n"
"(#uuid \"00000000-0000-0005-0000-00000000000b\"\n"
" #uuid \"00000000-0000-0005-0000-000000000011\"\n"
" #uuid \"00000000-0000-000a-0000-000000000000\")\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:147
#, no-wrap
msgid ""
"user> (sort [:ns2/kw1 :ns2/kw2 :ns1/kw2 :kw2 nil])\n"
"(nil :kw2 :ns1/kw2 :ns2/kw1 :ns2/kw2)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:155
msgid ""
"An exception will be thrown if you call `compare` with different types.  Any "
"numeric types above can be compared to each other, but not to a non-numeric "
"type.  An exception will also be thrown if you use `compare` on a list, set, "
"map, or any other type not mentioned above.  You must implement your own "
"comparator if you wish to sort such values."
msgstr ""

#. type: Title ==
#: en/content/guides/comparators.adoc:156
#, no-wrap
msgid "Off-the-shelf comparators"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:159
msgid ""
"First consider using well-tested comparators developed by others, especially "
"if they are complex."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:164
msgid ""
"A perfect example of this would be sorting Unicode strings in different "
"languages in orders specific to different locales. The Java https://docs."
"oracle.com/javase/8/docs/api/java/text/Collator.html[Collator] class and "
"http://site.icu-project.org/home#TOC-What-is-ICU-[ICU] (International "
"Components for Unicode) provide libraries for this."
msgstr ""

#. type: Title ==
#: en/content/guides/comparators.adoc:165
#, no-wrap
msgid "Writing your own comparators"
msgstr ""

#. type: Title ===
#: en/content/guides/comparators.adoc:167
#, no-wrap
msgid "Reverse order"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:171
msgid ""
"To sort numbers in decreasing order, simply write a comparator that calls "
"`compare` with the arguments in the opposite order:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:176
#, no-wrap
msgid ""
"user> (sort [4 2 3 1])\n"
"(1 2 3 4)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:180
#, no-wrap
msgid ""
"user> (defn reverse-cmp [a b]\n"
"        (compare b a))\n"
"#'user/reverse-cmp\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:183
#, no-wrap
msgid ""
"user> (sort reverse-cmp [4 3 2 1])\n"
"(4 3 2 1)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:187
msgid ""
"Such short functions are often written using Clojure's #() notation, where "
"the two arguments are %1 and %2, in that order."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:191
#, no-wrap
msgid "user> (sort #(compare %2 %1) [4 3 2 1])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:194
msgid "`reverse-cmp` will also work for all other types `compare` works for."
msgstr ""

#. type: Title ===
#: en/content/guides/comparators.adoc:195
#, no-wrap
msgid "Multi-field comparators"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:200
msgid ""
"Because equal-length Clojure vectors are compared lexicographically, they "
"can be used to do multi-field sorting on values like maps or records. This "
"only works if the fields are already sorted by `compare` in the order you "
"wish (or the reverse of that)."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:202
msgid "First we will show a way to do it that does not compare vectors."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:210
#, no-wrap
msgid ""
"(def john1 {:name \"John\", :salary 35000.00, :company \"Acme\"})\n"
"(def mary  {:name \"Mary\", :salary 35000.00, :company \"Mars Inc\"})\n"
"(def john2 {:name \"John\", :salary 40000.00, :company \"Venus Co\"})\n"
"(def john3 {:name \"John\", :salary 30000.00, :company \"Asteroids-R-Us\"})\n"
"(def people [john1 mary john2 john3])\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:223
#, no-wrap
msgid ""
"(defn by-salary-name-co [x y]\n"
"  ;; :salary values sorted in decreasing order because x and y\n"
"  ;; swapped in this compare.\n"
"  (let [c (compare (:salary y) (:salary x))]\n"
"    (if (not= c 0)\n"
"      c\n"
"      ;; :name and :company are sorted in increasing order\n"
"      (let [c (compare (:name x) (:name y))]\n"
"        (if (not= c 0)\n"
"          c\n"
"          (let [c (compare (:company x) (:company y))]\n"
"            c))))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:229
#, no-wrap
msgid ""
"user> (pprint (sort by-salary-name-co people))\n"
"({:name \"John\", :salary 40000.0, :company \"Venus Co\"}\n"
" {:name \"John\", :salary 35000.0, :company \"Acme\"}\n"
" {:name \"Mary\", :salary 35000.0, :company \"Mars Inc\"}\n"
" {:name \"John\", :salary 30000.0, :company \"Asteroids-R-Us\"})\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:233
msgid ""
"Below is the shorter way, by comparing Clojure vectors. It behaves exactly "
"the same as above. Note that as above, the field :salary is sorted in "
"descending order because _x_ and _y_ are swapped."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:239
#, no-wrap
msgid ""
"(defn by-salary-name-co2 [x y]\n"
"    (compare [(:salary y) (:name x) (:company x)]\n"
"             [(:salary x) (:name y) (:company y)]))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:245
#, no-wrap
msgid ""
"user> (pprint (sort by-salary-name-co2 people))\n"
"({:name \"John\", :salary 40000.0, :company \"Venus Co\"}\n"
" {:name \"John\", :salary 35000.0, :company \"Acme\"}\n"
" {:name \"Mary\", :salary 35000.0, :company \"Mars Inc\"}\n"
" {:name \"John\", :salary 30000.0, :company \"Asteroids-R-Us\"})\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:251
msgid ""
"The above is fine for key values that are inexpensive to compute from the "
"values being sorted.  If the key values are expensive to compute, it is "
"better to calculate them once for each value.  See the \"decorate-sort-"
"undecorate\" technique described in the documentation for https://github.com/"
"jafingerhut/thalia/blob/master/doc/project-docs/clojure.core-1.5.1/clojure."
"core/sort-by.md[sort-by]."
msgstr ""

#. type: Title ===
#: en/content/guides/comparators.adoc:252
#, no-wrap
msgid "Boolean comparators"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:256
msgid ""
"Java comparators are all 3-way, meaning they return a negative, 0, or "
"positive integer depending upon whether the first argument should be "
"considered less than, equal to, or greater than the second argument."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:263
msgid ""
"In Clojure, you may also use boolean comparators that return `true` if the "
"first argument should come before the second argument, or `false` otherwise "
"(i.e. should come after, or it is equal).  The function `<` is a perfect "
"example, as long as you only need to compare numbers. `>` works for sorting "
"numbers in decreasing order.  Behind the scenes, when such a Clojure "
"function `bool-cmp-fn` is \"called as a comparator\", Clojure runs code that "
"works like this to return an _int_ instead:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:271
#, no-wrap
msgid ""
"(if (bool-cmp-fn x y)\n"
"  -1     ; x < y\n"
"  (if (bool-cmp-fn y x)  ; note the reversed argument order\n"
"    1    ; x > y\n"
"    0))  ; x = y\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:276
msgid ""
"You can see this by calling the compare method of any Clojure function.  "
"Below is an example with a custom version `my-<` of `<` that prints its "
"arguments when it is called, so you can see the cases where it is called "
"more than once:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:283
#, no-wrap
msgid ""
"user> (defn my-< [a b]\n"
"        (println \"(my-<\" a b \") returns \" (< a b))\n"
"        (< a b))\n"
"#'user/my-<\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:298
#, no-wrap
msgid ""
";; (. o (compare a b)) calls the method named compare for object\n"
";; o, with arguments a and b.  In this case the object is the\n"
";; Clojure function my-<\n"
"user> (. my-< (compare 1 2))\n"
"(my-< 1 2 ) returns  true\n"
"-1\n"
"user> (. my-< (compare 2 1))\n"
"(my-< 2 1 ) returns  false\n"
"(my-< 1 2 ) returns  true\n"
"1\n"
"user> (. my-< (compare 1 1))\n"
"(my-< 1 1 ) returns  false\n"
"(my-< 1 1 ) returns  false\n"
"0\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:304
#, no-wrap
msgid ""
";; Calling a Clojure function in the normal way uses its invoke\n"
";; method, not compare.\n"
"user> (. my-< (invoke 2 1))\n"
"(my-< 2 1 ) returns  false\n"
"false\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:310
msgid ""
"See Clojure source file https://github.com/clojure/clojure/blob/"
"clojure-1.10.0/src/jvm/clojure/lang/AFunction.java#L50[src/jvm/clojure/lang/"
"AFunction.java] method `compare` if you want all the details."
msgstr ""

#. type: Title ===
#: en/content/guides/comparators.adoc:311
#, no-wrap
msgid "General rules for comparators"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:316
msgid ""
"Any comparator, whether 3-way or boolean, should return answers consistent "
"with a https://en.wikipedia.org/wiki/Total_order[total order] on the values "
"you want to compare."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:320
msgid ""
"A total order is simply an ordering of all values from smallest to largest, "
"where some groups of values can all be equal to each other. Every pair of "
"values must be comparable to each other (i.e. no \"I do not know how to "
"compare them\" answers from the comparator)."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:325
msgid ""
"For example, you can order all fractions written in the form _m/n_ for "
"integers m and n from smallest to largest, in the usual way this is done in "
"mathematics. Many of the fractions would be equal to each other, e.g. _1/2 = "
"2/4 = 3/6_. A comparator implementing that total order should behave as if "
"they are all the same."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:328
msgid ""
"A 3-way comparator `(cmp a b)` should return a negative, positive, or 0 "
"_int_ if _a_ is before, after, or is considered equal to b in the total "
"order, respectively."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:333
msgid ""
"A boolean comparator `(cmp a b)` should return true if _a_ is before _b_ in "
"the total order, or false if _a_ is after or considered equal to _b_. That "
"is, it should work like `<` does for numbers.  As explained later, it should "
"not behave like `\\<=` for numbers (see section \"Comparators for sorted "
"sets and maps are easy to get wrong\")."
msgstr ""

#. type: Title ==
#: en/content/guides/comparators.adoc:334
#, no-wrap
msgid "Mistakes to avoid"
msgstr ""

#. type: Title ===
#: en/content/guides/comparators.adoc:336
#, no-wrap
msgid "Be wary of \"Not a Number\" values as compared values in sorted collections"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:343
msgid ""
"Clojure's default comparator `compare` treats \"Not a Number\" (`pass:"
"[##NaN]`) values as equal to all other numbers.  If you call https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/sort[sort] on sequences "
"of numbers that contain occurrences of `pass:[##NaN]`, it might throw an "
"exception."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:349
#, no-wrap
msgid ""
"user> (sort [##NaN 5 13 ##NaN 3 7 12 ##NaN 8 4 2 20 6 9 ##NaN 50 83 19 -7 0 18 26 30 42 ##NaN 57 90 -8 -12 43 87 38])\n"
"Execution error (IllegalArgumentException) at java.util.TimSort/mergeHi (TimSort.java:899).\n"
"Comparison method violates its general contract!\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:355
msgid ""
"Even if it does not throw an exception, it is likely that the returned "
"sequence will not be sorted.  This is because `compare` does not put `pass:"
"[##NaN]` into a total order with other numbers as a comparator should, in "
"order for `sort` to work correctly:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:360
#, no-wrap
msgid ""
"user> (sort [##NaN 10 5 13 ##NaN 3 7 12 ##NaN 8 4 2 20 6 9 ##NaN 50 83 19 -7])\n"
"(##NaN -7 2 3 4 5 6 7 8 10 12 13 ##NaN ##NaN 9 19 20 ##NaN 50 83)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:364
msgid ""
"Because `pass:[##NaN]` is not equal to any other value, you cannot use code "
"like this to remove values from a sequence of numbers:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:369
#, no-wrap
msgid ""
"user> (remove #(= % ##NaN) [9 3 ##NaN 4])\n"
"(9 3 ##NaN 4)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:373
msgid ""
"You may use the Java method `Double/isNaN` to indicate whether a value is "
"`pass:[##NaN]`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:378
#, no-wrap
msgid ""
"user> (remove #(Double/isNaN %) [9 3 ##NaN 4])\n"
"(9 3 4)\n"
msgstr ""

#. type: Title ===
#: en/content/guides/comparators.adoc:381
#, no-wrap
msgid "Comparators for sorted sets and maps are easy to get wrong"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:387
msgid ""
"This is just as accurately stated as \"comparators are easy to get wrong\", "
"but it is often more noticeable when you use a bad comparator for sorted "
"sets and maps. If you write the kinds of bad comparators in this section and "
"use them to call `sort`, usually little or nothing will go wrong (although "
"inconsistent comparators are not good for sorting, either). With sorted sets "
"and maps, these bad comparators can cause values not to be added to your "
"sorted collections, or to be added but not be found when you search for them."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:391
msgid ""
"Suppose you want a sorted set containing vectors of two elements, where each "
"is a string followed by a number, e.g. `[\"a\" 5]`. You want the set sorted "
"by the number, and to allow multiple vectors with the same number but "
"different strings. Your first try might be to write something like `by-2nd`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:396
#, no-wrap
msgid ""
"(defn by-2nd [a b]\n"
"  (compare (second a) (second b)))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:399
msgid ""
"But look what happens when you try to add multiple vectors with the same "
"number."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:404
#, no-wrap
msgid ""
"user> (sorted-set-by by-2nd [\"a\" 1] [\"b\" 1] [\"c\" 1])\n"
"#{[\"a\" 1]}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:408
msgid ""
"Only one element is in the set, because `by-2nd` treats all three of the "
"vectors as equal. Sets should not contain duplicate elements, so the other "
"elements are not added."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:410
msgid ""
"A common thought in such a case is to use a boolean comparator function "
"based on `\\<=` instead of `<`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:415
#, no-wrap
msgid ""
"(defn by-2nd-<= [a b]\n"
"  (<= (second a) (second b)))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:419
msgid ""
"The boolean comparator `by-2nd-\\<=` seems to work correctly on the first "
"step of creating the set, but fails when testing whether elements are in the "
"set."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:432
#, no-wrap
msgid ""
"user> (def sset (sorted-set-by by-2nd-<= [\"a\" 1] [\"b\" 1] [\"c\" 1]))\n"
"#'user/sset\n"
"user> sset\n"
"#{[\"c\" 1] [\"b\" 1] [\"a\" 1]}\n"
"user> (sset [\"c\" 1])\n"
"nil\n"
"user> (sset [\"b\" 1])\n"
"nil\n"
"user> (sset [\"a\" 1])\n"
"nil\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:439
msgid ""
"The problem here is that `by-2nd-\\<=` gives inconsistent answers. If you "
"ask it whether `[\"c\" 1]` comes before `[\"b\" 1]`, it returns true (which "
"Clojure's boolean-to-int comparator conversion turns into -1).  If you ask "
"it whether `[\"b\" 1]` comes before `[\"c\" 1]`, again it returns true "
"(again converted into -1 by Clojure).  One cannot reasonably expect an "
"implementation of a sorted data structure to provide any kind of guarantees "
"on its behavior if you give it an inconsistent comparator."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:443
msgid ""
"The techniques described in \"Multi-field comparators\" above provide "
"correct comparators for this example.  In general, be wary of comparing only "
"parts of values to each other. Consider having some kind of tie-breaking "
"condition after all of the fields of interest to you have been compared."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:447
msgid ""
"Aside: If you do not want multiple vectors in your set with the same number, "
"`by-2nd` is the comparator you should use.  It gives exactly the behavior "
"you want. (TBD: Are there any caveats here? Will `sorted-set` ever use `=` "
"to compare elements for any reason, or only the supplied comparator "
"function?)"
msgstr ""

#. type: Title ===
#: en/content/guides/comparators.adoc:448
#, no-wrap
msgid "Beware using subtraction in a comparator"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:452
msgid ""
"Java comparators return a negative int value if the first argument is to be "
"treated as less than the second, a positive int value if the first argument "
"is to be treated as greater than the second, and 0 if they are equal."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:461
#, no-wrap
msgid ""
"user> (compare 10 20)\n"
"-1\n"
"user> (compare 20 10)\n"
"1\n"
"user> (compare 20 20)\n"
"0\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:464
msgid ""
"Because of this, you might be tempted to write a comparator by subtracting "
"one numeric value from another, like so."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:469
#, no-wrap
msgid ""
"user> (sort #(- %1 %2) [4 2 3 1])\n"
"(1 2 3 4)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:473
msgid ""
"While this works in many cases, think twice (or three times) before using "
"this technique.  It is less error-prone to use explicit conditional checks "
"and return -1, 0, or 1, or to use boolean comparators."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:480
msgid ""
"Why? Java comparators must return a 32-bit _int_ type, so when a Clojure "
"function is used as a comparator and it returns any type of number, that "
"number is converted to an _int_ behind the scenes using the Java method "
"https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html#intValue--"
"[intValue].  See Clojure source file https://github.com/clojure/clojure/blob/"
"clojure-1.10.0/src/jvm/clojure/lang/AFunction.java#L50[src/jvm/clojure/lang/"
"AFunction.java] method `compare` if you want the details."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:483
msgid ""
"For comparing floating point numbers and ratios, this causes numbers "
"differing by less than 1 to be treated as equal, because a return value "
"between -1 and 1 is truncated to the _int_ 0:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:489
#, no-wrap
msgid ""
";; This gives the correct answer\n"
"user> (sort #(- %1 %2) [10.0 9.0 8.0 7.0])\n"
"(7.0 8.0 9.0 10.0)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:494
#, no-wrap
msgid ""
";; but this does not, because all values are treated as equal by\n"
";; the bad comparator.\n"
"user> (sort #(- %1 %2) [1.0 0.9 0.8 0.7])\n"
"(1.0 0.9 0.8 0.7)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:498
#, no-wrap
msgid ""
";; .intValue converts all values between -1.0 and 1.0 to 0\n"
"user> (map #(.intValue %) [-1.0 -0.99 -0.1 0.1 0.99 1.0])\n"
"(-1 0 0 0 0 1)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:503
msgid ""
"This also leads to bugs when comparing integer values that differ by amounts "
"that change sign when you truncate it to a 32-bit _int_ (by discarding all "
"but its least significant 32 bits).  About half of all pairs of long values "
"are compared incorrectly by using subtraction as a comparator."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:509
#, no-wrap
msgid ""
";; This looks good\n"
"user> (sort #(- %1 %2) [4 2 3 1])\n"
"(1 2 3 4)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:513
#, no-wrap
msgid ""
";; What the heck?\n"
"user> (sort #(- %1 %2) [2147483650 2147483651 2147483652 4 2 3 1])\n"
"(3 4 2147483650 2147483651 2147483652 1 2)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:516
#, no-wrap
msgid ""
"user> [Integer/MIN_VALUE Integer/MAX_VALUE]\n"
"[-2147483648 2147483647]\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:522
#, no-wrap
msgid ""
";; How .intValue truncates a few selected values.  Note especially\n"
";; the first and last ones.\n"
"user> (map #(.intValue %) [-2147483649 -2147483648 -1 0 1\n"
"                            2147483647  2147483648])\n"
"(2147483647 -2147483648 -1 0 1 2147483647 -2147483648)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:528
msgid ""
"Java itself uses a subtraction comparator for strings and characters, among "
"others.  This does not cause any problems, because the result of subtracting "
"an arbitrary pair of 16-bit characters converted to ints is guaranteed to "
"fit within an _int_ without wrapping around.  If your comparator is not "
"guaranteed to be given such restricted inputs, better not to risk it."
msgstr ""

#. type: Title ==
#: en/content/guides/comparators.adoc:529
#, no-wrap
msgid "Comparators that work between different types"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:534
msgid ""
"Sometimes you might wish to sort a collection of values by some key, but "
"that key is not unique.  You want the values with the same key to be sorted "
"in some predictable, repeatable order, but you do not care much what that "
"order is."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:540
msgid ""
"As a toy example, you might have a collection of vectors, each with two "
"elements, where the first element is always a string and the second is "
"always a number.  You want to sort them by the number value in increasing "
"order, but you know your data can contain more than one vector with the same "
"number. You want to break ties in some way, consistently across multiple "
"sorts."
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:542
msgid ""
"This case is easily implemented using a multi-field comparator as described "
"in an earlier section."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:548
#, no-wrap
msgid ""
"(defn by-number-then-string [[a-str a-num] [b-str b-num]]\n"
"  (compare [a-num a-str]\n"
"           [b-num b-str]))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:553
msgid ""
"If the entire vector values can be compared with `compare`, because all "
"vectors are equal length, and the type of each corresponding elements can be "
"compared to each other with `compare`, then you can also do this, using the "
"entire vector values as the final tie-breaker:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:559
#, no-wrap
msgid ""
"(defn by-number-then-whatever [a-vec b-vec]\n"
"  (compare [(second a-vec) a-vec]\n"
"           [(second b-vec) b-vec]))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:563
msgid ""
"However, that will throw an exception if some element position in the "
"vectors contain types too different for `compare` to work on, and those "
"vectors have the same second element:"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:571
#, no-wrap
msgid ""
";; compare throws exception if you try to compare a string and a\n"
";; keyword\n"
"user> (sort by-number-then-whatever [[\"a\" 2] [\"c\" 3] [:b 2]])\n"
"Execution error (ClassCastException) at user/by-number-then-whatever (REPL:2).\n"
"class java.lang.String cannot be cast to class clojure.lang.Keyword\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:576
msgid ""
"`cc-cmp` (\"cross class compare\") below may be useful in such cases.  It "
"can compare values of different types, which it orders based on a string "
"that represents the type of the value.  It is not simply `(class x)`, "
"because then numbers like `Integer` and `Long` would not be sorted in "
"numeric order."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:581
#, no-wrap
msgid ""
";; comparison-class throws exceptions for some types that might be\n"
";; useful to include.\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:587
#, no-wrap
msgid ""
"(defn comparison-class [x]\n"
"  (cond (nil? x) \"\"\n"
"        ;; Lump all numbers together since Clojure's compare can\n"
"        ;; compare them all to each other sensibly.\n"
"        (number? x) \"java.lang.Number\"\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:596
#, no-wrap
msgid ""
"        ;; sequential? includes lists, conses, vectors, and seqs of\n"
"        ;; just about any collection, although it is recommended not\n"
"        ;; to use this to compare seqs of unordered collections like\n"
"        ;; sets or maps (vectors should be OK).  This should be\n"
"        ;; everything we would want to compare using cmp-seq-lexi\n"
"        ;; below.  TBD: Does it leave anything out?  Include anything\n"
"        ;; it should not?\n"
"        (sequential? x) \"clojure.lang.Sequential\"\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:600
#, no-wrap
msgid ""
"        (set? x) \"clojure.lang.IPersistentSet\"\n"
"        (map? x) \"clojure.lang.IPersistentMap\"\n"
"        (.isArray (class x)) \"java.util.Arrays\"\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:608
#, no-wrap
msgid ""
"        ;; Comparable includes Boolean, Character, String, Clojure\n"
"        ;; refs, and many others.\n"
"        (instance? Comparable x) (.getName (class x))\n"
"        :else (throw\n"
"               (ex-info (format \"cc-cmp does not implement comparison of values with class %s\"\n"
"                                (.getName (class x)))\n"
"                        {:value x}))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:626
#, no-wrap
msgid ""
"(defn cmp-seq-lexi\n"
"  [cmpf x y]\n"
"  (loop [x x\n"
"         y y]\n"
"    (if (seq x)\n"
"      (if (seq y)\n"
"        (let [c (cmpf (first x) (first y))]\n"
"          (if (zero? c)\n"
"            (recur (rest x) (rest y))\n"
"            c))\n"
"        ;; else we reached end of y first, so x > y\n"
"        1)\n"
"      (if (seq y)\n"
"        ;; we reached end of x first, so x < y\n"
"        -1\n"
"        ;; Sequences contain same elements.  x = y\n"
"        0))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:644
#, no-wrap
msgid ""
";; The same result can be obtained by calling cmp-seq-lexi on two\n"
";; vectors, but cmp-vec-lexi should allocate less memory comparing\n"
";; vectors.\n"
"(defn cmp-vec-lexi\n"
"  [cmpf x y]\n"
"  (let [x-len (count x)\n"
"        y-len (count y)\n"
"        len (min x-len y-len)]\n"
"    (loop [i 0]\n"
"      (if (== i len)\n"
"        ;; If all elements 0..(len-1) are same, shorter vector comes\n"
"        ;; first.\n"
"        (compare x-len y-len)\n"
"        (let [c (cmpf (x i) (y i))]\n"
"          (if (zero? c)\n"
"            (recur (inc i))\n"
"            c))))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:659
#, no-wrap
msgid ""
"(defn cmp-array-lexi\n"
"  [cmpf x y]\n"
"  (let [x-len (alength x)\n"
"        y-len (alength y)\n"
"        len (min x-len y-len)]\n"
"    (loop [i 0]\n"
"      (if (== i len)\n"
"        ;; If all elements 0..(len-1) are same, shorter array comes\n"
"        ;; first.\n"
"        (compare x-len y-len)\n"
"        (let [c (cmpf (aget x i) (aget y i))]\n"
"          (if (zero? c)\n"
"            (recur (inc i))\n"
"            c))))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:667
#, no-wrap
msgid ""
"(defn cc-cmp\n"
"  [x y]\n"
"  (let [x-cls (comparison-class x)\n"
"        y-cls (comparison-class y)\n"
"        c (compare x-cls y-cls)]\n"
"    (cond (not= c 0) c  ; different classes\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:672
#, no-wrap
msgid ""
"          ;; Compare sets to each other as sequences, with elements in\n"
"          ;; sorted order.\n"
"          (= x-cls \"clojure.lang.IPersistentSet\")\n"
"          (cmp-seq-lexi cc-cmp (sort cc-cmp x) (sort cc-cmp y))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:679
#, no-wrap
msgid ""
"          ;; Compare maps to each other as sequences of [key val]\n"
"          ;; pairs, with pairs in order sorted by key.\n"
"          (= x-cls \"clojure.lang.IPersistentMap\")\n"
"          (cmp-seq-lexi cc-cmp\n"
"                        (sort-by key cc-cmp (seq x))\n"
"                        (sort-by key cc-cmp (seq y)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:682
#, no-wrap
msgid ""
"          (= x-cls \"java.util.Arrays\")\n"
"          (cmp-array-lexi cc-cmp x y)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:690
#, no-wrap
msgid ""
"          ;; Make a special check for two vectors, since cmp-vec-lexi\n"
"          ;; should allocate less memory comparing them than\n"
"          ;; cmp-seq-lexi.  Both here and for comparing sequences, we\n"
"          ;; must use cc-cmp recursively on the elements, because if\n"
"          ;; we used compare we would lose the ability to compare\n"
"          ;; elements with different types.\n"
"          (and (vector? x) (vector? y)) (cmp-vec-lexi cc-cmp x y)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:695
#, no-wrap
msgid ""
"          ;; This will compare any two sequences, if they are not both\n"
"          ;; vectors, e.g. a vector and a list will be compared here.\n"
"          (= x-cls \"clojure.lang.Sequential\")\n"
"          (cmp-seq-lexi cc-cmp x y)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:697
#, no-wrap
msgid "          :else (compare x y))))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/comparators.adoc:700
msgid ""
"Here is a quick example demonstrating `cc-cmp`'s ability to compare values "
"of different types."
msgstr ""

#. type: delimited block -
#: en/content/guides/comparators.adoc:729
#, no-wrap
msgid ""
"user> (pprint (sort cc-cmp [true false nil Double/MAX_VALUE 10\n"
"                            Integer/MIN_VALUE :a \"b\" 'c (ref 5)\n"
"                            [5 4 3] '(5 4) (seq [5]) (cons 6 '(1))\n"
"                            #{1 2 3} #{2 1}\n"
"                            {:a 1, :b 2} {:a 1, :b -2}\n"
"                            (object-array [1 2 3 4])]))\n"
"(nil\n"
" {:a 1, :b -2}\n"
" {:a 1, :b 2}\n"
" #{1 2}\n"
" #{1 2 3}\n"
" :a\n"
" #<Ref@1493d9b3: 5>\n"
" (5)\n"
" (5 4)\n"
" [5 4 3]\n"
" (6 1)\n"
" c\n"
" false\n"
" true\n"
" -2147483648\n"
" 10\n"
" 1.7976931348623157E308\n"
" \"b\"\n"
" [1, 2, 3, 4])\n"
"nil\n"
msgstr ""
