# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2017-06-01 09:26+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: en/content/guides/core_async_go.adoc:1
#, no-wrap
msgid "Go Block Best Practices"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:4
msgid "Timothy Baldridge 2017-05-24"
msgstr ""

#. type: Title ==
#: en/content/guides/core_async_go.adoc:10
#, no-wrap
msgid "General advice"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:14
msgid ""
"It's very tempting to do the following to send a message without waiting for "
"a reply:"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:17
#, no-wrap
msgid "(go (>! c 42))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:20
msgid ""
"Although go blocks are cheap, they aren't completely free. Thus it's "
"recommended to use"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:23
#, no-wrap
msgid "(async/put! c 42)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:26
msgid ""
"`go` just ends up calling `put!` eventually anyway, so there really isn't a "
"downside."
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:30
msgid ""
"Also, if the code is being called inside a callback and you want to respect "
"back-pressure, it's fairly easy to use a recursive function along with `put!"
"` to respect back-pressure."
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:35
#, no-wrap
msgid ""
"(defn http-call \n"
"  \"Makes an async call to a web browser\"\n"
"  [url callback] ...)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:38
#, no-wrap
msgid "(def urls [url1 url2 url3])\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:47
#, no-wrap
msgid ""
"(defn load-urls \n"
"  \"Spools the results of loading several urls onto a channel. \n"
"   does this without creating temporary channels or go blocks\"\n"
"  [urls out-c]\n"
"  (http-call \n"
"    (first urls)\n"
"    (fn [response]\n"
"      (put! out-c response (fn [_] (load-urls (next urls) out-c))))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:49
#, no-wrap
msgid "(load-urls urls)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:54
msgid ""
"In this example we have some nice clean interop code that allows us to start "
"working with channels in our app, without creating tons of channels or gos "
"only to dispose of them shortly after they're created."
msgstr ""

#. type: Title ==
#: en/content/guides/core_async_go.adoc:55
#, no-wrap
msgid "Unsupported constructs and other limitations in go blocks"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:60
msgid ""
"The go macro stops translating at function creation boundaries. This means "
"the following code will fail to compile, or may just throw a runtime error "
"stating that `<!` was used outside of a go block:"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:63
#, no-wrap
msgid "(go (let [my-fn (fn [] (<! c))] (my-fn)))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:68
msgid ""
"This is one thing to remember since many Clojure constructs create functions "
"inside macros. The following are examples of code that will not work as one "
"would expect:"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:73
#, no-wrap
msgid ""
"(go (map <! some-chan))\n"
"(go (for [x xs]\n"
"      (<! x)))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:77
msgid ""
"However, other Clojure constructs, such as `doseq` do not allocate closures "
"internally:"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:82
#, no-wrap
msgid ""
"; This works just fine\n"
"(go (doseq [c cs]\n"
"      (println (<! c)))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:87
msgid ""
"Unfortunately, currently there isn't a good way to know if a given macro "
"will work as expected inside a go block unless one either looks at the "
"source, or tests the code generated by the macro."
msgstr ""

#. type: Title ==
#: en/content/guides/core_async_go.adoc:88
#, no-wrap
msgid "Why is this?"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:93
msgid ""
"The best explanation for \"why does go block translation stop at function "
"creation?\" basically comes down to a question of types. Examine the "
"following snippet:"
msgstr ""

#. type: delimited block -
#: en/content/guides/core_async_go.adoc:96
#, no-wrap
msgid "(map str [1 2 3])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:106
msgid ""
"We can easily see that this produces a `seq` of strings since the output "
"type of `str` is a string. So what is the return type of `async/<!`? In the "
"context of a go block it is an object taken from a channel. But the go block "
"has to translate that to a parking call to `async/put!`. The return type of "
"`async/<!` should really be thought of as something akin to `Async<Object>` "
"or `Promise<Object>`. Thus the result of `(map async/<! chans)` is something "
"like \"a seq of pending channel operations\" which makes no sense at all."
msgstr ""

#. type: Plain text
#: en/content/guides/core_async_go.adoc:114
msgid ""
"In short, the go macro can't do these operations without some serious work. "
"Other languages such as https://github.com/trifork/erjang[Erjang], allow for "
"such constructs via translating all code in the entire JVM. This is "
"something we'd like to avoid in core.async, as it complicates things and "
"causes the logic of one library to infect the code of an entire JVM. So "
"we're left with the practical compromise, translation stops when it sees a "
"`(fn [] ...)`."
msgstr ""
