# Japanese translations for clojure-site-ja package
# Copyright (C) 2016 Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# Automatically generated, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2019-06-12 00:05+0900\n"
"PO-Revision-Date: 2019-06-15 19:19+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: en/content/reference/transducers.adoc:39 en/content/reference/reader.adoc:179
msgid "For example:"
msgstr "例:"

#. type: Title =
#: en/content/reference/reader.adoc:1
#, no-wrap
msgid "The Reader"
msgstr "リーダー(reader)"

#. type: Plain text
#: en/content/reference/reader.adoc:4 en/content/community/resources.adoc:4 en/content/community/books.adoc:4
msgid "Rich Hickey 2016-02-15"
msgstr "Rich Hickey 2016-02-15"

#. type: Plain text
#: en/content/reference/reader.adoc:15
msgid ""
"Clojure is a http://en.wikipedia.org/wiki/Homoiconicity[homoiconic] language, which is a fancy term describing the "
"fact that Clojure programs are represented by Clojure data structures. This is a very important difference between "
"Clojure (and Common Lisp) and most other programming languages - Clojure is defined in terms of the evaluation of "
"data structures and *not* in terms of the syntax of character streams/files. It is quite common, and easy, for "
"Clojure programs to manipulate, transform and produce other Clojure programs."
msgstr ""
"Clojureには http://en.wikipedia.org/wiki/Homoiconicity[同図像性] という特性がある。同図像性というのはClojureのプログラ"
"ムはClojureのデータ構造で表現されることを高尚に説明する言葉だ。これはClojure(およびCommon Lisp)とその他のプログラミン"
"グ言語との間の重要な差だ。- Clojureはストリームやファイルの中の文法 *ではなく* 、データ構造の評価で定義される。Clojure"
"プログラムが他のClojureプログラムを操作や変形、あるいは創り出すということはとても一般的で、簡単に行うことができる。"

#. type: Plain text
#: en/content/reference/reader.adoc:17
msgid ""
"That said, most Clojure programs begin life as text files, and it is the task of the _reader_ to parse the text and "
"produce the data structure the compiler will see. This is not merely a phase of the compiler. The reader, and the "
"Clojure data representations, have utility on their own in many of the same contexts one might use XML or JSON etc."
msgstr ""
"とはいうものの、ほとんどのClojureプログラムはテキストファイルとして作成される。このテキストをパースし、コンパイラが解"
"釈できるデータ構造を生成するのがreaderの役割だ。 _reader_ とClojureのデータの表現はXMLやJSONなどを使うような文脈でも使"
"用できる。"

#. type: Plain text
#: en/content/reference/reader.adoc:19
msgid ""
"One might say the reader has syntax defined in terms of characters, and the Clojure language has syntax defined in "
"terms of symbols, lists, vectors, maps etc. The reader is represented by the function https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/read[read], which reads the next form (not character) from a stream, and "
"returns the object represented by that form."
msgstr ""
"readerの文法は文字で定義されており、Clojureの言語はシンボル、リスト、ベクター、マップなどによって定義されていると言う"
"人もいるかもしれない。実際にはreaderはフォームを(文字ではなく)ストリームから読み込み、そのフォームによって表現されるオ"
"ブジェクトを返す https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read[read] 関数によって表現され"
"ている。"

#. type: Plain text
#: en/content/reference/reader.adoc:21
msgid ""
"Since we have to start somewhere, this reference starts where evaluation starts, with the reader forms. This will "
"inevitably entail talking about data structures whose descriptive details, and interpretation by the compiler, will "
"follow."
msgstr ""
"どこかしらから解説を始める必要があるので、このリファレンスでは評価の最初の段階にあたるリーダーフォームの解説から始めて"
"いる。これには必然的にデータ構造の詳細な解説とコンパイラによる解釈が付随する。"

#. type: Title ==
#: en/content/reference/reader.adoc:22
#, no-wrap
msgid "Reader forms"
msgstr "リーダーフォーム(reader form)"

#. type: Title ==
#: en/content/reference/reader.adoc:24 en/content/reference/data_structures.adoc:111
#, no-wrap
msgid "Symbols"
msgstr "シンボル"

#. type: Plain text
#: en/content/reference/reader.adoc:27
msgid ""
"Symbols begin with a non-numeric character and can contain alphanumeric characters and *, +, !, -, _, ', and ? (other "
"characters may be allowed eventually)."
msgstr ""
"シンボルは数字でない文字で始まり、英数字および*、+、!、 -、 _、 '、?を含むことができる(将来他の文字が許容される可能性"
"もある)。"

#. type: Plain text
#: en/content/reference/reader.adoc:28
msgid ""
"'/' has special meaning, it can be used once in the middle of a symbol to separate the namespace from the name, e.g. "
"`my-namespace/foo`. '/' by itself names the division function."
msgstr ""
"'/' には特別な意味があり、シンボルの途中に含むことで名前空間とシンボルの名前を分割することができる(例： 'my-namespace/"
"foo')。'/'単体は除算関数を指す。"

#. type: Plain text
#: en/content/reference/reader.adoc:29
msgid ""
"'.' has special meaning - it can be used one or more times in the middle of a symbol to designate a fully-qualified "
"class name, e.g. `java.util.BitSet`, or in namespace names. Symbols beginning or ending with '.' are reserved by "
"Clojure. Symbols containing / or . are said to be 'qualified'."
msgstr ""
"'.' には特別な意味がある - シンボルの途中に含むことで完全修飾されたクラス名 (例： 'java.util.BitSet')、またはネームス"
"ペースを指定することができる。'.' で開始、または終了するシンボルはClojureに予約されている。/ か . を含むシンボルは「修"
"飾されている」と呼ばれる。"

#. type: Plain text
#: en/content/reference/reader.adoc:30
msgid ""
"Symbols beginning or ending with ':' are reserved by Clojure. A symbol can contain one or more non-repeating ':'s."
msgstr ""
"':' で開始、もしくは終了する文字はClojureによって予約されている。シンボルには一つ、もしくは連続しない':'を含むことがで"
"きる。"

#. type: Title ==
#: en/content/reference/reader.adoc:31 en/content/guides/learn/syntax.adoc:15
#, no-wrap
msgid "Literals"
msgstr "リテラル"

#. type: Plain text
#: en/content/reference/reader.adoc:34
msgid "Strings - Enclosed in \"double quotes\". May span multiple lines. Standard Java escape characters are supported."
msgstr ""
"文字列 - \"ダブルクォート\" で囲まれている。複数行にまたがることもできる。標準のJavaエスケープ文字がサポートされてい"
"る。"

#. type: Plain text
#: en/content/reference/reader.adoc:35
msgid "Numbers - generally represented as per Java"
msgstr "数値 - 一般的に Java と同様に表記される"

#. type: Plain text
#: en/content/reference/reader.adoc:36
msgid ""
"Integers can be indefinitely long and will be read as Longs when in range and clojure.lang.BigInts otherwise. "
"Integers with an N suffix are always read as BigInts. When possible, they can be specified in any base with radix "
"from 2 to 36 (see http://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#parseLong(java.lang.String,%20int)"
"[Long.parseLong()]); for example `2r101010`, `8r52`, `36r16`, and `42` are all the same Long."
msgstr ""
"整数は長さの制限がなく、Longの範囲内にある時はLongとして読み込まれ、それ以外の場合には clojrue.lang.BigIntとして読み込"
"まれる。末尾にNが付いている整数は常にBigIntとして読み込まれる。可能な場合には2から36の基数を指定して表記することができ"
"る(参照: http://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#parseLong(java.lang.String,%20int)[Long."
"parseLong()])。例えば `2r101010`、`8r52`、`36r16`,`42` は全て同じLongになる。"

#. type: Plain text
#: en/content/reference/reader.adoc:37
msgid "Floating point numbers are read as Doubles; with M suffix they are read as BigDecimals."
msgstr "浮動小数点数はDoubleとして読み込まれる。末尾にMが付いているとBigDecimalとして読み込まれる。"

#. type: Plain text
#: en/content/reference/reader.adoc:38
msgid "Ratios are supported, e.g. `22/7`."
msgstr "分数もサポートされている(例: `22/7`)。"

#. type: Plain text
#: en/content/reference/reader.adoc:39
msgid ""
"Characters - preceded by a backslash: `\\c`. `\\newline`, `\\space`, `\\tab`, `\\formfeed`, `\\backspace`, and `"
"\\return` yield the corresponding characters. Unicode characters are represented with `\\uNNNN` as in Java. Octals "
"are represented with `\\oNNN`."
msgstr ""
"文字 - 先頭にバックスラッシュが付いている：`\\c`、 `\\newline`、`\\space`、 `\\tab`、 `\\formfeed`、 `\\backspace`、 `"
"\\return` はそれぞれの文字を意味する。ユニコード文字はJavaと同じく `\\uNNNN` と表記される。8進数は `\\oNNN` と表記され"
"る。"

#. type: Plain text
#: en/content/reference/reader.adoc:40
msgid "`nil` Means 'nothing/no-value'- represents Java null and tests logical false"
msgstr "`nil` は'何もない、もしくは値がない'ことを意味する - Javaのnullを表現し、論理的なテストではfalseになる。"

#. type: Plain text
#: en/content/reference/reader.adoc:41
msgid "Booleans - `true` and `false`"
msgstr "ブーリアン - `true` と `false`"

#. type: Plain text
#: en/content/reference/reader.adoc:42
msgid "Keywords - Keywords are like symbols, except:"
msgstr "キーワード - キーワードはシンボルと似ているが、以下の点で異なる:"

#. type: Plain text
#: en/content/reference/reader.adoc:43
msgid "They can and must begin with a colon, e.g. :fred."
msgstr "コロン(:) で始まらなければならない(例：:fred)。"

#. type: Plain text
#: en/content/reference/reader.adoc:44
msgid "They cannot contain '.' or name classes."
msgstr "'.'を含めたりクラスの名前に使用したりできない。"

#. type: Plain text
#: en/content/reference/reader.adoc:45
msgid "Like symbols, they can contain a namespace, `:person/name`"
msgstr "シンボルと同様に名前空間を含むことができる。 `:person/name`"

#. type: Plain text
#: en/content/reference/reader.adoc:46
msgid "A keyword that begins with two colons is auto-resolved in the current namespace to a qualified keyword:"
msgstr "コロン2つで始まるキーワードは現在の名前空間において修飾されたキーワードに自動的に解決される:"

#. type: Plain text
#: en/content/reference/reader.adoc:47
msgid ""
"If the keyword is unqualified, the namespace will be the current namespace. In `user`, `::rect` is read as `:user/"
"rect`."
msgstr ""
"キーワードが修飾されていない場合、その名前空間は現在の名前空間になる。 `user` では `::rect` は `user/rect` として読み"
"込まれる。"

#. type: Plain text
#: en/content/reference/reader.adoc:48
msgid ""
"If the keyword is qualified, the namespace will be resolved using aliases in the current namespace. In a namespace "
"where `x` is aliased to `example`, `::x/foo` resolves to `:example/foo`."
msgstr ""
"キーワードが修飾されている場合、その名前空間は現在の名前空間でのエイリアスを利用して解決される。 `x` が `example` にエ"
"イリアスされた名前空間では、 `::x/foo` は `:example/foo` に解決される。"

#. type: Title ==
#: en/content/reference/reader.adoc:49 en/content/community/editing.adoc:172
#: en/content/guides/learn/sequential_colls.adoc:102
#, no-wrap
msgid "Lists"
msgstr "リスト"

#. type: Plain text
#: en/content/reference/reader.adoc:52
msgid "Lists are zero or more forms enclosed in parentheses: `(a b c)`"
msgstr "リストは0個以上の丸括弧で括られたフォーム: `(a b c)`"

#. type: Title ==
#: en/content/reference/reader.adoc:53 en/content/guides/learn/sequential_colls.adoc:19
#, no-wrap
msgid "Vectors"
msgstr "ベクター"

#. type: Plain text
#: en/content/reference/reader.adoc:56
msgid "Vectors are zero or more forms enclosed in square brackets: `[1 2 3]`"
msgstr "ベクターは0個以上の角括弧で括られたフォーム: `[1 2 3]`"

#. type: Title ====
#: en/content/reference/reader.adoc:57 en/content/guides/learn/hashed_colls.adoc:82 en/content/about/spec.adoc:198
#, no-wrap
msgid "Maps"
msgstr "マップ"

#. type: Plain text
#: en/content/reference/reader.adoc:60
msgid "Maps are zero or more key/value pairs enclosed in braces: `{:a 1 :b 2}`"
msgstr "マップは波括弧で括られた0個以上のキー/値の対: `{:a 1 :b 1}`"

#. type: Plain text
#: en/content/reference/reader.adoc:61
msgid "Commas are considered whitespace, and can be used to organize the pairs: `{:a 1, :b 2}`"
msgstr "カンマは空白と同様に扱われ、マップの対を区切ることにも使える。`{:a 1, :b 2}` "

#. type: Plain text
#: en/content/reference/reader.adoc:62
msgid "Keys and values can be any forms."
msgstr "キーと値にはどのようなフォームも使用できる。"

#. type: Title ====
#: en/content/reference/reader.adoc:64
#, no-wrap
msgid "Map namespace syntax"
msgstr "名前空間付きマップ記法"

#. type: Plain text
#: en/content/reference/reader.adoc:67
msgid "_Added in Clojure 1.9_"
msgstr "_Clojure 1.9で追加された_"

#. type: Plain text
#: en/content/reference/reader.adoc:69
msgid ""
"Map literals can optionally specify a default namespace context for keys in the map using a `#:ns` prefix, where _ns_ "
"is the name of a namespace and the prefix precedes the opening brace `{` of the map. Additionally, `pass:[#::]` can "
"be used to auto-resolve namespaces with the same semantics as auto-resolved keywords."
msgstr ""
"マップのリテラルには任意でキーに対するデフォルトの名前空間コンテキストを `#:ns` プレフィックスによって指定することが可"
"能で、その場合 _ns_ には名前空間の名前を指定し、プレフィックスはマップの `{` の前に置く。加えて `pass:[#::]` を使用し"
"てキーワードの名前空間の解決と同じセマンティクスで自動的に名前空間を解決することができる。"

#. type: Plain text
#: en/content/reference/reader.adoc:71
msgid "A map literal with namespace syntax is read with the following differences from a map without:"
msgstr "名前空間付きのマップリテラルの文法に対する読み込みは通常のマップに対する読み込みと以下の点が異なる:"

#. type: Plain text
#: en/content/reference/reader.adoc:73
msgid "Keys"
msgstr "キー"

#. type: Plain text
#: en/content/reference/reader.adoc:74
msgid "Keys that are keywords or symbols without a namespace are read with the default namespace."
msgstr "名前空間なしのキーワードもしくはシンボルであるキーはデフォルトの名前空間で読み込まれる。"

#. type: Plain text
#: en/content/reference/reader.adoc:75
msgid ""
"Keys that are keywords or symbols with a namespace are not affected *except* for the special namespace `_`, which is "
"removed during read. This allows for the specification of keywords or symbols without namespaces as keys in a map "
"literal with namespace syntax."
msgstr ""
"名前空間のあるシンボルもしくはキーワードであるキーは影響されずに読み込まれる。 *ただし* 、特別な名前空間 `_` は読み込"
"み時に取り除かれるので扱いが異なる。これを使用することで名前空間シンタックスのあるマップリテラルの中で、名前空間なしの"
"キーワードやシンボルをキーとして指定することが可能になる。"

#. type: Plain text
#: en/content/reference/reader.adoc:76
msgid "Keys that are not symbols or keywords are not affected."
msgstr "キーワードもしくはシンボル以外のキーは影響を受けない。"

#. type: Plain text
#: en/content/reference/reader.adoc:77
msgid "Values"
msgstr "値"

#. type: Plain text
#: en/content/reference/reader.adoc:78
msgid "Values are not affected."
msgstr "値は影響を受けない。"

#. type: Plain text
#: en/content/reference/reader.adoc:79
msgid "Nested map literal keys are not affected."
msgstr "ネストしたマップリテラルのキーは影響を受けない。"

#. type: Plain text
#: en/content/reference/reader.adoc:81 en/content/guides/weird_characters.adoc:474
msgid "For example, the following map literal with namespace syntax:"
msgstr "例として以下の名前空間指定付きの以下のマップ:"

#. type: delimited block -
#: en/content/reference/reader.adoc:88
#, no-wrap
msgid ""
"#:person{:first \"Han\"\n"
"         :last \"Solo\"\n"
"         :ship #:ship{:name \"Millenium Falcon\"\n"
"                      :model \"YT-1300f light freighter\"}}\n"
msgstr ""
"#:person{:first \"Han\"\n"
"         :last \"Solo\"\n"
"         :ship #:ship{:name \"Millenium Falcon\"\n"
"                      :model \"YT-1300f light freighter\"}}\n"

#. type: Plain text
#: en/content/reference/reader.adoc:91 en/content/guides/weird_characters.adoc:482
msgid "is read as:"
msgstr "は以下のように読み込まれる:"

#. type: delimited block -
#: en/content/reference/reader.adoc:98
#, no-wrap
msgid ""
"{:person/first \"Han\"\n"
" :person/last \"Solo\"\n"
" :person/ship {:ship/name \"Millenium Falcon\" \n"
"               :ship/model \"YT-1300f light freighter\"}}\n"
msgstr ""
"{:person/first \"Han\"\n"
" :person/last \"Solo\"\n"
" :person/ship {:ship/name \"Millenium Falcon\" \n"
"               :ship/model \"YT-1300f light freighter\"}}\n"

#. type: Title ==
#: en/content/reference/reader.adoc:100 en/content/reference/data_structures.adoc:235
#: en/content/guides/learn/hashed_colls.adoc:19
#, no-wrap
msgid "Sets"
msgstr "セット"

#. type: Plain text
#: en/content/reference/reader.adoc:103
msgid "Sets are zero or more forms enclosed in braces preceded by `pass:[#]`: `#{:a :b :c}`"
msgstr "セットは0個以上の、先頭に `pass:[#]` を持つ波括弧で括られたフォーム： `#{:a :b :c}`"

#. type: Title ===
#: en/content/reference/reader.adoc:104
#, no-wrap
msgid "deftype, defrecord, and constructor calls (version 1.3 and later):"
msgstr "deftype、defrecord、およびコンストラクタの呼び出し (version 1.3以降):"

#. type: Plain text
#: en/content/reference/reader.adoc:107
msgid ""
"Calls to Java class, deftype, and defrecord constructors can be called using their fully qualified class name "
"preceded by # and followed by a vector: `#my.klass_or_type_or_record[:a :b :c]` +"
msgstr ""
"Javaのクラス、deftype、defrecordのコンストラクタは完全修飾されたクラス名の先頭に#を、末尾にベクターを付けることで呼び"
"出すことができる: `#my.klass_or_type_or_record[:a :b :c]` +"

#. type: Plain text
#: en/content/reference/reader.adoc:108
msgid ""
"The elements in the vector part are passed *unevaluated* to the relevant constructor. defrecord instances can also be "
"created with a similar form that takes a map instead: `#my.record{:a 1, :b 2}` +"
msgstr ""
"ベクターの中の要素は *評価されずに* 各コンストラクタに渡される。defrecordのインスタンスはマップを代わりに受け取る似た"
"ようなフォームを使用して作成することができる: `my.record{:a 1, :b 2}` +"

#. type: Plain text
#: en/content/reference/reader.adoc:109
msgid ""
"The keyed values in the map are assigned *unevaluated* to the relevant fields in the defrecord. Any defrecord fields "
"without corresponding entries in the literal map are assigned nil as their value. Any extra keyed values in the map "
"literal are added to the resulting defrecord instance."
msgstr ""
"キーを付与された値は *評価されずに* defrecordのフィールドに割り当てられる。マップリテラルに対応するエントリーがない"
"defrecordのフィールドにはnilが割り当てられる。defrecordで定義されている以外のキーに対応する値は結果のdefrecordインスタ"
"ンスに追加される。"

#. type: Title ==
#: en/content/reference/reader.adoc:111
#, no-wrap
msgid "Macro characters"
msgstr "マクロ文字"

#. type: Plain text
#: en/content/reference/reader.adoc:114
msgid ""
"The behavior of the reader is driven by a combination of built-in constructs and an extension system called the read "
"table. Entries in the read table provide mappings from certain characters, called macro characters, to specific "
"reading behavior, called reader macros. Unless indicated otherwise, macro characters cannot be used in user symbols."
msgstr ""
"リーダーの挙動はリーダー自身に組み込まれている定義とリードテーブルによる拡張システムの組み合わせで決定される。read "
"tableのエントリーはマクロキャラクターと呼ばれる特定の文字に対応する、リーダーマクロと呼ばれるる読み込みの動作のマッピ"
"ングを定義する。特別な指定がない限り、マクロキャラクターはユーザーシンボルに含めることはできない"

#. type: Title ===
#: en/content/reference/reader.adoc:115
#, no-wrap
msgid "Quote (')"
msgstr "クォート(')"

#. type: Plain text
#: en/content/reference/reader.adoc:118
msgid "`'form` => `(quote form)`"
msgstr "`'form` => `(quote form)`"

#. type: Title ===
#: en/content/reference/reader.adoc:119
#, no-wrap
msgid "Character (\\)"
msgstr "文字 (\\)"

#. type: Plain text
#: en/content/reference/reader.adoc:122
msgid "As per above, yields a character literal. Example character literals are: `\\a \\b \\c`."
msgstr "上記のように文字リテラルを生成する。文字リテラルの例: `\\a \\b \\c`"

#. type: Plain text
#: en/content/reference/reader.adoc:124
msgid ""
"The following special character literals can be used for common characters: `\\newline`, `\\space`, `\\tab`, `"
"\\formfeed`, `\\backspace`, and `\\return`."
msgstr ""
"以下の特殊文字は汎用的に使われる文字として使用できる: `\\newline`, `\\space`, `\\tab`, `\\formfeed`, `\\backspace`, "
"and `\\return`."

#. type: Plain text
#: en/content/reference/reader.adoc:126
msgid ""
"Unicode support follows Java conventions with support corresponding to the underlying Java version. A Unicode literal "
"is of the form `\\uNNNN`, for example `\\u03A9` is the literal for Ω."
msgstr ""
"UnicodeのサポートはJavaの規約に準拠しており、Javaのバージョンに対応するサポートがある。Unicodeのリテラルは `\\uNNNN` "
"の形式となる。例えばΩのリテラルは `\\u03A9` になる。"

#. type: Title ===
#: en/content/reference/reader.adoc:127
#, no-wrap
msgid "Comment (;)"
msgstr "コメント (;)"

#. type: Plain text
#: en/content/reference/reader.adoc:130
msgid "Single-line comment, causes the reader to ignore everything from the semicolon to the end-of-line."
msgstr "単一行コメント。セミコロンから行末までをreaderに無視させる効果がある。"

#. type: Title ===
#: en/content/reference/reader.adoc:131
#, no-wrap
msgid "Deref (@)"
msgstr "Deref (@)"

#. type: Plain text
#: en/content/reference/reader.adoc:134
msgid "`@form => (deref form)`"
msgstr "`@form => (deref form)`"

#. type: Title ===
#: en/content/reference/reader.adoc:135
#, no-wrap
msgid "Metadata (^)"
msgstr "メタデータ (^)"

#. type: Plain text
#: en/content/reference/reader.adoc:139
msgid ""
"Metadata is a map associated with some kinds of objects: Symbols, Lists, Vector, Sets, Maps, tagged literals "
"returning an IMeta, and record, type, and constructor calls. The metadata reader macro first reads the metadata and "
"attaches it to the next form read (see https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-"
"meta[with-meta] to attach meta to an object): + `^{:a 1 :b 2} [1 2 3]` yields the vector `[1 2 3]` with a metadata "
"map of `{:a 1 :b 2}`. +"
msgstr ""
"メタデータは次のようなオブジェクトと関連のあるマップだ：シンボル、リスト、ベクター、マップ、IMetaを返すタグ付きリテラ"
"ル、レコード、タイプ、およびコンストラクタ呼び出し。メタデータのリーダーマクロは最初にメタデータを読み込み、それを次に"
"読み込むフォームに関連付ける。(オブジェクトにメタデータを関連付けるには https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/with-meta[with-meta] を参照):\n"
"`^{:a 1 :b 2} [1 2 3]` は `{:a 1 :b 2}` をメタデータマップにもつ `[1 2 3]` を生成する。 "

#. type: Plain text
#: en/content/reference/reader.adoc:142
msgid ""
"A shorthand version allows the metadata to be a simple symbol or string, in which case it is treated as a single "
"entry map with a key of :tag and a value of the (resolved) symbol or string, e.g.: + `^String x` is the same as `^{:"
"tag java.lang.String} x` +"
msgstr ""
"簡略化したバージョンではメタデータを単純なシンボルもしくは文字列として指定できる。その場合メタデータはキーを:tag,バ"
"リューを(解決後の)シンボルもしくは文字列とした単一エントリーのマップになる。例:\n"
"`^String x` は `^{:tag java.lang.String} x` と同等。"

#. type: Plain text
#: en/content/reference/reader.adoc:144
msgid "Such tags can be used to convey type information to the compiler. +"
msgstr "このようなタグはコンパイラに型情報を渡すことに使用できる。 "

#. type: Plain text
#: en/content/reference/reader.adoc:147
msgid ""
"Another shorthand version allows the metadata to be a keyword, in which case it is treated as a single entry map with "
"a key of the keyword and a value of true, e.g.: + `^:dynamic x` is the same as `^{:dynamic true} x` +"
msgstr ""
"もう一つの簡略した表記ではメタデータにキーワードを使用できる。その場合、メタデータはキーをキーワード、値をtrueとした単"
"一エントリーのマップとして扱われる: `^:dynamic x` は `^{:dynamic true} x` と同等。"

#. type: Plain text
#: en/content/reference/reader.adoc:149
msgid "Metadata can be chained in which case they are merged from right to left."
msgstr "メタデータはチェインすることができる。その場合、メタデータは右から左へとマージされる。"

#. type: Title ===
#: en/content/reference/reader.adoc:150
#, no-wrap
msgid "Dispatch (pass:[#])"
msgstr "ディスパッチ (pass:[#])"

#. type: Plain text
#: en/content/reference/reader.adoc:153
msgid ""
"The dispatch macro causes the reader to use a reader macro from another table, indexed by the character following"
msgstr ""
"ディスパッチマクロはリーダーに、後に続く文字でインデックスされた別のテーブルに定義されているリーダーマクロを使用させ"
"る。"

#. type: Plain text
#: en/content/reference/reader.adoc:155
msgid "pass:[#{}] - see Sets above"
msgstr "pass:[#{}] - 上記のセットを参照"

#. type: Plain text
#: en/content/reference/reader.adoc:156
msgid "Regex patterns (pass:[#\"pattern\"])"
msgstr "正規表現パターン (pass:[#\"pattern\"])"

#. type: Plain text
#: en/content/reference/reader.adoc:158
msgid ""
"A regex pattern is read and _compiled at read time_. The resulting object is of type java.util.regex.Pattern. Regex "
"strings do not follow the same escape character rules as strings. Specifically, backslashes in the pattern are "
"treated as themselves (and do not need to be escaped with an additional backslash). For example, `(re-pattern \"\\\\s*"
"\\\\d+\")` can be written more concisely as `#\"\\s*\\d+\"`."
msgstr ""
"正規表現パターンは _読み込み時に_ コンパイルされる。コンパイルした結果のオブジェクトは java.util.regex.Patternタイプに"
"なる。正規表現のエスケープ文字のルールは文字列とは異なる。特にバックスラッシュはそれ自身として扱われる。(なのでエス"
"ケープするためにもうひとつバックスラッシュを付ける必要がない)。例えば、 `(re-pattern \"\\\\s*\\\\d+\")` は簡潔に `#"
"\"\\s*\\d+\"` と書ける。"

#. type: Plain text
#: en/content/reference/reader.adoc:159
msgid "Var-quote (pass:[#'])"
msgstr "Var-quote (pass:[#'])"

#. type: Plain text
#: en/content/reference/reader.adoc:161
msgid "`#'x` => `(var x)`"
msgstr "`#'x` => `(var x)`"

#. type: Plain text
#: en/content/reference/reader.adoc:162
msgid "Anonymous function literal (#())"
msgstr "無名関数リテラル (#())"

#. type: Plain text
#: en/content/reference/reader.adoc:165
msgid ""
"`#(...)` => `(fn [args] (...))` + where args are determined by the presence of argument literals taking the form %, "
"%n or %&. % is a synonym for %1, %n designates the nth arg (1-based), and %& designates a rest arg. This is not a "
"replacement for https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/fn[fn] - idiomatic use would be "
"for very short one-off mapping/filter fns and the like. #() forms cannot be nested."
msgstr ""
"`\\#(...)` => `(fn [args] (...))` + ここで引数は%、%n 、%nまたは%&の形をとる引数リテラルの存在によって決定される。%"
"は%1と同義で、 %nは(1から始まる)n番目の引数を指定し、%& はrest引数を指定する。これは http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/fn[fn] を置き換えるものではない - 慣習的には短く一度しか使用しないマッピングやフィ"
"ルター関数などのために利用する。#()フォームをネストすることはできない。"

#. type: Plain text
#: en/content/reference/reader.adoc:166
msgid "Ignore next form (pass:[#_])"
msgstr "次のフォームを無視する (pass:[#_])"

#. type: Plain text
#: en/content/reference/reader.adoc:168
msgid ""
"The form following pass:[#_] is completely skipped by the reader. (This is a more complete removal than the https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/comment[comment] macro which yields nil)."
msgstr ""
"pass:[#_] の後に続くフォームはreaderによって完全に無視される。(https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/comment[comment] マクロはnilを返すのでこちらの方がより完全なフォームの除去になる)。"

#. type: Title ===
#: en/content/reference/reader.adoc:170
#, no-wrap
msgid "Syntax-quote (`, note, the \"backquote\" character), Unquote (~) and Unquote-splicing (~@)"
msgstr "シンタックスクォート (`, バッククォートである点について注意), (アンクォート) (~), (アンクォートスプライシング) (~@)"

#. type: Plain text
#: en/content/reference/reader.adoc:173
msgid "For all forms other than Symbols, Lists, Vectors, Sets and Maps, `x is the same as 'x. +"
msgstr "シンボル、リスト、ベクター、セット、マップ以外のフォームについては `xと'xは同等。 "

#. type: Plain text
#: en/content/reference/reader.adoc:175
msgid ""
"For Symbols, syntax-quote _resolves_ the symbol in the current context, yielding a fully-qualified symbol (i.e. "
"namespace/name or fully.qualified.Classname). If a symbol is non-namespace-qualified and ends with pass:['#'], it is "
"resolved to a generated symbol with the same name to which '_' and a unique id have been appended. e.g. x# will "
"resolve to x_123. All references to that symbol within a syntax-quoted expression resolve to the same generated "
"symbol. +"
msgstr ""
"シンボルに対してシンタックスクォートはシンボルを現在のコンテキストで _解決_ し、完全修飾されたシンボルを生成する。"
"(例: namespace/name もしくは fully.qualified.Classname)。シンボルが名前空間で修飾されておらず、pass:['#']で終わる場"
"合、同じ名前に'_'とユニークなIDを末尾につけた自動生成されたシンボルに解決される。例: x# は x_123に解決される。同じシン"
"タックスクォート内での同じシンボルに対する参照は同一の自動生成されたシンボルに解決される。"

#. type: Plain text
#: en/content/reference/reader.adoc:177
msgid ""
"For Lists/Vectors/Sets/Maps, syntax-quote establishes a template of the corresponding data structure. Within the "
"template, unqualified forms behave as if recursively syntax-quoted, but forms can be exempted from such recursive "
"quoting by qualifying them with unquote or unquote-splicing, in which case they will be treated as expressions and be "
"replaced in the template by their value, or sequence of values, respectively. +"
msgstr ""
"リスト/ベクター/セット/マップに対するシンタックスクォートは対応するデータ構造のテンプレートを設ける。テンプレートの内"
"部では未修飾のフォームはあたかも再帰的にシンタックスクォートされたように振る舞うが、アンクォートもしくはアンクォートス"
"プライシング修飾することでフォームを再帰的なシンタックスクォートの対象から外すことができる。その場合、フォームは式とし"
"て扱われ、テンプレートの中でそれぞれその値、もしくは値のシークエンスで置き換えられる。"

#. type: delimited block -
#: en/content/reference/reader.adoc:186
#, no-wrap
msgid ""
"user=> (def x 5)\n"
"user=> (def lst '(a b c))\n"
"user=> `(fred x ~x lst ~@lst 7 8 :nine)\n"
"(user/fred user/x 5 user/lst a b c 7 8 :nine)\n"
msgstr ""
"user=> (def x 5)\n"
"user=> (def lst '(a b c))\n"
"user=> `(fred x ~x lst ~@lst 7 8 :nine)\n"
"(user/fred user/x 5 user/lst a b c 7 8 :nine)\n"

#. type: Plain text
#: en/content/reference/reader.adoc:189
msgid "The read table is currently not accessible to user programs."
msgstr "現在リードテーブルをユーザープログラムからアクセスすることはできない。"

#. type: Title ==
#: en/content/reference/reader.adoc:190
#, no-wrap
msgid "extensible data notation (edn)"
msgstr "extensible data notation (edn) (拡張可能なデータ記法)"

#. type: Plain text
#: en/content/reference/reader.adoc:192
msgid ""
"Clojure's reader supports a superset of https://github.com/edn-format/edn[extensible data notation (edn)]. The edn "
"specification is under active development, and complements this document by defining a subset of Clojure data syntax "
"in a language-neutral way."
msgstr ""
"Clojureのreaderは https://github.com/edn-format/edn[extensible data notation (edn)]のスーパーセットをサポートしてい"
"る。ednの仕様の策定は現在活動的に行われおり、Clojureのデータの文法のサブセットを定義することでこのドキュメントを言語に"
"依らない形で補完している。"

#. type: Title ==
#: en/content/reference/reader.adoc:194
#, no-wrap
msgid "Tagged Literals"
msgstr "タグ付きリテラル(tagged literal)"

#. type: Plain text
#: en/content/reference/reader.adoc:196
msgid ""
"Tagged literals are Clojure's implementation of edn https://github.com/edn-format/edn#tagged-elements[tagged "
"elements]."
msgstr "タグ付きリテラルはednのClojureによる実装 https://github.com/edn-format/edn#tagged-elements[tagged elements]."

#. type: Plain text
#: en/content/reference/reader.adoc:198
msgid ""
"When Clojure starts, it searches for files named `data_readers.clj` at the root of the classpath. Each such file must "
"contain a Clojure map of symbols, like this:"
msgstr ""
"Clojure が起動する際、クラスパスのルート位置から `data_readers.clj` という名前がついたファイルが探される。それらのファ"
"イルには次のようなシンボルをClojureマップに書く:"

#. type: delimited block -
#: en/content/reference/reader.adoc:202
#, no-wrap
msgid ""
"{foo/bar my.project.foo/bar\n"
" foo/baz my.project/baz}\n"
msgstr ""
"{foo/bar my.project.foo/bar\n"
" foo/baz my.project/baz}\n"

#. type: Plain text
#: en/content/reference/reader.adoc:204
msgid ""
"The key in each pair is a tag that will be recognized by the Clojure reader. The value in the pair is the fully-"
"qualified name of a <<vars#,Var>> which will be invoked by the reader to parse the form following the tag. For "
"example, given the `data_readers.clj` file above, the Clojure reader would parse this form:"
msgstr ""
"各ペアのキーはClojureリーダーによって認識されるタグとなる。ペアの値は完全修飾された <<vars#,Var>> の名前であり、リー"
"ダーがタグの後に続くフォームをパースするために参照される。例えば上記の `data_eaders.clj` ファイルが与えられた場合、"
"Clojureのリーダーはこのフォームを次のようにパースする:"

#. type: delimited block -
#: en/content/reference/reader.adoc:207
#, no-wrap
msgid "#foo/bar [1 2 3]\n"
msgstr "#foo/bar [1 2 3]\n"

#. type: Plain text
#: en/content/reference/reader.adoc:209
msgid ""
"by invoking the Var `#'my.project.foo/bar` on the vector `[1 2 3]`. The data reader function is invoked on the form "
"AFTER it has been read as a normal Clojure data structure by the reader."
msgstr ""
"Var `#'my.project.foo/bar` をベクター `[1 2 3]` に対して呼び出す。データリーダー関数はフォームが通常のClojureデータ構"
"造としてリーダーに読み込まれた後に呼び出される。"

#. type: Plain text
#: en/content/reference/reader.adoc:211
msgid ""
"Reader tags without namespace qualifiers are reserved for Clojure. Default reader tags are defined in https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/default-data-readers[default-data-readers] but may be overridden "
"in `data_readers.clj` or by rebinding https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2Adata-"
"readers%2A[pass:[*data-readers*]]. If no data reader is found for a tag, the function bound in https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/%2Adefault-data-reader-fn%2A[pass:[*default-data-reader-fn*]] will be "
"invoked with the tag and value to produce a value. If pass:[*default-data-reader-fn*] is nil (the default), a "
"RuntimeException will be thrown."
msgstr ""
"名前空間で修飾されていないリーダータグはClojureのために確保されている。デフォルトのリーダータグは https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/default-data-readers[default-data-readers] で定義されているが、 "
"`data_readers.clj` で上書きすることもできるし、 https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"%2Adata-readers%2A[pass:[*data-readers*]] を再束縛することもできる。 タグに対してデータリーダーが見つからなかった場"
"合、 https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2Adefault-data-reader-fn%2A[pass:[*default-"
"data-reader-fn*]] で束縛されている関数がタグと値と共に呼びだされ値が作り出される。 pass:[*default-data-reader-fn*] が"
"nilの場合(デフォルト)RuntimeExceptionが発生する。"

#. type: Title ===
#: en/content/reference/reader.adoc:212
#, no-wrap
msgid "Built-in tagged literals"
msgstr "組み込みのタグ付きリテラル"

#. type: Plain text
#: en/content/reference/reader.adoc:217
msgid ""
"Clojure 1.4 introduced the _instant_ and _UUID_ tagged literals. Instants have the format `#inst \"yyyy-mm-ddThh:mm:"
"ss.fff+hh:mm\"`.  NOTE: Some of the elements of this format are optional. See the code for details.  The default "
"reader will parse the supplied string into a `java.util.Date` by default. For example:"
msgstr ""
"Clojure 1.4では _instant_ と _UUID_ のタグ付きリテラルが導入された。instantは `#inst \"yyyy-mm-ddThh:mm:ss.fff+hh:mm"
"\"` という形式をとる。 注意: この形式の一部の要素は省略可能だ。詳細はコードを参照。デフォルトのリーダーは与えられた文"
"字列をパースしてデフォルトでは `java.util.Date` にする。例えば:"

#. type: delimited block -
#: en/content/reference/reader.adoc:222
#, no-wrap
msgid ""
"(def instant #inst \"2018-03-28T10:48:00.000\")\n"
"(= java.util.Date (class instant))\n"
";=> true\n"
msgstr ""
"(def instant #inst \"2018-03-28T10:48:00.000\")\n"
"(= java.util.Date (class instant))\n"
";=> true\n"

#. type: Plain text
#: en/content/reference/reader.adoc:225
msgid ""
"Since pass[*data-readers*] is a dynamic var that can be bound, you can replace the default reader with a different "
"one. For example, `clojure.instant/read-instant-calendar` will parse the literal into a `java.util.Calendar`, while "
"`clojure.instant/read-instant-timestamp` will parse it into a `java.util.Timestamp`:"
msgstr ""
"pass[*data-readers*] は束縛可能な動的Varなので、デフォルトのリーダーを別のものに置き換えることができる。例えば "
"`clojure.instant/read-instant-calendar` はリテラルをパースして `java.util.Calendar` にするが、 `clojure.instant/read-"
"instant-timestamp` はリテラルをパースして `java.util.Timestamp` にする:"

#. type: delimited block -
#: en/content/reference/reader.adoc:229
#, no-wrap
msgid ""
"(binding [*data-readers* {'inst read-instant-calendar}]\n"
"  (= java.util.Calendar (class (read-string instant))))\n"
";=> true\n"
msgstr ""
"(binding [*data-readers* {'inst read-instant-calendar}]\n"
"  (= java.util.Calendar (class (read-string instant))))\n"
";=> true\n"

#. type: delimited block -
#: en/content/reference/reader.adoc:233
#, no-wrap
msgid ""
"(binding [*data-readers* {'inst read-instant-timestamp}]\n"
"  (= java.util.Timestamp (class (read-string instant))))\n"
";=> true\n"
msgstr ""
"(binding [*data-readers* {'inst read-instant-timestamp}]\n"
"  (= java.util.Timestamp (class (read-string instant))))\n"
";=> true\n"

#. type: Plain text
#: en/content/reference/reader.adoc:236
msgid "The `#uuid` tagged literal will be parsed into a `java.util.UUID`:"
msgstr "`#uuid` タグ付きリテラルはパースされて `java.util.UUID` になる:"

#. type: delimited block -
#: en/content/reference/reader.adoc:240
#, no-wrap
msgid ""
"(= java.util.UUID (class (read-string \"#uuid \\\"3b8a31ed-fd89-4f1b-a00f-42e3d60cf5ce\\\"\")))\n"
";=> true\n"
msgstr ""
"(= java.util.UUID (class (read-string \"#uuid \\\"3b8a31ed-fd89-4f1b-a00f-42e3d60cf5ce\\\"\")))\n"
";=> true\n"

#. type: Title ==
#: en/content/reference/reader.adoc:242
#, no-wrap
msgid "Reader Conditionals"
msgstr "リーダーコンディショナル(reader conditional)"

#. type: Plain text
#: en/content/reference/reader.adoc:245
msgid ""
"Clojure 1.7 introduced a new extension (.cljc) for portable files that can be loaded by multiple Clojure platforms. "
"The primary mechanism for managing platform-specific code is to isolate that code into a minimal set of namespaces, "
"and then provide platform-specific versions (.clj/.class or .cljs) of those namespaces."
msgstr ""
"Clojure 1.7 で複数のClojureプラットフォームの間でロードできるポータブルなファイルのための新しい拡張子 (.cljc)が導入さ"
"れた。プラットフォームに特有なコードを管理する主なメカニズムはプラットフォームに特有なコードをできるだけ小さなネームス"
"ペースに隔離し、それらのプラットフォーム毎のバージョン(.clj/.class or.cljs)を用意することだ。"

#. type: Plain text
#: en/content/reference/reader.adoc:247
msgid ""
"In cases where is not feasible to isolate the varying parts of the code, or where the code is mostly portable with "
"only small platform-specific parts, 1.7 also introduced _reader conditionals_, which are supported only in cljc files "
"and at the default REPL. Reader conditionals should be used sparingly and only when necessary."
msgstr ""
"プラットフォーム毎に異なるコードを隔離することが現実的ではない場合やコードがほとんどポータブルでプラットフォーム特有の"
"部分がごく少ない場合のために1.7で cljcとデフォルトREPLでのみ使える _リーダーコンディショナル_ が導入された。_リーダー"
"コンディショナル_ は控えめに、必要な時だけ使うことが推奨される。"

#. type: Plain text
#: en/content/reference/reader.adoc:249
msgid ""
"Reader conditionals are a new reader dispatch form starting with `pass:[#?]` or `pass:[#?@]`. Both consist of a "
"series of alternating features and expressions, similar to `cond`. Every Clojure platform has a well-known \"platform "
"feature\" - `:clj`, `:cljs`, `:cljr`. Each condition in a reader conditional is checked in order until a feature "
"matching the platform feature is found. The reader conditional will read and return that feature's expression. The "
"expression on each non-selected branch will be read but skipped. A well-known `:default` feature will always match "
"and can be used to provide a default. If no branches match, no form will be read (as if no reader conditional "
"expression was present)."
msgstr ""
"リーダーコンディショナルは `pass:[#?]` もしくは `pass:[#?@]` で始まる新しいディスパッチフォームだ。どちらも `cond` と"
"似たような形でフィーチャーと式を含む。全てのClojureプラットフォームはよく知られた \"プラットフォームフィーチャー\" が"
"存在する - `:clj`, `:cljs`, `:cljr`。リーダーコンディショナルの条件はプラットフォームにマッチするフィーチャーが見つか"
"るまで順番に検査され、そのフィーチャーの式を読み込んで返す。マッチしなかった分岐の式は読み込まれはするが、スキップされ"
"る。よく知られた `:default` フィーチャーは必ずマッチするためデフォルトとして使える。マッチするブランチが存在しない場"
"合、フォームは一切読み込まれない(リーダーコンディショナルが最初から存在しないのと同等)。"

#. type: Plain text
#: en/content/reference/reader.adoc:251
msgid ""
"The following example will read as Double/NaN in Clojure, js/NaN in ClojureScript, and nil in any other platform:"
msgstr ""
"以下の例はClojureでは Double/NaN ClojureScript では js/NaN、それ以外のプラットフォームではnilとして読み込まれる。"

#. type: delimited block -
#: en/content/reference/reader.adoc:257
#, no-wrap
msgid ""
"#?(:clj     Double/NaN\n"
"   :cljs    js/NaN\n"
"   :default nil)\n"
msgstr ""
"#?(:clj     Double/NaN\n"
"   :cljs    js/NaN\n"
"   :default nil)\n"

#. type: Plain text
#: en/content/reference/reader.adoc:260
msgid ""
"The syntax for `pass:[#?@]` is exactly the same but the expression is expected to return a collection that can be "
"spliced into the surrounding context, similar to unquote-splicing in syntax quote. Use of reader conditional splicing "
"at the top level is not supported and will throw an exception. An example:"
msgstr ""
"`pass:[#?@]` の文法は全く同じだが、アンクォートスプライシングと同様に周りのコンテキストにスプライス可能なコレクション"
"を返す式が期待される。リーダーコンディショナルスプライシングをトップレベルで使用することはサポートされておらず、例外が"
"発生する。例:"

#. type: delimited block -
#: en/content/reference/reader.adoc:267
#, no-wrap
msgid ""
"[1 2 #?@(:clj [3 4] :cljs [5 6])]\n"
";; in clj =>        [1 2 3 4]\n"
";; in cljs =>       [1 2 5 6]\n"
";; anywhere else => [1 2]\n"
msgstr ""
"[1 2 #?@(:clj [3 4] :cljs [5 6])]\n"
";; in clj =>        [1 2 3 4]\n"
";; in cljs =>       [1 2 5 6]\n"
";; anywhere else => [1 2]\n"

#. type: Plain text
#: en/content/reference/reader.adoc:270
msgid ""
"The https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read[read] and https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/read-string[read-string] functions optionally take a map of options as a "
"first argument. The current feature set and reader conditional behavior can be set in the options map with these keys "
"and values:"
msgstr ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read[read] と https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/read-string[read-string] 関数は任意でオプションを指定したマップを第一引数に取ること"
"ができる。このオプションマップのキーと値で現在のフィーチャーとリーダーコンディショナルの挙動を指定することができる:"

#. type: delimited block -
#: en/content/reference/reader.adoc:276
#, no-wrap
msgid ""
"  :read-cond - :allow to process reader conditionals, or\n"
"               :preserve to keep all branches\n"
"  :features - persistent set of feature keywords that are active\n"
msgstr ""
"  :read-cond - :allow を指定してリーダーコンディショナルを処理する、もしくは\n"
"               :preserve で全てのブランチを保持する。\n"
"  :features - 有効なフィーチャーキーワードのパーシスタントセット。\n"

#. type: Plain text
#: en/content/reference/reader.adoc:279
msgid "An example of how to test ClojureScript reader conditionals from Clojure:"
msgstr "ClojureScriptのリーダーコンデショナルをClojureからテストする例:"

#. type: delimited block -
#: en/content/reference/reader.adoc:287
#, no-wrap
msgid ""
"(read-string\n"
"  {:read-cond :allow\n"
"   :features #{:cljs}}\n"
"  \"#?(:cljs :works! :default :boo)\")\n"
";; :works!\n"
msgstr ""
"(read-string\n"
"  {:read-cond :allow\n"
"   :features #{:cljs}}\n"
"  \"#?(:cljs :works! :default :boo)\")\n"
";; :works!\n"

#. type: Plain text
#: en/content/reference/reader.adoc:290
msgid ""
"However, note that the Clojure reader will _always_ inject the platform feature :clj as well. For platform-agnostic "
"reading, see https://github.com/clojure/tools.reader[tools.reader]."
msgstr ""
"ただ、Clojureのリーダーは _常に_ プラットフォームフィーチャーである:cljも注入する点には注意が必要だ。プラットフォーム"
"に依存しない読み込みに関しては https://github.com/clojure/tools.reader[tools.reader]を参照。"

#. type: Plain text
#: en/content/reference/reader.adoc:292
msgid ""
"If the reader is invoked with `{:read-cond :preserve}`, the reader conditional and non-executed branches will be "
"preserved, as data, in the returned form. The reader-conditional will be returned as a type that supports keyword "
"retrieval for keys with `:form` and a `:splicing?` flag. Read but skipped tagged literals will be returned as a type "
"that supports keyword retrieval for keys with `:form` and `:tag` keys."
msgstr ""
"リーダーが `{:read-cond :preserve}` で呼び出された場合、リーダーコンディショナルと未実行の分岐がデータとして保持された"
"フォームを返す。その場合、リーダーコンディショナルは `:form` と `:splicing?` フラグのキーワード取得をサポートする型と"
"して返される。読み込まれたもののスキップされたタグ付きリテラルは `:form` `:tag` のキーによるキーワード取得をサポートす"
"る型として返される。"

#. type: delimited block -
#: en/content/reference/reader.adoc:299
#, no-wrap
msgid ""
"(read-string\n"
"  {:read-cond :preserve}\n"
"  \"[1 2 #?@(:clj [3 4] :cljs [5 6])]\")\n"
";; [1 2 #?@(:clj [3 4] :cljs [5 6])]\n"
msgstr ""
"(read-string\n"
"  {:read-cond :preserve}\n"
"  \"[1 2 #?@(:clj [3 4] :cljs [5 6])]\")\n"
";; [1 2 #?@(:clj [3 4] :cljs [5 6])]\n"

#. type: Plain text
#: en/content/reference/reader.adoc:302
msgid ""
"The following functions can also be used as predicates or constructors for these types: + https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/reader-conditional%3F[reader-conditional?] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/reader-conditional[reader-conditional] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/tagged-literal%3F[tagged-literal?] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/tagged-literal[tagged-literal]"
msgstr ""
"これらの型の述語やコンストラクタとして以下の関数を使用することができる: + https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/reader-conditional%3F[reader-conditional?] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/reader-conditional[reader-conditional] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/tagged-literal%3F[tagged-literal?] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/tagged-literal[tagged-literal]"
