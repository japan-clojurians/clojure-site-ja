# Japanese translations for clojure-site-ja package
# Copyright (C) 2016 Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# Automatically generated, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2019-06-12 00:05+0900\n"
"PO-Revision-Date: 2019-02-18 20:21+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: en/content/reference/metadata.adoc:4 en/content/reference/protocols.adoc:4 en/content/reference/sequences.adoc:4
#: en/content/reference/multimethods.adoc:4 en/content/reference/libs.adoc:4 en/content/reference/transients.adoc:4
#: en/content/reference/compilation.adoc:4 en/content/reference/other_libraries.adoc:4
#: en/content/reference/documentation.adoc:4 en/content/reference/macros.adoc:4 en/content/reference/transducers.adoc:4
#: en/content/reference/refs.adoc:4 en/content/reference/lazy.adoc:4 en/content/reference/namespaces.adoc:4
#: en/content/reference/lisps.adoc:4 en/content/reference/evaluation.adoc:4 en/content/reference/other_functions.adoc:4
#: en/content/reference/reducers.adoc:4 en/content/reference/data_structures.adoc:4 en/content/reference/atoms.adoc:4
#: en/content/reference/repl_and_main.adoc:4 en/content/reference/agents.adoc:4 en/content/reference/datatypes.adoc:4
#: en/content/community/libraries.adoc:4 en/content/community/license.adoc:4 en/content/community/downloads_older.adoc:4
#: en/content/community/downloads.adoc:4 en/content/community/swag.adoc:4 en/content/404.adoc:4
#: en/content/privacy.adoc:4 en/content/search.adoc:4 en/content/about/spec.adoc:4
#: en/content/about/concurrent_programming.adoc:4 en/content/about/lisp.adoc:4 en/content/about/jvm_hosted.adoc:4
#: en/content/about/runtime_polymorphism.adoc:4 en/content/about/dynamic.adoc:4 en/content/about/features.adoc:4
#: en/content/about/rationale.adoc:4 en/content/about/state.adoc:4 en/content/about/clojurescript.adoc:4
#: en/content/about/functional_programming.adoc:4 en/content/about/clojureclr.adoc:4
msgid "Rich Hickey 2015-01-01"
msgstr "Rich Hickey 2015-01-01"

#. type: Title ==
#: en/content/reference/libs.adoc:64 en/content/reference/refs.adoc:73 en/content/reference/namespaces.adoc:24
#: en/content/reference/other_functions.adoc:41 en/content/reference/other_functions.adoc:65
#: en/content/reference/vars.adoc:85 en/content/reference/data_structures.adoc:70
#: en/content/reference/data_structures.adoc:90 en/content/reference/data_structures.adoc:98
#: en/content/reference/data_structures.adoc:107 en/content/reference/data_structures.adoc:116
#: en/content/reference/data_structures.adoc:162 en/content/reference/data_structures.adoc:174
#: en/content/reference/data_structures.adoc:188 en/content/reference/data_structures.adoc:223
#: en/content/reference/repl_and_main.adoc:185 en/content/reference/agents.adoc:64
#, no-wrap
msgid "Related functions"
msgstr "関連する関数"

#. type: Title ==
#: en/content/reference/reader.adoc:24 en/content/reference/data_structures.adoc:111
#, no-wrap
msgid "Symbols"
msgstr "シンボル"

#. type: Title ==
#: en/content/reference/reader.adoc:100 en/content/reference/data_structures.adoc:235
#: en/content/guides/learn/hashed_colls.adoc:19
#, no-wrap
msgid "Sets"
msgstr "セット"

#. type: Title =
#: en/content/reference/data_structures.adoc:1
#, no-wrap
msgid "Data Structures"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:18
msgid "Clojure has a rich set of data structures. They share a set of properties:"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:20
msgid "They are immutable"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:21
msgid "They are read-able"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:22
msgid "They support proper value equality semantics in their implementation of equals"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:23
msgid "They provide good hash values"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:24
msgid "In addition, the collections:"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:25
msgid "Are manipulated via interfaces."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:26
msgid "Support sequencing"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:27
msgid "Support persistent manipulation."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:28
msgid "Support metadata"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:29
msgid "Implement java.lang.Iterable"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:30
msgid "Implement the non-optional (read-only) portion of java.util.Collection"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:32
#, no-wrap
msgid "nil"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:35
msgid ""
"nil is a possible value of any data type in Clojure. nil has the same value as Java null. The Clojure conditional "
"system is based around nil and false, with nil and false representing the values of logical falsity in conditional "
"tests - anything else is logical truth. In addition, nil is used as the end-of-sequence sentinel value in the "
"sequence protocol."
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:37
#, no-wrap
msgid "Numbers"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:40
msgid ""
"Clojure provides full support for JVM primitive values by default, allowing high performance, idiomatic Clojure code "
"for numeric applications."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:42
msgid ""
"Clojure also supports the Java boxed number types derived from java.lang.Number, including BigInteger and BigDecimal, "
"plus its own Ratio type. There is some special handling:"
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:43
#, no-wrap
msgid "Longs"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:46
msgid ""
"By default Clojure operates with natural numbers as instances of Java's long primitive type. When a primitive integer "
"operation results in a value that too large to be contained in a primitive value, a java.lang.ArithmeticException is "
"thrown. Clojure provides a set of alternative math operators suffixed with an apostrophe: +', -', *', inc', and dec'. "
"These operators auto-promote to BigInt upon overflow, but are less efficient than the regular math operators."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:47
#, no-wrap
msgid "Ratio"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:50
msgid ""
"Represents a ratio between integers. Division of integers that can't be reduced to an integer yields a ratio, i.e. "
"22/7 = 22/7, rather than a floating point or truncated value."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:51
#, no-wrap
msgid "Contagion"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:54
msgid ""
"BigInts and floating point types are \"contagious\" across operations. That is, any integer operation involving a "
"BigInt will result in a BigInt, and any operation involving a double or float will result in a double."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:55
#, no-wrap
msgid "BigInt and BigDecimal literals"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:58
msgid "Numeric literals for BigInt and BigDecimal are specified using a postfix N and M respectively."
msgstr ""

#. type: Table
#: en/content/reference/data_structures.adoc:68
#, no-wrap
msgid ""
"| Example expression | Return value\n"
"| `(== 1 1.0 1M)` | `true`\n"
"| `(/ 2 3)` | `2/3`\n"
"| `(/ 2.0 3)` | `0.6666666666666666`\n"
"| `(map #(Math/abs %) (range -3 3))` | `(3 2 1 0 1 2)`\n"
"| `(class 36786883868216818816N)` | `clojure.lang.BigInt`\n"
"| `(class 3.14159265358M)` | `java.math.BigDecimal`\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:79
msgid ""
"Computation: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2B[\\+] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/%2D[-] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/%2A[\\*] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2F[/] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/inc[inc] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/dec[dec] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/quot[quot] https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/rem[rem] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/min[min] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/max[max] Auto-"
"promoting computation: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2B%27[+'] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2D%27[-'] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/%2A%27[*'] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/inc"
"%27[inc'] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dec%27[dec'] Comparison: https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/%3D%3D[==] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/%3C[<] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%3C%3D[pass:"
"[<=]] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%3E[>] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/%3E%3D[>=] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"zero%3F[zero?] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/pos%3F[pos?] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/neg%3F[neg?] Bitwise operations: https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/bit-and[bit-and] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/bit-or[bit-or] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/bit-xor[bit-"
"xor] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/bit-not[bit-not] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/bit-shift-right[bit-shift-right] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/bit-shift-left[bit-shift-left] Ratios: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/numerator[numerator] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"denominator[denominator] Coercions: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/int[int] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/bigdec[bigdec] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/bigint[bigint] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/double[double] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/float[float] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/long[long] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/num[num] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/short[short]"
msgstr ""
"マクロを作成する: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defmacro[defmacro] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/definline[definline] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/macroexpand-1[macroexpand-1] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/macroexpand[macroexpand] 分岐: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"and[and] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/or[or] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/when[when] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"when-not[when-not] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/when-let[when-let] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/when-first[when-first] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/if-not[if-not] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"if-let[if-let] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/cond[cond] http://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/condp[condp] ループ ( <<sequences#,Sequences>> も参照): http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/for[for] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/doseq[doseq] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dotimes[dotimes] "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/while[while] varを扱う ( <<vars#,Vars and "
"Environment>> も参照): http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/ns[ns] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/declare[declare] http://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/defn[defn] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"defmacro[defmacro] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/definline[definline] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/defmethod[defmethod] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/defmulti[defmulti] http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/defn-[defn-] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defonce[defonce] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/defstruct[defstruct] コードの並べ替え: http://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/%2E%2E[..] http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/doto[doto] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3e[pass:[->]] ダイナミックスコー"
"プ ( <<vars#,Vars and Environment>> も参照): http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"binding[binding] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/locking[locking] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/time[time] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/with-in-str[with-in-str] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-"
"local-vars[with-local-vars] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-open[with-open] "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-out-str[with-out-str] http://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/with-precision[with-precision] lazyなものを作成する ( <<sequences#,"
"Sequences>> も参照): http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-cat[lazy-cat] http://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-cons[lazy-cons] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/delay[delay] <<java_interop#,Java interop>> macros: http://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/%2E%2E[..] http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/amap[amap] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/areduce[areduce] http://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/gen-class[gen-class] http://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/gen-interface[gen-interface] http://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/proxy[proxy] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/proxy-super[proxy-"
"super] http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/memfn[memfn] コードをドキュメント化する: "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/assert[assert] http://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/comment[comment] http://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/doc[doc] トランザクション: http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dosync[dosync] "
"http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/io![io!]"

#. type: Title ==
#: en/content/reference/data_structures.adoc:81
#, no-wrap
msgid "Strings"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:84
msgid "Clojure strings are Java Strings. See also <<other_functions#printing#,Printing>>."
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:88
#, no-wrap
msgid ""
"user=> (map (fn [x] (.toUpperCase x)) (.split \"Dasher Dancer Prancer\" \" \"))\n"
"(\"DASHER\" \"DANCER\" \"PRANCER\")\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:93
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/str[str] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/string?[string?] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/pr-str[pr-str] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/prn-str[prn-str] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/print-str[print-str] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/println-str[println-str] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/with-out-str[with-out-str]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:95
#, no-wrap
msgid "Characters"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:97
msgid "Clojure characters are Java Characters."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:100
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/char[char] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/char-name-string[char-name-string] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/char-escape-string[char-escape-string]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:102
#, no-wrap
msgid "Keywords"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:104
msgid ""
"Keywords are symbolic identifiers that evaluate to themselves. They provide very fast equality tests. Like Symbols, "
"they have names and optional <<namespaces#,namespaces>>, both of which are strings. The leading ':' is not part of "
"the namespace or name."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:106
msgid ""
"Keywords implement IFn for invoke() of one argument (a map) with an optional second argument (a default value). For "
"example `(:mykey my-hash-map :none)` means the same as `(get my-hash-map :mykey :none)`. See https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/get[get]."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:109
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keyword[keyword] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/keyword?[keyword?]"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:113
msgid ""
"Symbols are identifiers that are normally used to refer to something else. They can be used in program forms to refer "
"to function parameters, let bindings, class names and global vars. They have names and optional <<namespaces#,"
"namespaces>>, both of which are strings. Symbols can have metadata (see https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/with-meta[with-meta])."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:115
msgid ""
"Symbols, just like Keywords, implement IFn for invoke() of one argument (a map) with an optional second argument (a "
"default value). For example `('mysym my-hash-map :none)` means the same as `(get my-hash-map 'mysym :none)`. See "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/get[get]."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:118
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/symbol[symbol] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/symbol?[symbol?] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/genysm[gensym] (see also the \\#-suffix <<reader#,reader>> macro)"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:120 en/content/guides/spec.adoc:435
#, no-wrap
msgid "Collections"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:123
msgid ""
"All of the Clojure collections are immutable and http://en.wikipedia.org/wiki/Persistent_data_structure[persistent]. "
"In particular, the Clojure collections support efficient creation of 'modified' versions, by utilizing structural "
"sharing, and make all of their performance bound guarantees for persistent use. The collections are efficient and "
"inherently thread-safe. Collections are represented by abstractions, and there may be one or more concrete "
"realizations. In particular, since 'modification' operations yield new collections, the new collection might not have "
"the same concrete type as the source collection, but will have the same logical (interface) type."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:125
msgid ""
"All the collections support https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/count[count] for "
"getting the size of the collection, https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/conj[conj] "
"for 'adding' to the collection, and https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq[seq] to "
"get a sequence that can walk the entire collection, though their specific behavior is slightly different for "
"different types of collections."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:127
msgid ""
"Because collections support the https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq[seq] "
"function, all of the <<sequences#,sequence functions>> can be used with any collection."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:129
#, no-wrap
msgid "Java collection hashes"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:131
msgid ""
"The Java collection interfaces specify algorithms for http://docs.oracle.com/javase/7/docs/api/java/util/List."
"html#hashCode()[Lists], http://docs.oracle.com/javase/7/docs/api/java/util/Set.html#hashCode()[Sets], and http://docs."
"oracle.com/javase/7/docs/api/java/util/Map.html#hashCode()[Maps] in calculating hashCode() values. All Clojure "
"collections conform to these specifications in their hashCode() implementations."
msgstr ""

#. type: Title ===
#: en/content/reference/data_structures.adoc:132
#, no-wrap
msgid "Clojure collection hashes"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:134
msgid ""
"Clojure provides its own hash computations that provide better hash properties for collections (and other types), "
"known as the _hasheq_ value."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:136
msgid ""
"The `IHashEq` interface marks collections that provide the `hasheq()` function to obtain the hasheq value. In "
"Clojure, the https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/hash[hash] function can be used to "
"compute the hasheq value."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:138
msgid ""
"Ordered collections (vector, list, seq, etc) must use the following algorithm for calculating hasheq (where hash "
"computes hasheq). Note that unchecked-add-int and unchecked-multiply-int are used to get integer overflow "
"calculations."
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:147
#, no-wrap
msgid ""
"(defn hash-ordered [collection]\n"
"  (-> (reduce (fn [acc e] (unchecked-add-int\n"
"                            (unchecked-multiply-int 31 acc)\n"
"                            (hash e)))\n"
"              1\n"
"              collection)\n"
"      (mix-collection-hash (count collection))))\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:149
msgid ""
"Unordered collections (maps, sets) must use the following algorithm for calculating hasheq. A map entry is treated as "
"an ordered collection of key and value. Note that unchecked-add-int is used to get integer overflow calculations."
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:154
#, no-wrap
msgid ""
"(defn hash-unordered [collection]\n"
"  (-> (reduce unchecked-add-int 0 (map hash collection))\n"
"      (mix-collection-hash (count collection))))\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:156
msgid ""
"The https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mix-collection-hash[mix-collection-hash] "
"algorithm is an implementation detail subject to change."
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:158
#, no-wrap
msgid "Lists (IPersistentList)"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:161
msgid ""
"Lists are collections. They implement the ISeq interface directly (except for the empty list, which is not a valid "
"seq). https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/count[count] is O(1). https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/conj[conj] puts the item at the front of the list."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:168
msgid ""
"Create a list: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/list[list] https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/list*[list*] Treat a list like a stack: https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/peek[peek] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/pop[pop] Examine a list: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/list?[list?]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:170
#, no-wrap
msgid "Vectors (IPersistentVector)"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:173
msgid ""
"A Vector is a collection of values indexed by contiguous integers. Vectors support access to items by index in log32N "
"hops. https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/count[count] is O(1). https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/conj[conj] puts the item at the end of the vector. Vectors also "
"support https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rseq[rseq], which returns the items in "
"reverse order. Vectors implement IFn, for invoke() of one argument, which they presume is an index and look up in "
"themselves as if by nth, i.e. vectors are functions of their indices. Vectors are compared first by length, then each "
"element is compared in order."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:180
msgid ""
"Create a vector: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/vector[vector] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/vec[vec] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/vector-of[vector-of] Examine a vector: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/get[get] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nth[nth] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/peek[peek] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/rseq[rseq] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/vector?"
"[vector?] 'change' a vector: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/assoc[assoc] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/pop[pop] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/subvec[subvec] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/replace[replace]"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:182
msgid "See also <<other_libraries#,zippers>>"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:184
#, no-wrap
msgid "Maps (IPersistentMap)"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:187
msgid ""
"A Map is a collection that maps keys to values. Two different map types are provided - hashed and sorted. Hash maps "
"require keys that correctly support hashCode and equals. Sorted maps require keys that implement Comparable, or an "
"instance of Comparator. Hash maps provide faster access (log32N hops) vs (logN hops), but sorted maps are, well, "
"sorted. https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/count[count] is O(1). https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/conj[conj] expects another (possibly single entry) map as the "
"item, and returns a new map which is the old map plus the entries from the new, which may overwrite entries of the "
"old. https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/conj[conj] also accepts a MapEntry or a "
"vector of two items (key and value). https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq[seq] "
"returns a sequence of map entries, which are key/value pairs. Sorted map also supports https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/rseq[rseq], which returns the entries in reverse order. Maps implement "
"IFn, for invoke() of one argument (a key) with an optional second argument (a default value), i.e. maps are functions "
"of their keys. nil keys and values are ok."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:195
msgid ""
"Create a new map: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/hash-map[hash-map] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-map[sorted-map] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/sorted-map-by[sorted-map-by] 'change' a map: https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/assoc[assoc] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"dissoc[dissoc] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/select-keys[select-keys] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/merge[merge] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/merge-with[merge-with] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/zipmap[zipmap] Examine a map: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/get[get] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/contains?[contains?] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/find[find] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/keys[keys] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/vals[vals] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/map?[map?] Examine a map entry: https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/key[key] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/val[val]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:197
#, no-wrap
msgid "StructMaps"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:201
msgid "Most uses of StructMaps would now be better served by <<datatypes#,records>>."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:203
msgid ""
"Often many map instances have the same base set of keys, for instance when maps are used as structs or objects would "
"be in other languages. StructMaps support this use case by efficiently sharing the key information, while also "
"providing optional enhanced-performance accessors to those keys. StructMaps are in all ways maps, supporting the same "
"set of functions, are interoperable with all other maps, and are persistently extensible (i.e. struct maps are not "
"limited to their base keys). The only restriction is that you cannot dissociate a struct map from one of its base "
"keys. A struct map will retain its base keys in order."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:205
msgid ""
"StructMaps are created by first creating a structure basis object using https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/create-struct[create-struct] or https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/defstruct[defstruct], then creating instances with https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/struct-map[struct-map] or https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"struct[struct]."
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:221
#, no-wrap
msgid ""
"(defstruct desilu :fred :ricky)\n"
"(def x (map (fn [n]\n"
"              (struct-map desilu\n"
"                :fred n\n"
"                :ricky 2\n"
"                :lucy 3\n"
"                :ethel 4))\n"
"             (range 100000)))\n"
"(def fred (accessor desilu :fred))\n"
"(reduce (fn [n y] (+ n (:fred y))) 0 x)\n"
" -> 4999950000\n"
"(reduce (fn [n y] (+ n (fred y))) 0 x)\n"
" -> 4999950000\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:228
msgid ""
"StructMap setup: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/create-struct[create-struct] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defstruct[defstruct] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/accessor[accessor] Create individual struct: https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/struct-map[struct-map] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/struct[struct]"
msgstr ""

#. type: Title ==
#: en/content/reference/data_structures.adoc:230
#, no-wrap
msgid "ArrayMaps"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:233
msgid ""
"When doing code form manipulation it is often desirable to have a map which maintains key order. An array map is such "
"a map - it is simply implemented as an array of key val key val... As such, it has linear lookup performance, and is "
"only suitable for _very small_ maps. It implements the full map interface. New ArrayMaps can be created with the "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/array-map[array-map] function. Note that an "
"array map will only maintain sort order when un-'modified'. Subsequent assoc-ing will eventually cause it to 'become' "
"a hash-map."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:237
msgid "Sets are collections of unique values."
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:239
msgid "There is literal support for hash-sets:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:244
#, no-wrap
msgid ""
"#{:a :b :c :d}\n"
"-> #{:d :a :b :c}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:247
msgid ""
"You can create sets with the https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/hash-set[hash-set] "
"and https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-set[sorted-set] functions:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:252
#, no-wrap
msgid ""
"(hash-set :a :b :c :d)\n"
"-> #{:d :a :b :c}\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:255
#, no-wrap
msgid ""
"(sorted-set :a :b :c :d)\n"
"-> #{:a :b :c :d}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:258
msgid ""
"You can also get a set of the values in a collection using the https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/set[set] function:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:263
#, no-wrap
msgid ""
"(set [1 2 3 2 1 2 3])\n"
"-> #{1 2 3}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:266
msgid "Sets are collections:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:271
#, no-wrap
msgid ""
"(def s #{:a :b :c :d})\n"
"(conj s :e)\n"
"-> #{:d :a :b :e :c}\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:274
#, no-wrap
msgid ""
"(count s)\n"
"-> 4\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:277
#, no-wrap
msgid ""
"(seq s)\n"
"-> (:d :a :b :c)\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:280
#, no-wrap
msgid ""
"(= (conj s :e) #{:a :b :c :d :e})\n"
"-> true\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:283
msgid ""
"Sets support 'removal' with https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/disj[disj], as well "
"as _**contains?**_ and _**get**_, the latter returning the object that is held in the set which compares equal to the "
"key, if found:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:288
#, no-wrap
msgid ""
"(disj s :d)\n"
"-> #{:a :b :c}\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:291
#, no-wrap
msgid ""
"(contains? s :b)\n"
"-> true\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:294
#, no-wrap
msgid ""
"(get s :a)\n"
"-> :a\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:297
msgid "Sets are functions of their members, using _**get**_:"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:301
#, no-wrap
msgid ""
"(s :b)\n"
"-> :b\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/data_structures.adoc:304
#, no-wrap
msgid ""
"(s :k)\n"
"-> nil\n"
msgstr ""

#. type: Plain text
#: en/content/reference/data_structures.adoc:306
msgid ""
"Clojure provides basic set operations like https://clojure.github.io/clojure/clojure.set-api.html#clojure.set/"
"union[union] / https://clojure.github.io/clojure/clojure.set-api.html#clojure.set/difference[difference] / https://"
"clojure.github.io/clojure/clojure.set-api.html#clojure.set/intersection[intersection], as well as some pseudo-"
"relational algebra support for 'relations', which are simply sets of maps - https://clojure.github.io/clojure/clojure."
"set-api.html#clojure.set/select[select] / https://clojure.github.io/clojure/clojure.set-api.html#clojure.set/"
"index[index] / https://clojure.github.io/clojure/clojure.set-api.html#clojure.set/rename[rename] / https://clojure."
"github.io/clojure/clojure.set-api.html#clojure.set/join[join]."
msgstr ""
