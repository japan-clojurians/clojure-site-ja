# Japanese translations for clojure-site-ja package
# Copyright (C) 2016 Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# Automatically generated, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2018-04-02 07:18+0900\n"
"PO-Revision-Date: 2016-06-27 08:47+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: en/content/reference/metadata.adoc:15 en/content/reference/protocols.adoc:15 en/content/reference/sequences.adoc:15
#: en/content/reference/deps_and_cli.adoc:13 en/content/reference/multimethods.adoc:15 en/content/reference/libs.adoc:16
#: en/content/reference/transients.adoc:16 en/content/reference/compilation.adoc:16
#: en/content/reference/other_libraries.adoc:16 en/content/reference/macros.adoc:15
#: en/content/reference/transducers.adoc:15 en/content/reference/refs.adoc:15 en/content/reference/lazy.adoc:12
#: en/content/reference/reader.adoc:13 en/content/reference/special_forms.adoc:15
#: en/content/reference/namespaces.adoc:15 en/content/reference/java_interop.adoc:15
#: en/content/reference/other_functions.adoc:17 en/content/reference/vars.adoc:16 en/content/reference/reducers.adoc:15
#: en/content/reference/data_structures.adoc:16 en/content/reference/repl_and_main.adoc:16
#: en/content/reference/agents.adoc:16 en/content/reference/datatypes.adoc:16 en/content/guides/deps_and_cli.adoc:11
#: en/content/guides/weird_characters.adoc:10 en/content/guides/spec.adoc:11 en/content/guides/getting_started.adoc:11
#: en/content/guides/higher_order_functions.adoc:11 en/content/guides/reader_conditionals.adoc:10
#: en/content/guides/learn/hashed_colls.adoc:16 en/content/guides/learn/syntax.adoc:14
#: en/content/guides/learn/flow.adoc:14 en/content/guides/learn/sequential_colls.adoc:16
#: en/content/guides/learn/functions.adoc:16 en/content/guides/destructuring.adoc:11
#: en/content/guides/repl/annex_troubleshooting.adoc:14 en/content/guides/repl/navigating_namespaces.adoc:16
#: en/content/guides/repl/introduction.adoc:14 en/content/guides/repl/data_visualization_at_the_repl.adoc:16
#: en/content/guides/repl/launching_a_basic_repl.adoc:16 en/content/guides/repl/basic_usage.adoc:16
#: en/content/guides/repl/enhancing_your_repl_workflow.adoc:16 en/content/guides/faq.adoc:11
#: en/content/about/spec.adoc:16 en/content/about/dynamic.adoc:16 en/content/about/rationale.adoc:13
#: en/content/about/state.adoc:16 en/content/about/functional_programming.adoc:15
msgid "toc::[]"
msgstr "toc::[]"

#. type: Plain text
#: en/content/reference/metadata.adoc:23 en/content/reference/metadata.adoc:29 en/content/reference/libs.adoc:63
#: en/content/reference/java_interop.adoc:78 en/content/reference/java_interop.adoc:98
#: en/content/reference/java_interop.adoc:111 en/content/reference/java_interop.adoc:133
#: en/content/reference/java_interop.adoc:140 en/content/reference/java_interop.adoc:154
#: en/content/reference/java_interop.adoc:195 en/content/reference/evaluation.adoc:62
#: en/content/reference/evaluation.adoc:73 en/content/community/editing.adoc:71 en/content/community/editing.adoc:85
#: en/content/community/editing.adoc:103 en/content/community/editing.adoc:121 en/content/community/editing.adoc:131
msgid "''''"
msgstr "''''"

#. type: Title ==
#: en/content/reference/deps_and_cli.adoc:216 en/content/reference/java_interop.adoc:275
#, no-wrap
msgid "Aliases"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:1 en/content/guides/learn/functions.adoc:268
#, no-wrap
msgid "Java Interop"
msgstr "Javaとの相互運用"

#. type: Plain text
#: en/content/reference/java_interop.adoc:4
msgid "Rich Hickey 2016-02-25"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:17
#, no-wrap
msgid "Member access"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:25
#, no-wrap
msgid ""
"**(.instanceMember instance args*)**\n"
"**(.instanceMember Classname args*)**\n"
"**(.-instanceField instance)**\n"
"**(Classname/staticMethod args*)**\n"
"**Classname/staticField**\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:38
#, no-wrap
msgid ""
"(.toUpperCase \"fred\")\n"
"-> \"FRED\"\n"
"(.getName String)\n"
"-> \"java.lang.String\"\n"
"(.-x (java.awt.Point. 1 2))\n"
"-> 1\n"
"(System/getProperty \"java.vm.version\")\n"
"-> \"1.6.0_07-b06-57\"\n"
"Math/PI\n"
"-> 3.141592653589793\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:41
msgid ""
"The preferred idiomatic forms for accessing field or method members are given above. The instance member form works "
"for both fields and methods. The instanceField form is preferred for fields and required if both a field and a 0-"
"argument method of the same name exist. They all expand into calls to the dot operator (described below) at "
"macroexpansion time. The expansions are as follows:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:50
#, no-wrap
msgid ""
"(.instanceMember instance args*) ==> (. instance instanceMember args*)\n"
"(.instanceMember Classname args*) ==>\n"
"    (. (identity Classname) instanceMember args*)\n"
"(.-instanceField instance) ==> (. instance -instanceField)\n"
"(Classname/staticMethod args*) ==> (. Classname staticMethod args*)\n"
"Classname/staticField ==> (. Classname staticField)\n"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:52
#, no-wrap
msgid "The Dot special form"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:60
#, no-wrap
msgid ""
"*(_._ instance-expr member-symbol)*\n"
"*(_._ Classname-symbol member-symbol)*\n"
"*(_._ instance-expr -field-symbol)*\n"
"**(_._ instance-expr (method-symbol args*))** or **(_._ instance-expr method-symbol args*)**\n"
"**(_._ Classname-symbol (method-symbol args*))** or **(_._ Classname-symbol method-symbol args*)**\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:62 en/content/reference/java_interop.adoc:117
msgid "Special form."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:64
msgid ""
"The '.' special form is the basis for access to Java. It can be considered a member-access operator, and/or read as "
"'in the scope of'."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:66
msgid ""
"If the first operand is a symbol that resolves to a class name, the access is considered to be to a static member of "
"the named class. Note that nested classes are named EnclosingClass$NestedClass, per the JVM spec. Otherwise it is "
"presumed to be an instance member and the first argument is evaluated to produce the target object."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:68
msgid ""
"For the special case of invoking an instance member on a Class instance, the first argument must be an expression "
"that evaluates to the class instance - note that the preferred form at the top expands `Classname` to `(identity "
"Classname)`."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:70
msgid ""
"If the second operand is a symbol and no args are supplied it is taken to be a field access - the name of the field "
"is the name of the symbol, and the value of the expression is the value of the field, _unless_ there is a no argument "
"public method of the same name, in which case it resolves to a call to the method. If the second operand is a symbol "
"starting with _-_, the member-symbol will resolve only as field access (never as a 0-arity method) and should be "
"preferred when that is the intent."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:72
msgid ""
"If the second operand is a list, or args are supplied, it is taken to be a method call. The first element of the list "
"must be a simple symbol, and the name of the method is the name of the symbol. The args, if any, are evaluated from "
"left to right, and passed to the matching method, which is called, and its value returned. If the method has a void "
"return type, the value of the expression will be _**nil**_. Note that placing the method name in a list with any args "
"is optional in the canonic form, but can be useful to gather args in macros built upon the form."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:74
msgid ""
"Note that boolean return values will be turned into Booleans, chars will become Characters, and numeric primitives "
"will become Numbers unless they are immediately consumed by a method taking a primitive."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:76
msgid ""
"The member access forms given at the top of this section are preferred for use in all cases other than in macros."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:82
#, no-wrap
msgid ""
"*(_.._ instance-expr member+)*\n"
"*(_.._ Classname-symbol member+)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:84
msgid "member => fieldName-symbol or (instanceMethodName-symbol args*)"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:86
msgid ""
"Macro. Expands into a member access (.) of the first member on the first argument, followed by the next member on the "
"result, etc. For instance:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:88
msgid "`(.. System (getProperties) (get \"os.name\"))`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:90
msgid "expands to:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:92
msgid "`(. (. System (getProperties)) (get \"os.name\"))`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:94
msgid ""
"but is easier to write, read, and understand. See also the https://clojure.github.com/clojure/clojure.core-api."
"html#clojure.core/%2d%3e[pass:[->]] macro which can be used similarly:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:96
msgid "`(pass:[->] (System/getProperties) (.get \"os.name\"))`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:100
#, no-wrap
msgid "**(_doto_ instance-expr (instanceMethodName-symbol args*)*)**\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:102
msgid ""
"Macro. Evaluates instance-expr then calls all of the methods/functions with the supplied arguments in succession on "
"the resulting object, returning it."
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:107
#, no-wrap
msgid ""
"(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))\n"
"-> {a=1, b=2}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:115
#, no-wrap
msgid ""
"**(Classname. args*)**\n"
"**(_new_ Classname args*)**\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:119
msgid ""
"The args, if any, are evaluated from left to right, and passed to the constructor of the class named by Classname. "
"The constructed object is returned."
msgstr ""

#. type: Title ===
#: en/content/reference/java_interop.adoc:120
#, no-wrap
msgid "Alternative Macro Syntax"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:123
msgid ""
"As shown, in addition to the canonic special form new, Clojure supports special macroexpansion of symbols containing "
"'.':"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:125
msgid "`(new Classname args*)`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:127
msgid "can be written"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:129
msgid "`(Classname. args*) ;note trailing dot`"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:131
msgid "the latter expanding into the former at macro expansion time."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:135
#, no-wrap
msgid "*(_instance?_ Class expr)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:137
msgid "Evaluates expr and tests if it is an instance of the class. Returns true or false"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:144
#, no-wrap
msgid ""
"*(_set!_ (. instance-expr instanceFieldName-symbol) expr)*\n"
"*(_set!_ (. Classname-symbol staticFieldName-symbol) expr)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:146 en/content/reference/vars.adoc:65
msgid "Assignment special form."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:148
msgid ""
"When the first operand is a field member access form, the assignment is to the corresponding field. If it is an "
"instance field, the instance expr will be evaluated, then the expr."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:150
msgid "In all cases the value of expr is returned."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:152 en/content/reference/vars.adoc:69
msgid ""
"Note - _you cannot assign to function params or local bindings. Only Java fields, Vars, Refs and Agents are mutable "
"in Clojure_."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:156
#, no-wrap
msgid "**(_memfn_ method-name arg-names*)**\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:158
msgid ""
"Macro. Expands into code that creates a fn that expects to be passed an object and any args and calls the named "
"instance method on the object passing the args. Use when you want to treat a Java method as a first-class fn."
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:163
#, no-wrap
msgid ""
"(map (memfn charAt i) [\"fred\" \"ethel\" \"lucy\"] [1 2 3])\n"
"-> (\\r \\h \\y)\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:166
msgid "Note it almost always preferable to do this directly now, with syntax like:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:171
#, no-wrap
msgid ""
"(map #(.charAt %1 %2) [\"fred\" \"ethel\" \"lucy\"] [1 2 3])\n"
"-> (\\r \\h \\y)\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:175
msgid "'''' *(_bean_ obj)*"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:177
msgid ""
"Takes a Java object and returns a read-only implementation of the map abstraction based upon its JavaBean properties."
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:184
#, no-wrap
msgid ""
"(bean java.awt.Color/black)\n"
"-> {:RGB -16777216, :alpha 255, :blue 0, :class java.awt.Color,\n"
"    :colorSpace #object[java.awt.color.ICC_ColorSpace 0x5cb42b \"java.awt.color.ICC_ColorSpace@5cb42b\"],\n"
"    :green 0, :red 0, :transparency 1}\n"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:186
#, no-wrap
msgid "Support for Java in Clojure Library Functions"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:189
msgid ""
"Many of the Clojure library functions have defined semantics for objects of Java types. contains? and get work on "
"Java Maps, arrays, Strings, the latter two with integer keys. count works on Java Strings, Collections and arrays. "
"nth works on Java Strings, Lists and arrays. seq works on Java reference arrays, Iterables and Strings. Since much of "
"the rest of the library is built upon these functions, there is great support for using Java objects in Clojure "
"algorithms."
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:190
#, no-wrap
msgid "Implementing Interfaces and Extending Classes"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:193
msgid ""
"Clojure supports the dynamic creation of objects that implement one or more interfaces and/or extend a class with the "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/proxy[proxy] macro. The resulting objects are of "
"an anonymous class. You can also generate statically-named classes and .class files with https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/gen-class[gen-class]. As of Clojure 1.2, https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/reify[reify] is also available for implementing interfaces."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:197
#, no-wrap
msgid "*( _proxy_ [class-and-interfaces] [args] fs+)*\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:201
msgid ""
"class-and-interfaces - a vector of class names + args - a (possibly empty) vector of arguments to the superclass "
"constructor. + f => (name [params*] body) or (name ([params*] body) ([params+] body) ...)"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:203
msgid "Macro"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:205
msgid ""
"Expands to code which creates a instance of a proxy class that implements the named class/interface(s) by calling the "
"supplied fns. A single class, if provided, must be first. If not provided it defaults to Object. The interfaces names "
"must be valid interface types. If a method fn is not provided for a class method, the superclass method will be "
"called. If a method fn is not provided for an interface method, an UnsupportedOperationException will be thrown "
"should it be called. Method fns are closures and can capture the environment in which proxy is called. Each method fn "
"takes an additional implicit first arg, which is bound to this. Note that while method fns can be provided to "
"override protected methods, they have no other access to protected members, nor to super, as these capabilities "
"cannot be proxied."
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:206
#, no-wrap
msgid "Arrays"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:209
msgid ""
"Clojure supports the creation, reading and modification of Java arrays. It is recommended that you limit use of "
"arrays to interop with Java libraries that require them as arguments or use them as return values."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:211
msgid ""
"Note that many other Clojure functions work with arrays such as via the <<sequences#,seq library>>. The functions "
"listed here exist for initial creation of arrays, or to support mutation or higher performance operations on arrays."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:219
msgid ""
"Create array from existing collection: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"aclone[aclone] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/amap[amap] https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/to-array[to-array] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/to-array-2d[to-array-2d] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/into-"
"array[into-array] Multi-dimensional array support: https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/aget[aget] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/aset[aset] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/to-array-2d[to-array-2d] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/make-array[make-array] Type-specific array constructors: https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/boolean-array[boolean-array] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/byte-array[byte-array] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/char-array[char-array] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/double-array[double-"
"array] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/float-array[float-array] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/int-array[int-array] https://clojure.github.io/clojure/clojure."
"core-api.html#clojure.core/long-array[long-array] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/object-array[object-array] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/short-"
"array[short-array] Primitive array casts: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"booleans[booleans] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/bytes[bytes] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/chars[chars] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/doubles[doubles] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"floats[floats] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/ints[ints] https://clojure.github."
"io/clojure/clojure.core-api.html#clojure.core/longs[longs] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/shorts[shorts] Mutate an array: https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/aset[aset] Process an existing array: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"aget[aget] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/alength[alength] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/amap[amap] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/areduce[areduce]"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:221
#, no-wrap
msgid "Type Hints"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:224
msgid ""
"Clojure supports the use of type hints to assist the compiler in avoiding reflection in performance-critical areas of "
"code. Normally, one should avoid the use of type hints until there is a known performance bottleneck. Type hints are "
"<<metadata#_metadata_reader_macros,metadata tags>> placed on symbols or expressions that are consumed by the "
"compiler. They can be placed on function parameters, let-bound names, var names (when defined), and expressions:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:229
#, no-wrap
msgid ""
"(defn len [x]\n"
"  (.length x))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:232
#, no-wrap
msgid ""
"(defn len2 [^String x]\n"
"  (.length x))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:239
#, no-wrap
msgid ""
"user=> (time (reduce + (map len (repeat 1000000 \"asdf\"))))\n"
"\"Elapsed time: 3007.198 msecs\"\n"
"4000000\n"
"user=> (time (reduce + (map len2 (repeat 1000000 \"asdf\"))))\n"
"\"Elapsed time: 308.045 msecs\"\n"
"4000000\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:242
msgid ""
"Once a type hint has been placed on an identifier or expression, the compiler will try to resolve any calls to "
"methods thereupon at compile time. In addition, the compiler will track the use of any return values and infer types "
"for their use and so on, so very few hints are needed to get a fully compile-time resolved series of calls. Note that "
"type hints are not needed for static members (or their return values!) as the compiler always has the type for "
"statics."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:244
msgid ""
"There is a pass:[*warn-on-reflection*] flag (defaults to false) which will cause the compiler to warn you when it "
"can't resolve to a direct call:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:249
#, no-wrap
msgid ""
"(set! *warn-on-reflection* true)\n"
"-> true\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:253
#, no-wrap
msgid ""
"(defn foo [s] (.charAt s 1))\n"
"-> Reflection warning, line: 2 - call to charAt can't be resolved.\n"
"-> #user/foo\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:256
#, no-wrap
msgid ""
"(defn foo [^String s] (.charAt s 1))\n"
"-> #user/foo\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:259
msgid "For function return values, the type hint can be placed before the arguments vector:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:263
#, no-wrap
msgid "(defn hinted-single ^String [])\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:265
#, no-wrap
msgid "-> #user/hinted-single\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:270
#, no-wrap
msgid ""
"(defn hinted\n"
"  (^String [])\n"
"  (^Integer [a])\n"
"  (^java.util.List [a & args]))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:272
#, no-wrap
msgid "-> #user/hinted\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:281
msgid ""
"Clojure provides aliases for primitive Java types and arrays which do not have typical representations as Java class "
"names.  The types are represented according to the specification of http://docs.oracle.com/javase/specs/jvms/se7/html/"
"jvms-4.html#jvms-4.3.2-200[Java Field Descriptors].  For example, byte arrays (byte-array []) have a type of \"[B\"."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:283
msgid "int - A primitive int"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:284
msgid "ints - An int array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:285
msgid "long - A primitive long"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:286
msgid "longs - A long array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:287
msgid "float - A primitive float"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:288
msgid "floats - A float array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:289
msgid "double - A primitive double"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:290
msgid "doubles - A double array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:291
msgid "void - A void return"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:292
msgid "short - A primitive short"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:293
msgid "shorts - A short array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:294
msgid "boolean - A primitive boolean"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:295
msgid "booleans - A boolean array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:296
msgid "byte - A primitive byte"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:297
msgid "bytes - A byte array"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:298
msgid "char - A primitive character"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:299
msgid "chars - A character array"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:301
#, no-wrap
msgid "Support for Java Primitives"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:304
msgid ""
"Clojure has support for high-performance manipulation of, and arithmetic involving, Java primitive types in local "
"contexts. All Java primitive types are supported: int, float, long, double, boolean, char, short, and byte."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:306
msgid ""
"_**let**_/_**loop**_-bound locals can be of primitive types, having the inferred, possibly primitive type of their "
"init-form."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:307
msgid ""
"_**recur**_ forms that rebind primitive locals do so without boxing, and do type-checking for same primitive type."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:308
msgid "Arithmetic (+,-,*,/,inc,dec,<,<=,>,>= etc) is overloaded for primitive types where semantics are same."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:309
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/aget[aget] / https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/aset[aset] are overloaded for arrays of primitives"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:310
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/aclone[aclone], https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/alength[alength] functions for arrays of primitives"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:311
msgid ""
"constructor functions for primitive arrays: https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/"
"float-array[float-array], https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/int-array[int-array], "
"etc."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:312
msgid "Type hints for primitive arrays - +^ints, ^floats+, etc."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:313
msgid ""
"Coercion ops https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/int[int], https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/float[float], etc. produce primitives when consumer can take primitive"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:314
msgid ""
"The https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/num[num] coercion function boxes primitives "
"to force generic arithmetic"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:315
msgid ""
"Array cast functions https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/ints[ints] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/longs[longs], etc. which produce +int[]+, +long[]+, etc."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:316
msgid ""
"A set of \"unchecked\" operations for utmost performing, but potentially unsafe, integer (int/long) ops: https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/unchecked-multiply[unchecked-multiply] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/unchecked-dec[unchecked-dec] https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/unchecked-inc[unchecked-inc] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/unchecked-negate[unchecked-negate] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/unchecked-add[unchecked-add] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/unchecked-"
"subtract[unchecked-subtract] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/unchecked-"
"remainder[unchecked-remainder] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/unchecked-"
"divide[unchecked-divide]"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:317
msgid ""
"A dynamic var to automatically swap safe operations with unchecked operations: https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/%2Aunchecked-math%2A[pass:[*unchecked-math*]]"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:318
msgid ""
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/amap[amap] and https://clojure.github.io/clojure/"
"clojure.core-api.html#clojure.core/areduce[areduce] macros for functionally (i.e. non-destructively) processing one "
"or more arrays in order to produce a new array or aggregate value respectively."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:320
msgid "Rather than write this Java:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:328
#, no-wrap
msgid ""
"static public float asum(float[] xs){\n"
"  float ret = 0;\n"
"  for(int i = 0; i < xs.length; i++)\n"
"    ret += xs[i];\n"
"  return ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:331
msgid "you can write this Clojure:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:337
#, no-wrap
msgid ""
"(defn asum [^floats xs]\n"
"  (areduce xs i ret (float 0)\n"
"    (+ ret (aget xs i))))\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:340
msgid "and the resulting code is exactly the same speed (when run with java -server)."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:342
msgid ""
"The best aspect of this is that you need not do anything special in your initial coding. Quite often these "
"optimizations are unneeded. Should a bit of code be a bottleneck, you can speed it up with minor adornment:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:350
#, no-wrap
msgid ""
"(defn foo [n]\n"
"  (loop [i 0]\n"
"    (if (< i n)\n"
"      (recur (inc i))\n"
"      i)))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:354
#, no-wrap
msgid ""
"(time (foo 100000))\n"
"\"Elapsed time: 0.391 msecs\"\n"
"100000\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:361
#, no-wrap
msgid ""
"(defn foo2 [n]\n"
"  (let [n (int n)]\n"
"    (loop [i (int 0)]\n"
"      (if (< i n)\n"
"        (recur (inc i))\n"
"        i))))\n"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:365
#, no-wrap
msgid ""
"(time (foo2 100000))\n"
"\"Elapsed time: 0.084 msecs\"\n"
"100000\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:368
msgid ""
"Functions have limited support for primitive arguments and return type: type hints for `long` and `double` (only "
"these) generate primitive-typed overloads. Note that this capability is restricted to functions of arity no greater "
"than 4."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:370
msgid "Thus a function defined as"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:374
#, no-wrap
msgid "(defn foo ^long [^long n])\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:377
msgid ""
"both takes and returns values of primitive type `long` (invocations with a boxed argument and indeed any object "
"result in a cast and delegation to the primitive-typed overload)."
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:378
#, no-wrap
msgid "Coercions"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:381
msgid ""
"At times it is necessary to have a value of a particular primitive type. These coercion functions yield a value of "
"the indicated type as long as such a coercion is possible: https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/bigdec[bigdec] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/bigint[bigint] "
"https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/boolean[boolean] https://clojure.github.io/"
"clojure/clojure.core-api.html#clojure.core/byte[byte] https://clojure.github.io/clojure/clojure.core-api.html#clojure."
"core/char[char] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/double[double] https://clojure."
"github.io/clojure/clojure.core-api.html#clojure.core/float[float] https://clojure.github.io/clojure/clojure.core-api."
"html#clojure.core/int[int] https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/long[long] https://"
"clojure.github.io/clojure/clojure.core-api.html#clojure.core/num[num] https://clojure.github.io/clojure/clojure.core-"
"api.html#clojure.core/short[short]"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:383
#, no-wrap
msgid "Some optimization tips"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:386
msgid ""
"All arguments are passed to Clojure fns as objects, so there's no point to putting arbitrary primitive type hints on "
"fn args (excepting primitive array type hints, and long and double as noted). Instead, use the let technique shown to "
"place args in primitive locals if they need to participate in primitive arithmetic in the body."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:387
msgid "(let [foo (int bar)] ...) is the correct way to get a primitive local. Do not use ^Integer etc."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:388
msgid ""
"Don't rush to unchecked math unless you want truncating operations. HotSpot does a good job at optimizing the "
"overflow check, which will yield an exception instead of silent truncation. On a typical example, that has about a 5% "
"difference in speed - well worth it. Also, people reading your code don't know if you are using unchecked for "
"truncation or performance - best to reserve it for the former and comment if the latter."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:389
msgid ""
"There's usually no point in trying to optimize an outer loop, in fact it can hurt you as you'll be representing "
"things as primitives which just have to be re-boxed in order to become args to the inner call. The only exception is "
"reflection warnings - you must get rid of them in any code that gets called frequently."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:390
msgid ""
"Almost every time someone presents something they are trying to optimize with hints, the faster version has far fewer "
"hints than the original. If a hint doesn't improve things in the end - take it out."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:391
msgid ""
"Many people seem to presume only the unchecked- ops do primitive arithmetic - not so. When the args are primitive "
"locals, regular + and * etc do primitive math with an overflow check - fast _and_ safe."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:392
msgid ""
"So, the simplest route to fast math is to leave the operators alone and just make sure the source literals and locals "
"are primitive. Arithmetic on primitives yields primitives. If you've got a loop (which you probably do if you need to "
"optimize) make sure the loop locals are primitives first - then if you accidentally are producing a boxed "
"intermediate result you'll get an error on recur. Don't solve that error by coercing your intermediate result, "
"instead, figure out what argument or local is not primitive."
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:393
#, no-wrap
msgid "Simple XML Support"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:395
msgid ""
"Included with the distribution is simple XML support, found in the src/xml.clj file. All names from this file are in "
"the xml namespace."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:398
msgid "'''' *(_parse_ source)*"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:400
msgid ""
"Parses and loads the source, which can be a File, InputStream or String naming a URI. Returns a tree of the xml/"
"element struct-map, which has the keys :tag, :attrs, and :content. and accessor fns tag, attrs, and content."
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:405
#, no-wrap
msgid ""
"(xml/parse \"/Users/rich/dev/clojure/build.xml\")\n"
"-> {:tag :project, :attrs {:name \"clojure\", :default \"jar\"}, :content [{:tag :description, ...\n"
msgstr ""

#. type: Title ==
#: en/content/reference/java_interop.adoc:407
#, no-wrap
msgid "Calling Clojure From Java"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:410
msgid ""
"The https://clojure.github.io/clojure/javadoc[clojure.java.api] package provides a minimal interface to bootstrap "
"Clojure access from other JVM languages. It does this by providing:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:412
msgid ""
"The ability to use Clojure's namespaces to locate an arbitrary var, returning the var's clojure.lang.IFn interface."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:413
msgid "A convenience method read for reading data using Clojure's edn reader"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:415
msgid ""
"IFns provide complete access to Clojure's APIs. You can also access any other library written in Clojure, after "
"adding either its source or compiled form to the classpath."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:417
msgid "The public Java API for Clojure consists of the following classes and interfaces:"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:419
msgid "https://clojure.github.io/clojure/javadoc/clojure/java/api/Clojure.html[clojure.java.api.Clojure]"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:420
msgid "https://clojure.github.io/clojure/javadoc/clojure/lang/IFn.html[clojure.lang.IFn]"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:422
msgid ""
"All other Java classes should be treated as implementation details, and applications should avoid relying on them."
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:424
msgid "To lookup and call a Clojure function:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:428
#, no-wrap
msgid ""
"IFn plus = Clojure.var(\"clojure.core\", \"+\");\n"
"plus.invoke(1, 2);\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:430
msgid "Functions in clojure.core are automatically loaded. Other namespaces can be loaded via require:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:434
#, no-wrap
msgid ""
"IFn require = Clojure.var(\"clojure.core\", \"require\");\n"
"require.invoke(Clojure.read(\"clojure.set\"));\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:436
msgid "IFns can be passed to higher order functions, e.g. the example below passes plus to read:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:441
#, no-wrap
msgid ""
"IFn map = Clojure.var(\"clojure.core\", \"map\");\n"
"IFn inc = Clojure.var(\"clojure.core\", \"inc\");\n"
"map.invoke(inc, Clojure.read(\"[1 2 3]\"));\n"
msgstr ""

#. type: Plain text
#: en/content/reference/java_interop.adoc:443
msgid ""
"Most IFns in Clojure refer to functions. A few, however, refer to non-function data values. To access these, use "
"deref instead of fn:"
msgstr ""

#. type: delimited block -
#: en/content/reference/java_interop.adoc:448
#, no-wrap
msgid ""
"IFn printLength = Clojure.var(\"clojure.core\", \"*print-length*\");\n"
"IFn deref = Clojure.var(\"clojure.core\", \"deref\");\n"
"deref.invoke(printLength);\n"
msgstr ""
