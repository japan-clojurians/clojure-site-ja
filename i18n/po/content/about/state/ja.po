# Japanese translations for clojure-site-ja package
# Copyright (C) 2016 Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# Automatically generated, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2018-03-31 17:24+0900\n"
"PO-Revision-Date: 2017-04-02 16:44+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: en/content/reference/metadata.adoc:4 en/content/reference/protocols.adoc:4 en/content/reference/sequences.adoc:4
#: en/content/reference/multimethods.adoc:4 en/content/reference/libs.adoc:4 en/content/reference/transients.adoc:4
#: en/content/reference/compilation.adoc:4 en/content/reference/other_libraries.adoc:4
#: en/content/reference/documentation.adoc:4 en/content/reference/macros.adoc:4 en/content/reference/transducers.adoc:4
#: en/content/reference/refs.adoc:4 en/content/reference/lazy.adoc:4 en/content/reference/namespaces.adoc:4
#: en/content/reference/lisps.adoc:4 en/content/reference/evaluation.adoc:4 en/content/reference/other_functions.adoc:4
#: en/content/reference/reducers.adoc:4 en/content/reference/data_structures.adoc:4 en/content/reference/atoms.adoc:4
#: en/content/reference/repl_and_main.adoc:4 en/content/reference/agents.adoc:4 en/content/reference/datatypes.adoc:4
#: en/content/community/libraries.adoc:4 en/content/community/license.adoc:4 en/content/community/downloads_older.adoc:4
#: en/content/community/downloads.adoc:4 en/content/community/swag.adoc:4 en/content/404.adoc:4
#: en/content/privacy.adoc:4 en/content/search.adoc:4 en/content/about/spec.adoc:4
#: en/content/about/concurrent_programming.adoc:4 en/content/about/lisp.adoc:4 en/content/about/jvm_hosted.adoc:4
#: en/content/about/runtime_polymorphism.adoc:4 en/content/about/dynamic.adoc:4 en/content/about/features.adoc:4
#: en/content/about/rationale.adoc:4 en/content/about/state.adoc:4 en/content/about/clojurescript.adoc:4
#: en/content/about/functional_programming.adoc:4 en/content/about/clojureclr.adoc:4
msgid "Rich Hickey 2015-01-01"
msgstr "Rich Hickey 2015-01-01"

#. type: Plain text
#: en/content/reference/metadata.adoc:15 en/content/reference/protocols.adoc:15 en/content/reference/sequences.adoc:15
#: en/content/reference/multimethods.adoc:15 en/content/reference/libs.adoc:16 en/content/reference/transients.adoc:16
#: en/content/reference/compilation.adoc:16 en/content/reference/other_libraries.adoc:16
#: en/content/reference/macros.adoc:15 en/content/reference/transducers.adoc:15 en/content/reference/refs.adoc:15
#: en/content/reference/lazy.adoc:12 en/content/reference/reader.adoc:13 en/content/reference/special_forms.adoc:15
#: en/content/reference/namespaces.adoc:15 en/content/reference/java_interop.adoc:15
#: en/content/reference/other_functions.adoc:17 en/content/reference/vars.adoc:16 en/content/reference/reducers.adoc:15
#: en/content/reference/data_structures.adoc:16 en/content/reference/repl_and_main.adoc:16
#: en/content/reference/agents.adoc:16 en/content/reference/datatypes.adoc:16 en/content/guides/weird_characters.adoc:10
#: en/content/guides/spec.adoc:11 en/content/guides/getting_started.adoc:11
#: en/content/guides/reader_conditionals.adoc:10 en/content/guides/destructuring.adoc:11 en/content/guides/faq.adoc:11
#: en/content/about/spec.adoc:16 en/content/about/dynamic.adoc:16 en/content/about/rationale.adoc:13
#: en/content/about/state.adoc:16 en/content/about/functional_programming.adoc:15
msgid "toc::[]"
msgstr "toc::[]"

#. type: Title ==
#: en/content/reference/transients.adoc:75 en/content/guides/comparators.adoc:12 en/content/about/state.adoc:74
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#. type: Title =
#: en/content/about/state.adoc:1
#, no-wrap
msgid "Values and Change: Clojure's approach to Identity and State"
msgstr "値と変更: Clojureのアイデンティティと状態に対するアプローチ"

#. type: Plain text
#: en/content/about/state.adoc:18
msgid ""
"Many people come to Clojure from an imperative language and find themselves out of their element when faced with "
"Clojure's approach to doing things, while others are coming from a more functional background and assume that once "
"they leave Clojure's functional subset, they will be faced with the same story re: state as is found in Java. This "
"essay intends to illuminate Clojure's approach to the problems faced by imperative and functional programs in "
"modeling the world."
msgstr ""
"命令型言語からClojureに来た人の多くは、Clojureでのアプローチのしかたに直面して勝手が違うことに気づく。一方、より関数型"
"の背景を持って来た人は、ひとたびClojureの関数型のサブセットを離れれば、Javaで見られるような状態と同じような話に直面す"
"ることになると想定する。この文章は、命令型と関数型のプログラムが世界をモデリングする際に直面する問題に対するClojureの"
"アプローチを明らかにすることを意図している。"

#. type: Title ==
#: en/content/about/state.adoc:19
#, no-wrap
msgid "Imperative programming"
msgstr "命令型プログラミング"

#. type: Plain text
#: en/content/about/state.adoc:22
msgid ""
"An imperative program manipulates its world (e.g. memory) directly. It is founded on a now-unsustainable single-"
"threaded premise - that the world is stopped while you look at or change it. You say \"do this\" and it happens, "
"\"change that\" and it changes. Imperative programming languages are oriented around saying do this/do that, and "
"changing memory locations."
msgstr ""
"命令型のプログラムは世界(例えばメモリ)を直接操作する。それは今では維持できないシングルスレッドという前提――世界を観察し"
"たり変更したりする間、世界は停止している――に基づいている。「これをせよ」と言えばそれは起こり、「あれを変更せよ」と言え"
"ばそれは変化する。命令型プログラミング言語は、これをせよ/あれをせよと言ってメモリロケーションを変更することを指向して"
"いる。"

#. type: Plain text
#: en/content/about/state.adoc:24
msgid ""
"This was never a great idea, even before multithreading. Add concurrency and you have a real problem, because \"the "
"world is stopped\" premise is simply no longer true, and restoring that illusion is extremely difficult and error-"
"prone. Multiple participants, each of which acts as though they were omnipotent, must somehow avoid destroying the "
"presumptions and effects of the others. This requires mutexes and locks, to cordon off areas for each participant to "
"manipulate, and a lot of overhead to propagate changes to shared memory so they are seen by other cores. It doesn't "
"work very well."
msgstr ""
"これはマルチスレッド以前でさえ素晴らしいアイディアではなかった。並行処理が加わると現実の問題になる、というのも「世界は"
"停止している」という前提はもはや全く正しくなく、その幻想を取り戻すのは極めて困難でエラーを引き起こしがちだからだ。複数"
"の参加者が、それぞれ全能であるかのように振る舞う中で、他者の仮定や努力の成果を破壊してしまうのを何とかして避けなければ"
"ならない。これには、個々の参加者が操作する領域を遮断するためにミューテックスやロックが必要となり、他のコアからも見える"
"ように共有メモリの変更を伝播させる大きなオーバーヘッドを要する。これはあまり上手くいかない。"

#. type: Title ==
#: en/content/about/state.adoc:25
#, no-wrap
msgid "Functional programming"
msgstr "関数型プログラミング"

#. type: Plain text
#: en/content/about/state.adoc:28
msgid ""
"Functional programming takes a more mathematical view of the world, and sees programs as functions that take certain "
"values and produce others. Functional programs eschew the external 'effects' of imperative programs, and thus become "
"easier to understand, reason about, and test, since the activity of functions is completely local. To the extent a "
"portion of a program is purely functional, concurrency is a non-issue, as there is simply no change to coordinate."
msgstr ""
"関数型プログラミングはより数学的に世界を捉え、プログラムは特定の値を取って別の値を生み出す関数だとみなす。関数型のプロ"
"グラムは、命令型のプログラムが持つ外界への「効果」を避けるため、理解しやすく、推論しやすく、テストしやすいものになる、"
"というのも関数の活動は完全にローカルなものだからだ。プログラムが純粋に関数型である限り、並行処理は問題にならない。なぜ"
"なら協調させるべき変更が全く存在しないからだ。"

#. type: Title ==
#: en/content/about/state.adoc:29
#, no-wrap
msgid "Working Models and Identity"
msgstr "ワーキングモデルとアイデンティティ"

#. type: Plain text
#: en/content/about/state.adoc:32
msgid ""
"While some programs are merely large functions, e.g. compilers or theorem provers, many others are not - they are "
"more like working models, and as such need to support what I'll refer to in this discussion as *_identity_.* By "
"identity I mean *_a stable logical entity associated with a series of different values over time_*. Models need "
"identity for the same reasons humans need identity - to represent the world. How could it work if identities like "
"'today' or 'America' had to represent a single constant value for all time? Note that by identities I don't mean "
"names (I call my mother Mom, but you wouldn't)."
msgstr ""
"一部のプログラムは大きな関数(例えばコンパイラや定理証明器)だが、その他の多くのプログラムはそうではない――むしろワーキン"
"グモデルのようなもので、私がこの議論で *_アイデンティティ_* と呼ぶものをサポートする必要がある。アイデンティティという"
"のは *_時間とともに異なる一連の値と結び付いた、安定した論理的なエンティティ_* のことを意味している。人間にアイデンティ"
"ティが必要であるのと同様な理由で、世界を表現するためにモデルにはアイデンティティが必要だ。「今日」や「アメリカ」のよう"
"なアイデンティティが常に単一の定数値を表さなければならないとしたらどうなるだろう? アイデンティティというのは名前のこと"
"を意味しているわけではないことに注意が必要だ(私は自分の母親のことをママと呼ぶが、あなたはそうではないかもしれない)。"

#. type: Plain text
#: en/content/about/state.adoc:34
msgid ""
"So, for this discussion, an identity is an entity that has a state, which is its value at a point in time. And *_a "
"value is something that doesn't change_*. 42 doesn't change. June 29th 2008 doesn't change. Points don't move, dates "
"don't change, no matter what some bad class libraries may cause you to believe. Even aggregates are values. The set "
"of my favorite foods doesn't change, i.e. if I prefer different foods in the future, that will be a different set."
msgstr ""
"というわけで、この議論では、アイデンティティとは、ある時点での値としての状態を持つエンティティのことだ。そして *_値と"
"は変化しないもののことだ_* 。42は変化しない。2008年6月29日は変化しない。点は移動することがないし、ひどいクラスライブラ"
"リが何を信じさせようとも、日付は変化することがない。集合体(aggregate)でさえ値だ。私の好きな食べ物の集合は変化しない、"
"つまり私が将来、別の食べ物を好むようになったとしたら、それは別の集合ということだ"

#. type: Plain text
#: en/content/about/state.adoc:36
msgid ""
"Identities are mental tools we use to superimpose continuity on a world which is constantly, functionally, creating "
"new values of itself."
msgstr ""
"アイデンティティは、絶えず関数的に自身の新たな値を生み出していく世界を連続性のあるものとして捉えるためのメンタルツール"
"だ。"

#. type: Title ==
#: en/content/about/state.adoc:37
#, no-wrap
msgid "Object Oriented programming (OO)"
msgstr "オブジェクト指向プログラミング(OO)"

#. type: Plain text
#: en/content/about/state.adoc:40
msgid ""
"OO is, among other things, an attempt to provide tools for modeling identity and state in programs (as well as "
"associating behavior with state, and hierarchical classification, both ignored here). OO typically unifies identity "
"and state, i.e. an object (identity) is a pointer to the memory that contains the value of its state. There is no way "
"to obtain the state independent of the identity other than copying it. There is no way to observe a stable state "
"(even to copy it) without blocking others from changing it. There is no way to associate the identity's state with a "
"different value other than in-place memory mutation. In other words, *_typical OO has imperative programming baked "
"into it!_* OO doesn't have to be this way, but, usually, it is (Java/C++/Python/Ruby etc)."
msgstr ""
"OOとは、何よりも、プログラムにおいてアイデンティティと状態をモデリングするためのツールを提供する試みだ(振る舞いを状態"
"に関連付けることや階層的な分類はどちらもここでは無視する)。OOは典型的にはアイデンティティと状態を統合している、つまり"
"オブジェクト(アイデンティティ)が状態の値を保持するメモリに対するポインタになっている。コピーすることなくアイデンティ"
"ティから独立した状態を取得する方法はない。変更されるのをブロックすることなく安定した状態を観察する方法も(コピーする方"
"法さえ)ない。置き換えによるメモリ変更以外でアイデンティティの状態に異なる値を関連付ける方法もない。言い換えれば、 *_典"
"型的なOOは命令型プログラミングを焼き込んでいる!_* OOはこのようである必要はないのだが、たいていそうなっている(Java/C++/"
"Python/Rubyなど)。"

#. type: Plain text
#: en/content/about/state.adoc:42
msgid ""
"People accustomed to OO conceive of their programs as mutating the values of objects. They understand the true notion "
"of a value, say, 42, as something that would never change, but usually don't extend that notion of value to their "
"object's state. That is a failure of their programming language. These languages use the same constructs for modeling "
"values as they do for identities, objects, and default to mutability, causing all but the most disciplined "
"programmers to create many more identities than they should, creating identities out of things that should be values "
"etc."
msgstr ""
"OOに慣れている人はプログラムをオブジェクトの値を変更するものと考えている。彼らは値(例えば42)の真の観念は決して変わるこ"
"とのないものだと理解しているが、たいていその値の観念をオブジェクトの状態に拡大することはない。それは彼らのプログラミン"
"グ言語の欠陥だ。そうした言語は、アイデンティティやオブジェクトのために使うのと同じ構造を値のモデリングのために利用し、"
"ミュータブルをデフォルトとしており、最も熟練のプログラマ以外の誰もが必要以上に多くのアイデンティティを作ってしまう原因"
"となり、値その他であるべきものからアイデンティティを作っている。"

#. type: Title ==
#: en/content/about/state.adoc:43
#, no-wrap
msgid "Clojure programming"
msgstr "Clojureプログラミング"

#. type: Plain text
#: en/content/about/state.adoc:46
msgid ""
"There is another way, and that is to separate identity and state (once again, indirection saves the day in "
"programming). We need to move away from a notion of state as \"the content of this memory block\" to one of \"the "
"*_value_* currently associated with this identity\". Thus an identity can be in different states at different times, "
"but _the state itself doesn't change_. That is, an identity is not a state, an identity *_has_* a state. Exactly one "
"state at any point in time. And that state is a true value, i.e. it never changes. If an identity appears to change, "
"it is because it becomes associated with different state values over time. This is the Clojure model."
msgstr ""
"方法は他にもあり、それはアイデンティティと状態を分離することだ(再び、間接化がプログラミングにおける困難から救ってくれ"
"る)。私たちは、状態の観念を「このメモリブロックの中身」から離れて「このアイデンティティに現在関連付けられている *_値"
"_* 」に変える必要がある。したがって、アイデンティティは異なる時点で異なる状態をとりうるが、 _状態自身が変化することは"
"ない_ 。つまり、アイデンティティが状態なのではなく、アイデンティティが状態を *_持っている_* のだ。あらゆる時点において"
"ちょうど1つだけの状態。そしてその状態は真の値だ、つまり決して変わることがない。アイデンティティが変化しているように見"
"えたとしても、それは時間とともに異なる状態の値が関連付けられるからだ。これがClojureのモデルだ。"

#. type: Plain text
#: en/content/about/state.adoc:48
msgid ""
"In Clojure's model, value calculation is purely functional. Values never change. New values are functions of old, not "
"mutations. But logical identity is well supported, via atomic references to values (<<xref/../../reference/refs#,"
"Refs>> and <<xref/../../reference/agents#,Agents>>). Changes to references are controlled/coordinated by the system - "
"i.e. cooperation is not optional and not manual. The world moves forward due to the cooperative efforts of its "
"participants and the programming language/system, Clojure, is in charge of world consistency management. The value of "
"a reference (state of an identity) is always observable without coordination, and freely shareable between threads."
msgstr ""
"Clojureのモデルでは、値の計算は純粋に関数型だ。値は決して変化しない。新しい値は古い値の関数であり、古い値を変更したも"
"のではない。しかし論理的なアイデンティティは値に対するアトミックな参照(<<xref/../../reference/refs#,Refs>> と "
"<<xref/../../reference/agents#,Agents>>)としてしっかりサポートされている。参照に対する変更はシステムによって制御/調整"
"されている、つまり協調させることは選択的でも手動でもない。世界は参加者の協調的な努力によって前進し、プログラミング言"
"語/システムであるClojureが世界の一貫性の管理を担っている。参照の値(アイデンティティの状態)は常に調整なく観察することが"
"でき、スレッド間で自由に共有できる"

#. type: Plain text
#: en/content/about/state.adoc:50
msgid ""
"It is worth constructing programs this way even when there is only one participant (thread). Programs are easier to "
"understand/test when functional value calculation is independent of identity/value association. And it's easy to add "
"other participants when they are (inevitably) needed."
msgstr ""
"参加者(スレッド)がただ1つしかないときでも、このような方法でプログラムを構築する価値はある。関数の値の計算がアイデン"
"ティティ/値の関連から独立していると、プログラムはより理解しやすくテストしやすくなる。そして(必然的に)必要になったとき"
"に他の参加者を追加するのも簡単だ。"

#. type: Title ===
#: en/content/about/state.adoc:51
#, no-wrap
msgid "Concurrency"
msgstr "並行処理"

#. type: Plain text
#: en/content/about/state.adoc:54
msgid ""
"Dealing with concurrency means giving up the illusion of omnipotence. A program must recognize there will be other "
"participants, and the world will keep changing. So a program must understand that if it observes the values of the "
"states of some identities, the best it can get is a snapshot, as they can subsequently acquire new states. But often "
"that is good enough for decision making or reporting purposes. We humans do quite well with the snapshots provided by "
"our sensory systems. The nice thing is any such state value won't change in hand during the processing, as it is "
"immutable."
msgstr ""
"並行処理に取り組むということは、全能という幻想をあきらめることを意味する。他の参加者が存在しうるし、世界は変化し続ける"
"ということをプログラムは認識しなければならない。そのため、何らかのアイデンティティの状態の値を観察することで得られるの"
"はせいぜいスナップショットだということをプログラムは理解しなければならない、というのもそれらのアイデンティティは後に新"
"たな値を取りうるからだ。しかし、多くの場合には決定を下したりレポートしたりする目的にはそれで十分だ。私たち人間は自らの"
"感覚系から得られるスナップショットで上手くやっている。そうした状態の値はイミュータブルなので、処理中に手元で変化するこ"
"とがないのが良いところだ。"

#. type: Plain text
#: en/content/about/state.adoc:56
msgid ""
"On the other hand, changing state to a new value requires access to the 'current' value and the identity. Clojure's "
"Refs and Agents handle this automatically. In the case of Refs, any interaction you do must occur within a "
"transaction (else Clojure will throw an exception), all such interaction will see a consistent view of the world as "
"of a point in time, and no changes will proceed unless the states to be changed haven't been changed by other "
"participants in the meantime. Transactions support synchronous change to multiple Refs. Agents, OTOH, offer "
"asynchronous change to a single reference. You pass a function and values, and, at some point in the future, that "
"function will be passed the current state of the Agent and the return value of the function will become the Agent's "
"new state."
msgstr ""
"一方で、状態を新しい値に変更するには「現在の」値とアイデンティティにアクセスする必要がある。ClojureのRefとAgentはこれ"
"を自動的に行う。Refの場合には、いかなる相互作用もトランザクション内で行わなければならず(そうでなければClojureは例外を"
"投げる)、そうしたすべての相互作用はある時点での世界の一貫したビューを見ることになり、変更されるべき状態が途中で他の参"
"加者に変更されていないのでなければいかなる変更も生じない。トランザクションは複数のRefに対する同期的な変更をサポートし"
"ている。他方、Agentは単一の参照に対する非同期的な変更を提供している。関数と値を渡すと、未来のある時点でその関数にAgent"
"の現在の状態が渡され、関数の戻り値がAgentの新しい状態になる。"

#. type: Plain text
#: en/content/about/state.adoc:58
msgid ""
"In all cases the program will see stable views of the values in the world, as those values can't change, and sharing "
"them among cores is fine. The trick is, \"values never change\" means that making new values from old ones must be "
"efficient, and it is in Clojure, due to its persistent data structures. They allow you to finally follow the oft-"
"proffered advice to favor immutability. So you set the state of an identity to a new state by reading its current "
"value, calling a pure function on that value to create a new value, and setting that value as the new state. These "
"composite operations are made easy and atomic by the https://clojure.github.com/clojure/clojure.core-api.html#clojure."
"core/alter[alter], https://clojure.github.com/clojure/clojure.core-api.html#clojure.core/commute[commute] and https://"
"clojure.github.com/clojure/clojure.core-api.html#clojure.core/send[send] functions."
msgstr ""
"いずれの場合でも、プログラムは世界にある値の安定したビューを見ることになる、というのもそうした値は変化することができ"
"ず、値をコアの間で共有するのも上手くいくからだ。難しいのは「値は決して変化しない」ということは古い値から新しい値を作る"
"のが効率的でなければならないということで、Clojureでは永続的データ構造のおかげで実際に効率的になっている。永続的データ"
"構造によって最終的にfavor immutability(イミュータブルであることを好め)というよく言われる助言に従うことが可能になる。そ"
"してあるアイデンティティの状態を新しい値に設定するには、アイデンティティの現在の値を読み取り、純粋な関数をその値に対し"
"て呼び出して新しい値を生み出し、その値を新しい状態として設定することによって行う。こうした複合的な操作は https://"
"clojure.github.com/clojure/clojure.core-api.html#clojure.core/alter[alter] や https://clojure.github.com/clojure/"
"clojure.core-api.html#clojure.core/commute[commute] 、 https://clojure.github.com/clojure/clojure.core-api."
"html#clojure.core/send[send] という関数で簡単にアトミックに行うことができる。"

#. type: Title ==
#: en/content/about/state.adoc:60
#, no-wrap
msgid "Message Passing and Actors"
msgstr "メッセージパッシングとアクター"

#. type: Plain text
#: en/content/about/state.adoc:63
#, fuzzy
#| msgid ""
#| "There are other ways to model identity and state, one of the more popular of which is the message-passing https://"
#| "en.wikipedia.org/wiki/Actor_model[actor model], best exemplified by the quite impressive https://en.wikipedia.org/"
#| "wiki/Erlang_%28programming_language%29[Erlang]. In an actor model, state is encapsulated in an actor (identity) "
#| "and can only be affected/seen via the passing of messages (values). In an asynchronous system like Erlang's, "
#| "reading some aspect of an actor's state requires sending a request message, waiting for a response, and the actor "
#| "sending a response. It is important to understand that _the actor model was designed to address the problems of "
#| "*distributed* programs_. And the problems of distributed programs are much harder - there are multiple worlds "
#| "(address spaces), direct observation is not possible, interaction occurs over possibly unreliable channels, etc. "
#| "The actor model supports transparent distribution. If you write all of your code this way, you are not bound to "
#| "the actual location of the other actors, allowing a system to be spread over multiple processes/machines without "
#| "changing the code."
msgid ""
"There are other ways to model identity and state, one of the more popular of which is the message-passing https://en."
"wikipedia.org/wiki/Actor_model[actor model]. In an actor model, state is encapsulated in an actor (identity) and can "
"only be affected/seen via the passing of messages (values). In an asynchronous system, reading some aspect of an "
"actor's state requires sending a request message, waiting for a response, and the actor sending a response. It is "
"important to understand that _the actor model was designed to address the problems of *distributed* programs_. And "
"the problems of distributed programs are much harder - there are multiple worlds (address spaces), direct observation "
"is not possible, interaction occurs over possibly unreliable channels, etc. The actor model supports transparent "
"distribution. If you write all of your code this way, you are not bound to the actual location of the other actors, "
"allowing a system to be spread over multiple processes/machines without changing the code."
msgstr ""
"アイデンティティと状態をモデリングする方法は他にもあり、人気のある方法のひとつがメッセージパッシングの https://en."
"wikipedia.org/wiki/Actor_model[アクターモデル] で、 https://en.wikipedia.org/wiki/Erlang_%28programming_language"
"%29[Erlang] が非常に印象的な好例だ。アクターモデルでは、状態はアクター(アイデンティティ)にカプセル化され、メッセージ"
"(値)を渡すことによってのみ影響を与えたり見たりすることができる。Erlangでのような非同期的なシステムでは、あるアクターの"
"状態のある面を読み取るには、リクエストメッセージを送り、レスポンスを待ち、そのアクターがレスポンスを送る必要がある。 _"
"アクターモデルは *分散* プログラムの問題に対処するために設計された_ ということを理解しておくのは重要なことだ。そして、"
"分散プログラムの問題はずっと難しい――複数の世界(アドレス空間)があり、直接的な観察は可能ではなく、信頼できないかもしれな"
"いチャネルを通して相互作用が行われる、など。アクターモデルは透過的な分散(transparent distribution)をサポートしている。"
"すべてのコードをこのように書けば、他のアクターの実際の場所に縛られることはなくなり、コードを変更することなくシステムを"
"複数のプロセス/マシンに拡大することが可能になる。"

#. type: Plain text
#: en/content/about/state.adoc:65
msgid "I chose not to use the actor model for same-process state management in Clojure for several reasons:"
msgstr "私はいくつかの理由からアクターモデルをClojureでの同一プロセスでの状態管理には利用しないことを選んだ:"

#. type: Plain text
#: en/content/about/state.adoc:68
msgid ""
"It is a much more complex programming model, requiring 2-message conversations for the simplest data reads, and "
"forcing the use of blocking message receives, which introduce the potential for deadlock. Programming for the failure "
"modes of distribution means utilizing timeouts etc. It causes a bifurcation of the program protocols, some of which "
"are represented by functions and others by the values of messages."
msgstr ""
"最もシンプルなデータの読み取りにも2つのメッセージのやり取りを必要とし、ブロックするメッセージ受け取りを利用しなければ"
"ならず、それによってデッドロックの可能性が生まれる、ずっと複雑なプログラミングモデルだ。分散処理の故障モードのためにプ"
"ログラミングするということはタイムアウトなどを利用することを意味する。それはプログラムのプロトコルを関数で表されるもの"
"とメッセージの値で表されるものに二分してしまう原因になる。"

#. type: Plain text
#: en/content/about/state.adoc:69
msgid ""
"It doesn't let you fully leverage the efficiencies of being in the same process. It is quite possible to efficiently "
"directly share a large immutable data structure between threads, but the actor model forces intervening conversations "
"and, potentially, copying. Reads and writes get serialized and block each other, etc."
msgstr ""
"同一プロセスであることによる効率性を十分に活用できない。大きなイミュータブルデータ構造をスレッド間で効率的に直接共有す"
"ることは十分可能だが、アクターモデルでは介在するやり取り、もしかするとコピーも強いられることになる。読み書きがシリアラ"
"イズされ相互にブロックする、など。"

#. type: Plain text
#: en/content/about/state.adoc:70
msgid ""
"It reduces your flexibility in modeling - this is a world in which everyone sits in a windowless room and "
"communicates only by mail. Programs are decomposed as piles of blocking switch statements. You can only handle "
"messages you anticipated receiving. Coordinating activities involving multiple actors is very difficult. You can't "
"observe anything without its cooperation/coordination - making ad-hoc reporting or analysis impossible, instead "
"forcing every actor to participate in each protocol."
msgstr ""
"モデリングの柔軟性が低下する――これはみんなが窓のない部屋に座ってメールのみによってコミュニケーションを取るような世界"
"だ。プログラムは大量のブロックするswitch文に分解される。受け取ることを予想しているメッセージを扱うことしかできない。複"
"数のアクターが関わる活動を協調させるのは非常に困難だ。協調/調整させることなくして何も観察することができない――アドホッ"
"クにレポートしたり分析したりするのは不可能で、むしろすべてのアクターがそれぞれのプロトコルに参加することを強いられる。"

#. type: Plain text
#: en/content/about/state.adoc:71
msgid ""
"It is often the case that taking something that works well locally and transparently distributing it doesn't work out "
"- the conversation granularity is too chatty or the message payloads are too large or the failure modes change the "
"optimal work partitioning, i.e. transparent distribution isn't transparent and the code has to change anyway."
msgstr ""
"ローカルで上手く動作するものを透過的に分散させると上手く動作しなくなることがよくある――やり取りの粒度が細かすぎたり、"
"メッセージのペイロードが大きすぎたり、故障モードが最適な仕事の分割を変えてしまったり、つまり透過的な分散は透過的ではな"
"く、結局コードを変更しなければならない。"

#. type: Plain text
#: en/content/about/state.adoc:73
msgid ""
"Clojure may eventually support the actor model for distributed programming, paying the price only when distribution "
"is required, but I think it is quite cumbersome for same-process programming. YMMV of course."
msgstr ""
"Clojureもやがて、分散処理が必要な場合にだけ代価を払って、分散プログラミングのためにアクターモデルをサポートするかもし"
"れないが、私は同一プロセスでのプログラミングには扱いづらすぎると考えている。もちろんあなたの立場は異なるかもしれない。"

#. type: Plain text
#: en/content/about/state.adoc:77
msgid ""
"Clojure is a functional language that explicitly supports programs as models and provides robust and easy-to-use "
"facilities for managing identity and state in a single process in the face of concurrency."
msgstr ""
"Clojureは、モデルとしてのプログラムを明示的にサポートし、並行処理に際してシングルプロセスでのアイデンティティと状態を"
"管理するための堅牢で使いやすい機能を提供する関数型言語だ。"

#. type: Plain text
#: en/content/about/state.adoc:79
msgid ""
"In coming to Clojure from an OO language, you can use one of its <<xref/../../reference/data_structures#,persistent "
"collections>>, e.g. maps, instead of objects. Use values as much as possible. And for those cases where your objects "
"are truly modeling identities (far fewer cases than you might realize until you start thinking about it this way), "
"you can use a Ref or Agent with e.g. a map as its state in order to model an identity with changing state. If you "
"want to encapsulate or abstract away the details of your values, a good idea if they are non-trivial, write a set of "
"functions for viewing and manipulating them. If you want polymorphism, use Clojure's multimethods."
msgstr ""
"OO言語からClojureに来たのであれば、オブジェクトの代わりに <<xref/../../reference/data_structures#,永続的なコレクション"
">> 、例えばマップを利用することができる。可能な限り値を利用しよう。そして、オブジェクトが本当にアイデンティティをモデ"
"リングしている場合(そう考え始めるのはあなたが考える以上にずっとまれなことだが)には、変化する状態を持つアイデンティティ"
"をモデリングするために、例えばマップを状態としたRefやAgentを利用することができる。値の詳細をカプセル化したり抽象化した"
"りしたいのであれば、些細なものでなければ良いアイディアだが、値を参照したり操作したりする一連の関数を書こう。ポリモー"
"フィズムがほしいのであれば、Clojureのマルチメソッドを利用しよう。"

#. type: Plain text
#: en/content/about/state.adoc:80
msgid ""
"In the local case, since Clojure does not have mutable local variables, instead of building up values in a mutating "
"loop, you can instead do it functionally with <<xref/../../reference/special_forms#recur#,recur>> or https://clojure."
"github.com/clojure/clojure.core-api.html#clojure.core/reduce[reduce]."
msgstr ""
"ローカルな場合には、Clojureにはミュータブルなローカル変数がないので、変更を伴うループで値を組み立てる代わりに、 "
"<<xref/../../reference/special_forms#recur#,recur>> や https://clojure.github.com/clojure/clojure.core-api."
"html#clojure.core/reduce[reduce] で関数的に値を組み立てることができる。"
