# Japanese translations for clojure-site-ja package
# Copyright (C) 2016 Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# Automatically generated, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2018-04-02 07:15+0900\n"
"PO-Revision-Date: 2018-03-12 22:06+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: en/content/reference/metadata.adoc:4 en/content/reference/protocols.adoc:4 en/content/reference/sequences.adoc:4
#: en/content/reference/multimethods.adoc:4 en/content/reference/libs.adoc:4 en/content/reference/transients.adoc:4
#: en/content/reference/compilation.adoc:4 en/content/reference/other_libraries.adoc:4
#: en/content/reference/documentation.adoc:4 en/content/reference/macros.adoc:4 en/content/reference/transducers.adoc:4
#: en/content/reference/refs.adoc:4 en/content/reference/lazy.adoc:4 en/content/reference/namespaces.adoc:4
#: en/content/reference/lisps.adoc:4 en/content/reference/evaluation.adoc:4 en/content/reference/other_functions.adoc:4
#: en/content/reference/reducers.adoc:4 en/content/reference/data_structures.adoc:4 en/content/reference/atoms.adoc:4
#: en/content/reference/repl_and_main.adoc:4 en/content/reference/agents.adoc:4 en/content/reference/datatypes.adoc:4
#: en/content/community/libraries.adoc:4 en/content/community/license.adoc:4 en/content/community/downloads_older.adoc:4
#: en/content/community/downloads.adoc:4 en/content/community/swag.adoc:4 en/content/404.adoc:4
#: en/content/privacy.adoc:4 en/content/search.adoc:4 en/content/about/spec.adoc:4
#: en/content/about/concurrent_programming.adoc:4 en/content/about/lisp.adoc:4 en/content/about/jvm_hosted.adoc:4
#: en/content/about/runtime_polymorphism.adoc:4 en/content/about/dynamic.adoc:4 en/content/about/features.adoc:4
#: en/content/about/rationale.adoc:4 en/content/about/state.adoc:4 en/content/about/clojurescript.adoc:4
#: en/content/about/functional_programming.adoc:4 en/content/about/clojureclr.adoc:4
msgid "Rich Hickey 2015-01-01"
msgstr "Rich Hickey 2015-01-01"

#. type: Plain text
#: en/content/reference/metadata.adoc:15 en/content/reference/protocols.adoc:15 en/content/reference/sequences.adoc:15
#: en/content/reference/deps_and_cli.adoc:13 en/content/reference/multimethods.adoc:15 en/content/reference/libs.adoc:16
#: en/content/reference/transients.adoc:16 en/content/reference/compilation.adoc:16
#: en/content/reference/other_libraries.adoc:16 en/content/reference/macros.adoc:15
#: en/content/reference/transducers.adoc:15 en/content/reference/refs.adoc:15 en/content/reference/lazy.adoc:12
#: en/content/reference/reader.adoc:13 en/content/reference/special_forms.adoc:15
#: en/content/reference/namespaces.adoc:15 en/content/reference/java_interop.adoc:15
#: en/content/reference/other_functions.adoc:17 en/content/reference/vars.adoc:16 en/content/reference/reducers.adoc:15
#: en/content/reference/data_structures.adoc:16 en/content/reference/repl_and_main.adoc:16
#: en/content/reference/agents.adoc:16 en/content/reference/datatypes.adoc:16 en/content/guides/deps_and_cli.adoc:11
#: en/content/guides/weird_characters.adoc:10 en/content/guides/spec.adoc:11 en/content/guides/getting_started.adoc:11
#: en/content/guides/reader_conditionals.adoc:10 en/content/guides/learn/hashed_colls.adoc:16
#: en/content/guides/learn/syntax.adoc:14 en/content/guides/learn/flow.adoc:14
#: en/content/guides/learn/sequential_colls.adoc:16 en/content/guides/learn/functions.adoc:16
#: en/content/guides/destructuring.adoc:11 en/content/guides/faq.adoc:11 en/content/about/spec.adoc:16
#: en/content/about/dynamic.adoc:16 en/content/about/rationale.adoc:13 en/content/about/state.adoc:16
#: en/content/about/functional_programming.adoc:15
msgid "toc::[]"
msgstr "toc::[]"

#. type: Title ====
#: en/content/reference/sequences.adoc:1 en/content/guides/spec.adoc:513 en/content/about/spec.adoc:234
#, no-wrap
msgid "Sequences"
msgstr "シーケンス"

#. type: Title ==
#: en/content/reference/deps_and_cli.adoc:418 en/content/about/spec.adoc:337
#, no-wrap
msgid "Glossary"
msgstr "用語集"

#. type: Title ====
#: en/content/reference/documentation.adoc:1 en/content/news/2017/12/08/clojure19.adoc:21 en/content/about/spec.adoc:310
#, no-wrap
msgid "Documentation"
msgstr "ドキュメンテーション"

#. type: Title ====
#: en/content/reference/reader.adoc:57 en/content/guides/learn/hashed_colls.adoc:82 en/content/about/spec.adoc:198
msgid "Maps"
msgstr ""
"Maps (マップ)"

#. type: Plain text
#: en/content/guides/spec.adoc:1199 en/content/news/2017/12/08/clojure19.adoc:18 en/content/about/spec.adoc:100
#, no-wrap
msgid "Instrumentation"
msgstr "specの組み込み(instrumentation)"

#. type: Plain text
#: en/content/news/2017/12/08/clojure19.adoc:15 en/content/about/spec.adoc:97
msgid "Validation"
msgstr "バリデーション"

#. type: Plain text
#: en/content/news/2017/12/08/clojure19.adoc:16 en/content/about/spec.adoc:98
msgid "Error reporting"
msgstr "エラー報告"

#. type: Plain text
#: en/content/news/2017/12/08/clojure19.adoc:17 en/content/news/2011/07/22/introducing-clojurescript.adoc:30
#: en/content/about/spec.adoc:99
msgid "Destructuring"
msgstr "分配束縛"

#. type: Plain text
#: en/content/news/2017/12/08/clojure19.adoc:19 en/content/about/spec.adoc:101
msgid "Test-data generation"
msgstr "テストデータ生成"

#. type: Plain text
#: en/content/news/2017/12/08/clojure19.adoc:20 en/content/about/spec.adoc:102
msgid "Generative test generation"
msgstr "生成的テストの生成"

#. type: Plain text
#: en/content/news/2015/06/30/clojure-17.adoc:50 en/content/about/spec.adoc:381
msgid "Rich Hickey"
msgstr "Rich Hickey"

#. type: Title =
#: en/content/about/spec.adoc:1
#, no-wrap
msgid "clojure.spec - Rationale and Overview"
msgstr "clojure.spec - 論理的根拠と概要"

#. type: Title ==
#: en/content/about/spec.adoc:17
#, no-wrap
msgid "Problems"
msgstr "問題"

#. type: Title ===
#: en/content/about/spec.adoc:18
#, no-wrap
msgid "Docs are not enough"
msgstr "docsでは十分ではない"

#. type: Plain text
#: en/content/about/spec.adoc:23
msgid ""
"Clojure is a dynamic language. Among other things this means that type annotations are not required for code to run.  "
"While Clojure has some support for type hints, they are not an enforcement mechanism, nor comprehensive, and are "
"limited to communicating information to the compiler to aid in efficient code generation.  Clojure gets runtime "
"checking of a richer set of types by the JVM itself."
msgstr ""
"Clojureは動的言語だ。何よりこれは型アノテーションがコードの実行に必要とされないことを意味する。Clojureは型ヒントをいく"
"らかサポートしているが、型ヒントは強制のメカニズムではなく、網羅的でもなく、効率的なコード生成を支援するためコンパイラ"
"に情報を伝えることに限定されている。ClojureはJVM自身による豊富な型に対する実行時チェックの恩恵を受けている。"

#. type: Plain text
#: en/content/about/spec.adoc:29
msgid ""
"However it has always been a guiding principle of Clojure, widely valued and practiced by the community, to simply "
"represent information as data.  Thus important properties of Clojure systems are represented and conveyed by the "
"shape and other predicative properties of the data, not captured or checked anywhere since the runtime types are "
"indistinguishable heterogeneous maps and vectors."
msgstr ""
"しかし、情報をデータとしてシンプルに表現することが常にコミュニティで広く評価され実践されてきたClojureの指針だった。し"
"たがって、Clojureシステムの重要なプロパティはデータの形状やその他の述語的なプロパティによって表現され伝達され、実行時"
"の型は区別の付かない異種の型が混在するマップやベクターであるため、それ以外で捕捉されたりチェックされたりすることはな"
"い。"

#. type: Plain text
#: en/content/about/spec.adoc:34
msgid ""
"Documentation strings can be used to communicate with human consumers, but they can't be leveraged by programs or "
"tests, i.e. they have minimal power.  Users have turned to various libraries such as https://github.com/plumatic/"
"schema[Schema] and https://github.com/miner/herbert[Herbert] to get more powerful specifications."
msgstr ""
"ドキュメンテーション文字列は人間の利用者とのコミュニケーションに利用可能だが、プログラムやテストで活用することはできな"
"い、つまり最小限の力しか持っていないのだ。ユーザーはより強力な仕様記述を得るために https://github.com/plumatic/"
"schema[Schema] や https://github.com/miner/herbert[Herbert] のような様々なライブラリを頼ってきた。"

#. type: Title ===
#: en/content/about/spec.adoc:35
#, no-wrap
msgid "Map specs should be of keysets only"
msgstr "マップのspecはキーセットのみで構成されるべきだ"

#. type: Plain text
#: en/content/about/spec.adoc:40
msgid ""
"Most systems for specifying structures conflate the specification of the key set (e.g. of keys in a map, fields in an "
"object) with the specification of the values designated by those keys.  I.e. in such approaches the schema for a map "
"might say :a-key's type is x-type and :b-key's type is y-type.  This is a major source of rigidity and redundancy."
msgstr ""
"構造を記述するためのたいていのシステムではキーのセットに関する仕様(例えばマップのキーやオブジェクトのフィールドに関す"
"るもの)とそうしたキーが指し示す値に関する仕様を混同している。つまり、そうしたアプローチではあるマップに対するスキーマ"
"は:a-keyの型がx-typeで:b-keyの型がy-typeだと言うかもしれない。これは硬直性と冗長性の大きな原因だ。"

#. type: Plain text
#: en/content/about/spec.adoc:47
msgid ""
"In Clojure we gain power by dynamically composing, merging and building up maps. We routinely deal with optional and "
"partial data, data produced by unreliable external sources, dynamic queries etc. These maps represent various sets, "
"subsets, intersections and unions of the same keys, and in general ought to have the same semantic for the same key "
"wherever it is used. Defining specifications of every subset/union/intersection, and then redundantly stating the "
"semantic of each key is both an antipattern and unworkable in the most dynamic cases."
msgstr ""
"Clojureではマップを動的に合成し、マージし、構築することによって力を得ている。日常的に選択的なデータや部分的なデータ、"
"信頼できない外部ソースから生み出されたデータ、動的なクエリなどを扱っている。こうしたマップは同一のキーの様々な集合や部"
"分集合、共通部分、和集合を表し、一般に同一のキーはどこで使われても同一の意味を持つ必要がある。あらゆる部分集合/和集合/"
"共通部分に対する仕様を定義し、そして個々のキーの意味を冗長に述べるというのは、たいていの動的なケースでアンチパターンで"
"あり上手く機能するものでもない。"

#. type: Title ===
#: en/content/about/spec.adoc:48
#, no-wrap
msgid "Manual parsing and error reporting is not good enough"
msgstr "手動でのパース処理やエラー報告は十分に良いものではない"

#. type: Plain text
#: en/content/about/spec.adoc:55
msgid ""
"Many users, especially beginners, are frustrated and challenged by the error messages produced by hand-written "
"parsing and destructuring code, especially in macros where there are two contexts of execution (the macro runs at "
"compile time and its expansion at runtime, either of which could fail due to user error).  This has led to a call for "
"'macro grammars', but in fact macros are just functions of data->data and any solution for data validation and "
"destructuring should work as well for them as for any other functions.  I.e. macros are an instance of the problems "
"above."
msgstr ""
"多くのユーザー、特に初心者は、とりわけ2つの実行コンテキストがあるマクロ(マクロのコンパイル時の実行と実行時の展開はどち"
"らもユーザーエラーのために失敗しうる)において、手書きのパース処理やコードの分配束縛により生成されるエラーメッセージに"
"フラストレーションを覚えたり困難に直面したりしている。これは「マクロ文法」の必要性につながっているが、実際にはマクロは"
"データ->データの関数にすぎず、データのバリデーションや分配束縛のためのあらゆる解決策はその他の関数と同様にマクロにも機"
"能するはずだ。つまり、マクロは上記の問題の一例だといえる。"

#. type: Title ===
#: en/content/about/spec.adoc:56
#, no-wrap
msgid "Generative testing and robustness"
msgstr "生成的テストと頑健性"

#. type: Plain text
#: en/content/about/spec.adoc:62
msgid ""
"Finally, in all languages, dynamic or not, tests are essential to quality.  Too many critical properties are not "
"captured by common type systems.  But manual testing has a very low effectiveness/effort ratio. Property-based, "
"generative testing, as implemented for Clojure in https://github.com/clojure/test.check[test.check], has proved to be "
"far more powerful than manually written tests."
msgstr ""
"最後に、動的でもそうでなくてもすべての言語において、テストは品質に不可欠なものだ。あまりにも多くの重要なプロパティが一"
"般的な型システムでは捕捉されない。しかし手動でのテストは労力に対する効果の割合が非常に低い。 https://github.com/"
"clojure/test.check[test.check] でClojure向けに実装されているような、プロパティベースの生成的テストは手書きのテストより"
"もずっと強力であることが分かってきた。"

#. type: Plain text
#: en/content/about/spec.adoc:68
msgid ""
"Yet property based testing requires the definition of properties, which require extra effort and expertise to "
"produce, and which, at the function-level, have substantial overlap with function specifications.  Many interesting "
"properties at the function level would already be captured by structural+predicative specs.  Ideally, specs should "
"integrate with generative testing and provide certain categories of generative tests 'for free'."
msgstr ""
"それでも、プロパティベーストテストはプロパティの定義が必要となり、それにはそれを生み出すためのさらなる労力と熟練が必要"
"となり、そうした定義は関数のレベルでは関数の仕様記述と大きな重複がある。関数のレベルでの多くの興味深いプロパティがすで"
"に構造的+述語的なspecによって捕捉されているだろう。理想的には、specは生成的テストと統合し、ある種の生成的テストを「た"
"だで」提供するべきだ。"

#. type: Title ===
#: en/content/about/spec.adoc:69
#, no-wrap
msgid "A standard approach is needed"
msgstr "標準的なアプローチが必要だ"

#. type: Plain text
#: en/content/about/spec.adoc:71
msgid "In short, Clojure has no standard, expressive, powerful and integrated system for specification and testing."
msgstr "要するに、Clojureには仕様記述とテストのための標準的で表現力のある強力で統合されたシステムがないのだ。"

#. type: Plain text
#: en/content/about/spec.adoc:73
#, no-wrap
msgid "**clojure.spec** aims to provide it.\n"
msgstr "**clojure.spec** はそれを提供することを目指している。\n"

#. type: Title ==
#: en/content/about/spec.adoc:74
#, no-wrap
msgid "Objectives"
msgstr "目的"

#. type: Title ===
#: en/content/about/spec.adoc:75
#, no-wrap
msgid "Communication"
msgstr "コミュニケーション"

#. type: delimited block =
#: en/content/about/spec.adoc:81
msgid ""
"Species - appearance, form, sort, kind, equivalent to spec (ere) to look, regard + {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}"
"{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}+ -iēs abstract noun suffix"
msgstr ""
"Species - appearance, form, sort, kind, equivalent to spec (ere) to look, regard + {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}"
"{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}+ -iēs abstract noun suffix"

#. type: delimited block =
#: en/content/about/spec.adoc:83
msgid "Specify - species + -ficus -fic (make)"
msgstr "Specify - species + -ficus -fic (make)"

#. type: Plain text
#: en/content/about/spec.adoc:88
msgid ""
"A specification is about how something 'looks', but is, most importantly, something that is looked at.  Specs should "
"be readable, composed of 'words' (predicate functions) programmers are already using, and integrated in documentation."
msgstr ""
"仕様(specification)とはあるものがどう「見える」かに関するものだが、最も重要なのは、見られるものだ。specは、読みやす"
"く、プログラマがすでに使っている「単語」(述語関数)で構成され、ドキュメンテーションに統合されているべきだ。"

#. type: Title ===
#: en/content/about/spec.adoc:89
#, no-wrap
msgid "Unify specification in its various contexts"
msgstr "あらゆるコンテキストにおける仕様記述を統一"

#. type: Plain text
#: en/content/about/spec.adoc:92
msgid ""
"Specs for data structures, attribute values and functions should all be the same and live in a globally-namespaced "
"directory."
msgstr ""
"データ構造や属性値、関数のためのspecはすべて同じであるべきであり、グローバルにネームスペースの付いたディレクトリにある"
"べきだ。"

#. type: Title ===
#: en/content/about/spec.adoc:93
#, no-wrap
msgid "Maximize leverage from specification effort"
msgstr "仕様記述の労力を最大限に活用する"

#. type: Plain text
#: en/content/about/spec.adoc:95
msgid "Writing a spec should enable __automatic__:"
msgstr "specを書くことで以下のことが __自動的__ に可能になるべきだ:"

#. type: Title ===
#: en/content/about/spec.adoc:103
#, no-wrap
msgid "Minimize intrusion"
msgstr "侵入を最小化"

#. type: Plain text
#: en/content/about/spec.adoc:106
msgid ""
"Don't require that people e.g. define their functions differently. Minor modifications to `doc` and `macroexpand` "
"will allow independently written specs to adorn fn/macro behavior without redefinition."
msgstr ""
"例えば関数を異なる方法で定義することを要求してはならない。 `doc` と `macroexpand` への小さな変更によって、独立して書か"
"れたspecが再定義することなくfn/macroの振る舞いを修飾することが可能になる。"

#. type: Title ===
#: en/content/about/spec.adoc:107
#, no-wrap
msgid "Decomplect maps/keys/values"
msgstr "マップ、キー、値を分離する"

#. type: Plain text
#: en/content/about/spec.adoc:112
msgid ""
"Keep map (keyset) specs separate from attribute (key->value) specs. Encourage and support attribute-granularity specs "
"of namespaced keyword to value-spec. Combining keys into sets (to specify maps) becomes orthogonal, and checking "
"becomes possible in the fully-dynamic case, i.e. even when no map spec is present, attributes (key-values) can be "
"checked."
msgstr ""
"マップ(キーセット)のspecを属性(キー->値)のspecから分けておこう。ネームスペース付きのキーワードから値へのspecという、属"
"性の粒度でのspecを推奨しサポートしよう。(マップの仕様を記述するために)キーを組み合わせてセットにすることが直交的にな"
"り、完全に動的なケースでのチェックが可能になる、つまりマップのspecが存在しない場合でさえ、属性(キー-値)はチェックでき"
"る。"

#. type: Title ===
#: en/content/about/spec.adoc:113
#, no-wrap
msgid "Enable and start a dialog about semantic change and compatibility"
msgstr "意味の変更と互換性に関する対話を可能にし、開始する"

#. type: Plain text
#: en/content/about/spec.adoc:118
msgid ""
"Programmers suffer greatly when they redefine things while keeping the names the same. Yet some changes are "
"compatible and some are breaking, and most tools can't distinguish. Use constructs like set membership and regular "
"expressions for which compatibility can be determined, and provide tools for compatibility checking (while leaving "
"general predicate equality out of scope)."
msgstr ""
"プログラマは名前を同じにしたままで再定義する時に大いに苦しめられる。変更のいくらかは互換性があるが、いくらかは破壊的"
"で、たいていのツールはそれを区別することができない。互換性が判断できるようにセットの所属関係や正規表現のような構造を利"
"用し、(一般的な述語による等価性は除外して)互換性チェックのためのツールを提供しよう。"

#. type: Title ==
#: en/content/about/spec.adoc:119
#, no-wrap
msgid "Guidelines"
msgstr "ガイドライン"

#. type: Title ===
#: en/content/about/spec.adoc:120
#, no-wrap
msgid "Mistakes will be made"
msgstr "ミスは起こりうる"

#. type: Plain text
#: en/content/about/spec.adoc:124
msgid ""
"We don't (and couldn't) live in a world where we can't make mistakes. Instead, we periodically check that we "
"haven't.  Amazon doesn't send you your TV via a `UPS<Trucks<Boxes<TV>>>`. So occasionally you might get a microwave, "
"but the supply chain isn't burdened with correctness proof. Instead we check at the edges and run tests."
msgstr ""
"私たちはミスを起こしえない世界で生きているわけではない(そうすることもできないだろう)。その代わりに、私たちは定期的にミ"
"スしていないことをチェックするのだ。Amazonは `UPS<Trucks<Boxes<TV>>>` 経由でテレビを送ってくるわけではない。そのため時"
"には電子レンジを受け取ることもあるかもしれないが、サプライチェーンが正確性を証明する責任を負っているわけではない。その"
"代わりに私たちが終端でチェックしてテストするのだ。"

#. type: Title ===
#: en/content/about/spec.adoc:125
#, no-wrap
msgid "expressivity > proof"
msgstr "表現力 > 証明"

#. type: Plain text
#: en/content/about/spec.adoc:132
msgid ""
"There is no reason to limit our specifications to what we can prove, yet that is primarily what type systems do.  "
"There is so much more we want to communicate and verify about our systems. This goes beyond structural/"
"representational types and tagging to predicates that e.g. narrow domains or detail relationships between inputs or "
"between inputs and output.  Additionally, the properties we care most about are often those of the runtime values, "
"not some static notion.  Thus **spec** is not a type system."
msgstr ""
"主に型システムがしているのはそれなのだが、仕様記述を証明可能なものに制限する理由はない。システムについてコミュニケー"
"ションを取り、正しさを確かめたいことはもっとたくさんある。これは、例えば定義域を狭めたり複数の入力の間の関係や入力と出"
"力の間の関係を詳細に述べる、構造的/表象的な型や述語に対するタグ付け以上のものだ。加えて、私たちが最も気にするプロパ"
"ティは多くの場合実行時の値に関するプロパティであり、静的な概念のようなものではない。そういうわけで **spec** は型システ"
"ムではない。"

#. type: Title ===
#: en/content/about/spec.adoc:133
#, no-wrap
msgid "Names are important"
msgstr "名前は重要だ"

#. type: Plain text
#: en/content/about/spec.adoc:139
msgid ""
"All programs use names, even when the type systems don't, and they capture important semantics. `Int x Int x Int` "
"just isn't good enough (is it length/width/height or height/width/depth?). So **spec** will not have unlabeled "
"sequence components or untagged union bindings. The utility of this becomes evident when **spec** needs to talk to "
"users about specs, e.g. in error reporting, and vice versa, e.g. when users want to override generators in specs. "
"When all branches are named, you can talk about parts of specs using __paths__."
msgstr ""
"あらゆるプログラムは(型システムが使わない場合でさえ)名前を使い、名前は重要な意味を捉えている。 `Int x Int x Int` は十"
"分に良いものではない(長さ/幅/高さ なのか 高さ/幅/奥行き なのか?)。そのため、 **spec** にはラベルなしのシーケンス要素や"
"タグ付けされていない和集合の束縛はない。このことの効用は、 **spec** がspecについてユーザーに何か言わければならない時、"
"例えばエラー報告する場合、また逆に、例えばユーザーがspecのジェネレータをオーバーライドしたい場合に明らかになる。すべて"
"の分岐に名前が付いていれば、 __paths__ を使ってspecの部分について言うことができる。"

#. type: Title ===
#: en/content/about/spec.adoc:140
#, no-wrap
msgid "Global (namespaced) names are more important"
msgstr "グローバルな(ネームスペース付きの)名前はより重要だ"

#. type: Plain text
#: en/content/about/spec.adoc:147
msgid ""
"Clojure supports namespaced keywords and symbols. Note here we are just talking about namespace-qualified names, not "
"Clojure namespace objects. These are tragically underutilized and convey important benefits because they can always "
"co-reside in dictionaries/dbs/maps/sets without conflict. **spec** will allow (only) namespace-qualified keywords and "
"symbols to name specs. People using namespaced keys for their informational maps (a practice we'd like to see grow) "
"can register the specs for those attributes directly under those names. This categorically changes the self-"
"description of maps, particularly in dynamic contexts, and encourages composition and consistency."
msgstr ""
"Clojureはネームスペース付きのキーワードとシンボルをサポートしている。ここではネームスペースで修飾された名前のことを"
"言っているのであって、Clojureのネームスペースオブジェクトのことを言っているわけではないことに注意しよう。これらは悲し"
"いことにあまり活用されていないが、ディクショナリ/db/マップ/セットの中で衝突することなく常に共存することができるため、"
"重要な利益をもたらす。 **spec** はspecを名付けるのにネームスペース付きのキーワードとシンボル(だけ)を認めている。ネーム"
"スペース付きのキーを情報を持ったマップのために使う(広まってほしい習慣だ)と、マップの属性のためのspecを直接マップのキー"
"の名前で登録することができる。このことは、とりわけ動的な状況において、マップというものの自己記述を絶対的に変えることに"
"なり、合成や一貫性を促進することになる。"

#. type: Title ===
#: en/content/about/spec.adoc:148
#, no-wrap
msgid "Don't further add to/overload the (reified) namespaces of Clojure"
msgstr "Clojureの(実体化された)ネームスペースにさらに追加し/負担をかけすぎてはならない"

#. type: Plain text
#: en/content/about/spec.adoc:151
msgid ""
"Nothing will be attached to vars, metadata etc. All functions have namespaced names which can serve as keys to their "
"related data (e.g. spec) that is stored elsewhere."
msgstr ""
"varやメタデータなどには何も付加されない。すべての関数にはネームスペース付きの名前があり、それは別のどこかに格納された"
"関連するデータ(例えばspec)へのキーとして働く。"

#. type: Title ===
#: en/content/about/spec.adoc:152
#, no-wrap
msgid "Code is data (not vice versa)"
msgstr "コードはデータだ(逆ではない)"

#. type: Plain text
#: en/content/about/spec.adoc:162
msgid ""
"In Lisps (and thus Clojure), code is data. But data is not code until you define a language around it. Many DSLs in "
"this space drive at a data representation for schemas. But predicative specs have an open and large vocabulary, and "
"most of the useful predicates already exist and are well known as functions in the core and other namespaces, or can "
"be written as simple expressions. Having to 'datafy', possibly renaming, all of these predicates adds little value, "
"and has a definite cost in understanding precise semantics. **spec** instead leverages the fact that the original "
"predicates and expressions are data in the first place and captures that data for use in communicating with the users "
"in documentation and error reporting. Yes, this means that more of the surface area of ``clojure.spec`` will be "
"macros, but specs are overwhelmingly written by people and, when composed, manually so."
msgstr ""
"Lisp(したがってClojure)では、コードはデータだ。しかし、データはそれに関する言語を定義するまでコードではない。この領域"
"での多くのDSLはスキーマのデータ表現に向かっている。しかし、述語的なspecには開かれた大きな語彙があり、便利な述語の多く"
"がすでに存在し、coreやその他のネームスペースの関数としてよく知られている、もしくはシンプルな式として書くことができる。"
"こうしたあらゆる述語を「データ化」する、あるいは名前を付け直さなければならないことによって得られる価値はほとんどなく、"
"正確な意味を理解するのに明確なコストがある。 **spec** ではむしろ、もともとの述語と式が最初からデータであるという事実を"
"活用して、ドキュメンテーションやエラー報告でのユーザーとのコミュニケーションで利用するためにそうしたデータを捉えてい"
"る。そう、 ``clojure.spec`` の表層領域の多くはマクロになるが、specは圧倒的に人によって書かれ、組み合わせる時も手で行う"
"ということだ。"

#. type: Title ===
#: en/content/about/spec.adoc:163
#, no-wrap
msgid "Sets (maps) are about membership, that's it"
msgstr "セット(マップ)は所属関係に関するもの、それだけだ"

#. type: Plain text
#: en/content/about/spec.adoc:169
msgid ""
"As per above, maps defining the details of the values at their keys is a fundamental complecting of concerns that "
"will not be supported. Map specs detail required/optional keys (i.e. set membership things) and keyword/attr/value "
"semantics are independent. Map checking is two-phase, required key presence then key/value conformance.  The latter "
"can be done even when the (namespace-qualified) keys present at runtime are not in the map spec.  This is vital for "
"composition and dynamicity."
msgstr ""
"上述の通り、キーの値についての詳細を定義したマップは、根本的な関心の絡まり(complecting)であり、支持できないものだ。"
"マップのspecは必須/オプションのキー(つまりセットの所属関係)について詳しく述べるが、キーワード/属性/値の意味は独立して"
"いる。マップのチェックは、必須のキーの存在、そしてキー/値の一致という2フェーズだ。後者は、実行時に存在する(ネームス"
"ペース修飾された)キーがマップのspecにない場合でさえ行うことができる。これは合成と動的な性質のために極めて重要なもの"
"だ。"

#. type: Title ===
#: en/content/about/spec.adoc:170
#, no-wrap
msgid "Informational vs implementational"
msgstr "情報的 vs 実装的"

#. type: Plain text
#: en/content/about/spec.adoc:175
msgid ""
"Invariably, people will try to use a specification system to detail implementation decisions, but they do so to their "
"detriment. The best and most useful specs (and interfaces) are related to purely information aspects.  Only "
"information specs work over wires and across systems. We will always prioritize, and where there is a conflict, "
"prefer, the information approach."
msgstr ""
"いつでも、人は仕様記述システムを実装の決定について詳述するのに利用しようとするが、そうすることによって自らに損害を与え"
"ている。最も良く最も有用なspec(とインターフェース)は純粋に情報の側面に関するものだ。情報のspecだけがネットワークを越え"
"てシステムを横断して機能する。私たちは情報のアプローチを常に優先し、対立がある場合にはそちらを好むだろう。"

#. type: Title ===
#: en/content/about/spec.adoc:176
#, no-wrap
msgid "K.I.S.S."
msgstr "K.I.S.S."

#. type: Plain text
#: en/content/about/spec.adoc:182
msgid ""
"There are very few bottom notions in this space and we will endeavor to stick to them.  There are few distinct "
"structural notions - a handful of atomic types, sequential things, sets and maps.  Unsurprisingly, these are the "
"Clojure data types and fundamental ops will be provided only for these. Similarly there are mathematical tools for "
"talking about these - set logic for maps and regular expressions for sequences - that have valuable properties. We "
"will prefer these over ad hoc solutions."
msgstr ""
"この領域には基礎的な概念が非常に少ないが、私たちはそれらにこだわる努力をする。固有の構造的な概念は少ない。少数のアト"
"ミックな型、シーケンシャルなもの、セット、マップだ。驚くに当たらないことだが、これらはClojureのデータ型であり、基礎的"
"なオペレータはこれらに対してのみ提供される。同様に、これらについて言うための数学的なツールがあり(マップに対する集合論"
"理、シーケンスに対する正規表現)、価値のある性質を備えている。私たちはアドホックな解決策よりもこれらを好むだろう。"

#. type: Title ===
#: en/content/about/spec.adoc:183
#, no-wrap
msgid "Build on test.check but don't require knowledge of it"
msgstr "test.checkの上に構築するが、その知識は要求しない"

#. type: Plain text
#: en/content/about/spec.adoc:188
msgid ""
"The generative testing underpinning of **spec** will leverage ``test.check`` and not reinvent it.  But spec users "
"should not need to know anything about ``test.check`` until and unless they want to write their own generators or "
"supplement **spec**'s generated tests with further property-based tests of their own. There should be no production "
"runtime dependency on ``test.check``."
msgstr ""
"**spec** を土台とした生成的テストは ``test.check`` を活用し、再発明はしない。しかし、specのユーザーは、自分自身でジェ"
"ネレータを書きたかったり、さらなるプロパティベーストテストで **spec** が生成したテストを補いたかったりするのでない限"
"り、 ``test.check`` について何も知る必要がないようにするべきだ。"

#. type: Title =
#: en/content/about/spec.adoc:189 en/content/about/features.adoc:1
#, no-wrap
msgid "Features"
msgstr "特徴"

#. type: Title ===
#: en/content/about/spec.adoc:190
#, no-wrap
msgid "Overview"
msgstr "概要"

#. type: Title ====
#: en/content/about/spec.adoc:191
#, no-wrap
msgid "Predicative specs"
msgstr "述語的なspec"

#. type: Plain text
#: en/content/about/spec.adoc:197
msgid ""
"The basic idea is that specs are nothing more than a logical composition of predicates. At the bottom we are talking "
"about the simple boolean predicates you are used to like ``int?`` or `symbol?`, or expressions you build yourself "
"like `#(< 42 % 66)`.  **spec** adds logical ops like ``spec/and`` and ``spec/or`` which combine specs in a logical "
"way and offer deep reporting, generation and conform support and, in the case of ``spec/or``, tagged returns."
msgstr ""
"基本的なアイディアは、specは単なる述語の論理的な組み合わせにすぎないというものだ。根底では、 ``int?`` や ``symbol?"
"`` 、自分で組み立てた式 `#(< 42 % 66)` のような、慣れたシンプルなbooleanの述語について言っているのだ。 **spec** は "
"``spec/and`` と ``spec/or`` のような論理演算子を追加しており、論理的な方法でspecを組み合わせ、深いところまでの報告、生"
"成、conformのサポート、 ``spec/or`` のケースではタグ付きの戻り値を提供する。"

#. type: Plain text
#: en/content/about/spec.adoc:201
msgid ""
"Specs for map keysets provide for the specification of required and optional key sets. A spec for a map is produced "
"by calling ``keys`` with ``:req`` and ``:opt`` keyword arguments mapping to vectors of key names."
msgstr ""
"マップのキーセットのためのspecは、必須とオプションのキーのセットについての仕様記述を提供する。あるマップに対するspec"
"は、キーの名前のベクターに対応付けた ``:req`` と ``:opt`` キーワード引数で ``keys`` を呼び出すことで生成される。"

#. type: Plain text
#: en/content/about/spec.adoc:203
msgid "``:req`` keys support the logical operators ``and`` and ``or``."
msgstr "``:req`` のキーは論理演算子 ``and`` と ``or`` をサポートしている。"

#. type: delimited block -
#: en/content/about/spec.adoc:207
#, no-wrap
msgid "(spec/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n"
msgstr "(spec/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n"

#. type: Plain text
#: en/content/about/spec.adoc:212
msgid ""
"One of the most visible differences between **spec** and other systems is that there is no place in that map spec for "
"specifying the __values__ e.g. ``::x`` can take. It is the (enforced) opinion of **spec** that the specification of "
"values associated with a namespaced keyword, like ``:my.ns/k``, should be registered under that keyword itself, and "
"applied in any map in which that keyword appears. There are a number of advantages to this:"
msgstr ""
"**spec** と他のシステムとの間で最も見た目に明らかな違いのひとつは、マップのspecに(例えば ``::x`` がとりうる) __値__ に"
"ついて記述する場所がないことだ。これは、 ``:my.ns/k`` のようなネームスペース付きのキーワードに関連付けられた値の仕様は"
"そのキーワード自体に登録され、そのキーワードが現れるあらゆるマップに適用されるべきだという **spec** の(強制的な)主張"
"だ。これにはいくつもの利点がある:"

#. type: Plain text
#: en/content/about/spec.adoc:214
msgid "It ensures consistency for all uses of that keyword in an application where all uses should share a semantic"
msgstr "すべての利用で意味が共有されるべきアプリケーション内で、そのキーワードのすべての利用に一貫性を保証する"

#. type: Plain text
#: en/content/about/spec.adoc:215
msgid "It similarly ensures consistency between a library and its consumers"
msgstr "同様に、ライブラリとその利用者との間の一貫性を保証する"

#. type: Plain text
#: en/content/about/spec.adoc:216
msgid "It reduces redundancy, since otherwise many map specs would need to make matching declarations about k"
msgstr "そうでなければ多くのマップのspecがkについて同じ宣言をする必要があるため、冗長さを減らすことになる"

#. type: Plain text
#: en/content/about/spec.adoc:217
msgid "Namespaced keyword specs can be checked even when no map spec declares those keys"
msgstr "ネームスペース付きキーワードのspecはマップのspecがそのキーを宣言していない時でさえチェックされる"

#. type: Plain text
#: en/content/about/spec.adoc:221
msgid ""
"This last point is vital when dynamically building up, composing, or generating maps. Creating a spec for every map "
"subset/union/intersection is unworkable. It also facilitates fail-fast detection of bad data - when it is introduced "
"vs when it is consumed."
msgstr ""
"この最後の点はマップを動的に構築し、合成し、生成する場合に極めて重要だ。あらゆるマップの部分集合/和集合/共通部分にspec"
"を作るというのは上手くいかない。利用される時ではなく入ってきた時にフェイルファストで悪いデータを検知することも容易にな"
"る。"

#. type: Plain text
#: en/content/about/spec.adoc:224
msgid ""
"Of course, many existing map-based interfaces take non-namespaced keys. To support connecting them to properly "
"namespaced and reusable specs, ``keys`` supports ``-un`` variants of ``:req`` and ``:opt``"
msgstr ""
"もちろん、多くの既存のマップベースのインターフェースはネームスペースなしのキーをとっている。正しくネームスペースが付い"
"て再利用可能なspecとの接続をサポートするため、 ``keys`` は ``:req`` と ``:opt`` の ``-un`` 変種をサポートしている。"

#. type: delimited block -
#: en/content/about/spec.adoc:228
#, no-wrap
msgid "(spec/keys :req-un [:my.ns/a :my.ns/b])\n"
msgstr "(spec/keys :req-un [:my.ns/a :my.ns/b])\n"

#. type: Plain text
#: en/content/about/spec.adoc:233
msgid ""
"This specs a map that requires the unqualified keys ``:a`` and ``:b`` but validates and generates them using specs "
"(when defined) named ``:my.ns/a`` and ``:my.ns/b`` respectively. Note that this cannot convey the same power to "
"unqualified keywords as have namespaced keywords - the resulting maps are not self-describing."
msgstr ""
"これは、非修飾のキー ``:a`` と ``:b`` を要求するが、それぞれ ``:my.ns/a`` と ``:my.ns/b`` という名前のspecを(定義され"
"ている場合に)利用してバリデーションと生成を行うマップを記述している。これは非修飾のキーワードがネームスペース付きキー"
"ワードが持つのと同等の力を伝えることはできないことに注意しよう。結果として得られるマップは自己記述的ではないのだ。"

#. type: Plain text
#: en/content/about/spec.adoc:237
msgid ""
"Specs for sequences/vectors use a set of standard regular expression operators, with the standard semantics of "
"regular expressions:"
msgstr "シーケンス/ベクターのためのspecは、正規表現の標準的なセマンティクスで一連の標準的な正規表現演算子を利用する:"

#. type: Plain text
#: en/content/about/spec.adoc:239
msgid "``cat`` - a concatenation of predicates/patterns"
msgstr "``cat`` - 述語/パターンの連結"

#. type: Plain text
#: en/content/about/spec.adoc:240
msgid "``alt`` - a choice of one among a set of predicates/patterns"
msgstr "``alt`` - 一連の述語/パターンから1つの選択"

#. type: Plain text
#: en/content/about/spec.adoc:241
msgid "``*`` - zero or more occurrences of a predicate/pattern"
msgstr "``*`` - 述語/パターンの0回以上の出現"

#. type: Plain text
#: en/content/about/spec.adoc:242
msgid "``+`` - one or more"
msgstr "``+`` - 1以上"

#. type: Plain text
#: en/content/about/spec.adoc:243
msgid "``?`` - one or none"
msgstr "``?`` - 1または0"

#. type: Plain text
#: en/content/about/spec.adoc:244
msgid "``&`` - takes a regex op and further constrains it with one or more predicates"
msgstr "``&`` - 正規表現演算子をとり、1個以上の述語でさらに制約する"

#. type: Plain text
#: en/content/about/spec.adoc:246
msgid "These nest arbitrarily to form complex expressions."
msgstr "これらは任意にネストして複合的な式を形成する。"

#. type: Plain text
#: en/content/about/spec.adoc:249
msgid ""
"Note that ``cat`` and ``alt`` require all of their components be labeled, and the return value of each is a map with "
"the keys corresponding to the matched components. In this way **spec** regexes act as destructuring and parsing tools."
msgstr ""
"``cat`` と ``alt`` はすべての構成要素がラベル付けされていることを要求し、それぞれ戻り値はマッチした構成要素に対応する"
"キーのマップであることに注意しよう。このように **spec** の正規表現は分配束縛やパース処理のツールとして振る舞う。"

#. type: delimited block -
#: en/content/about/spec.adoc:269
#, no-wrap
msgid ""
"user=> (require '[clojure.spec.alpha :as s])\n"
"(s/def ::even? (s/and integer? even?))\n"
"(s/def ::odd? (s/and integer? odd?))\n"
"(s/def ::a integer?)\n"
"(s/def ::b integer?)\n"
"(s/def ::c integer?)\n"
"(def s (s/cat :forty-two #{42}\n"
"              :odds (s/+ ::odd?)\n"
"              :m (s/keys :req-un [::a ::b ::c])\n"
"              :oes (s/* (s/cat :o ::odd? :e ::even?))\n"
"              :ex (s/alt :odd ::odd? :even ::even?)))\n"
"user=> (s/conform s [42 11 13 15 {:a 1 :b 2 :c 3} 1 2 3 42 43 44 11])\n"
"{:forty-two 42,\n"
" :odds [11 13 15],\n"
" :m {:a 1, :b 2, :c 3},\n"
" :oes [{:o 1, :e 2} {:o 3, :e 42} {:o 43, :e 44}],\n"
" :ex {:odd 11}}\n"
msgstr ""
"user=> (require '[clojure.spec.alpha :as s])\n"
"(s/def ::even? (s/and integer? even?))\n"
"(s/def ::odd? (s/and integer? odd?))\n"
"(s/def ::a integer?)\n"
"(s/def ::b integer?)\n"
"(s/def ::c integer?)\n"
"(def s (s/cat :forty-two #{42}\n"
"              :odds (s/+ ::odd?)\n"
"              :m (s/keys :req-un [::a ::b ::c])\n"
"              :oes (s/* (s/cat :o ::odd? :e ::even?))\n"
"              :ex (s/alt :odd ::odd? :even ::even?)))\n"
"user=> (s/conform s [42 11 13 15 {:a 1 :b 2 :c 3} 1 2 3 42 43 44 11])\n"
"{:forty-two 42,\n"
" :odds [11 13 15],\n"
" :m {:a 1, :b 2, :c 3},\n"
" :oes [{:o 1, :e 2} {:o 3, :e 42} {:o 43, :e 44}],\n"
" :ex {:odd 11}}\n"

#. type: Title ====
#: en/content/about/spec.adoc:271
#, no-wrap
msgid "conform/explain"
msgstr "conform/explain"

#. type: Plain text
#: en/content/about/spec.adoc:275
msgid ""
"As you can see above, the basic operation for using specs is ``conform``, which takes a spec and a value and returns "
"the conformed value or ``:clojure.spec.alpha/invalid`` if the value did not conform. When the value does not conform "
"you can call ``explain`` or ``explain-data`` to find out why it didn't."
msgstr ""
"上で見た通り、specを使うための基本操作は ``conform`` で、specと値をとって一致した値、もしくは値が一致しなかった場合に"
"は ``:clojure.spec.alpha/invalid`` を返す。値が一致しない時には ``explain`` または ``explain-data`` を呼び出してなぜ一"
"致しなかったのか調べることができる。"

#. type: Title ===
#: en/content/about/spec.adoc:276
#, no-wrap
msgid "Defining specs"
msgstr "specを定義する"

#. type: Plain text
#: en/content/about/spec.adoc:281
msgid ""
"The primary operations for defining specs are s/def, s/and, s/or, s/keys and the regex ops. There is a ``spec`` "
"function that can take a predicate function or expression, a set, or a regex op, and can also take an optional "
"generator which would override the generator implied by the predicate(s)."
msgstr ""
"specを定義するための主要な操作はs/def, s/and, s/or, s/keysと正規表現演算子だ。 述語関数または式、セット、もしくは正規"
"表現演算子をとり、述語が暗示するジェネレータをオーバーライドするオプションのジェネレータをとることもできる ``spec`` 関"
"数がある。"

#. type: Plain text
#: en/content/about/spec.adoc:285
msgid ""
"Note however, that ``def, and, or, keys`` spec fns and the regex ops can all take and use predicate functions and "
"sets directly - and do not need them to be wrapped by ``spec``. ``spec`` should only be needed when you want to "
"override a generator or to specify that a nested regex starts anew, vs being included in the same pattern."
msgstr ""
"しかし、 ``def, and, or, keys`` のspec関数と正規表現演算子はいずれも述語関数とセットを直接とって使うことができ、 "
"``spec`` でラップする必要はないことに注意しよう。 ``spec`` はジェネレータをオーバーライドしたい場合やネストした正規表"
"現が同じパターンに含まれるのではなく新しいパターンを開始するように記述したい場合にのみ必要となるはずだ。"

#. type: Title ====
#: en/content/about/spec.adoc:286
#, no-wrap
msgid "Data spec registration"
msgstr "データspecの登録"

#. type: Plain text
#: en/content/about/spec.adoc:292
msgid ""
"In order for a spec to be reusable by name, it has to be registered via ``def``.  ``def`` takes a namespace-qualified "
"keyword/symbol and a spec/predicate expression. By convention, specs for data should be registered under keywords and "
"attribute values should be registered under their attribute name keyword. Once registered, the name can be used "
"anywhere a spec/predicate is called for in any of the **spec** operations."
msgstr ""
"specを名前で再利用できるようにするためには、 ``def`` によって登録しなければならない。 ``def`` はネームスペース付きの"
"キーワード/シンボルとspec/述語の式をとる。規約により、データのためのspecはキーワードに登録し、属性値はその属性名のキー"
"ワードに登録するべきだ。ひとたび登録すれば、specの名前はあらゆる **spec** 操作でのspec/述語が必要なあらゆる場所で利用"
"することができる。"

#. type: Title ====
#: en/content/about/spec.adoc:293
#, no-wrap
msgid "Function spec registration"
msgstr "関数specの登録"

#. type: Plain text
#: en/content/about/spec.adoc:296
msgid ""
"A function can be fully specified via three specs - one for the args, one for the return, and one for the operation "
"of the function relating the args to the return."
msgstr ""
"関数は3つのspecで完全に記述することができる。引数のspec、戻り値のspec、引数を戻り値に対応付ける関数の操作のspecだ。"

#. type: Plain text
#: en/content/about/spec.adoc:299
msgid ""
"The args spec for a fn is always going to be a regex that specs the arguments as if they were a list, i.e. the list "
"one would pass to ``apply`` the function. In this way, a single spec can handle functions with multiple arities."
msgstr ""
"関数の引数のspecは常に引数がリスト、つまり ``apply`` 関数に渡すリストであるかのように記述する正規表現になる。これに"
"よって、単一のspecが複数のアリティを持つ関数を扱うことができる。"

#. type: Plain text
#: en/content/about/spec.adoc:301
msgid "The return spec is an arbitrary spec of a single value."
msgstr "戻り値のspecは単一の値についての任意のspecだ。"

#. type: Plain text
#: en/content/about/spec.adoc:306
msgid ""
"The (optional) fn spec is a further specification of the relationship between the arguments and the return, i.e. the "
"function of the function. It will be passed (e.g. during testing) a map containing ``{:args conformed-args :ret "
"conformed-ret}`` and will generally contain predicates that relate those values - e.g. it could ensure that all keys "
"of an input map are present in the returned map."
msgstr ""
"(オプションの)関数のspecは引数と戻り値の関係、つまりその関数の機能についてのさらなる仕様記述だ。これは(例えばテスト時"
"に) ``{:args conformed-args :ret conformed-ret}`` の入ったマップを受け取り、それらの値について説明する述語を一般に含む"
"だろう。例えば入力のマップのすべてのキーが戻り値のマップに存在することを保証することができるだろう。"

#. type: Plain text
#: en/content/about/spec.adoc:308
msgid ""
"You can fully specify all three specs of a function in a single call to ``fdef``, and recall the specs via ``fn-"
"specs``."
msgstr ""
"ある関数の3つすべてのspecを ``fdef`` 一度の呼び出しで指定することができ、それらのspecは ``fn-specs`` によって取り出す"
"ことができる。"

#. type: Title ===
#: en/content/about/spec.adoc:309
#, no-wrap
msgid "Using specs"
msgstr "specを使う"

#. type: Plain text
#: en/content/about/spec.adoc:313
msgid ""
"Functions specs defined via ``fdef`` will appear when you call ``doc`` on the fn name. You can call ``describe`` on "
"specs to get descriptions as forms."
msgstr ""
"``fdef`` によって定義された関数specは関数名に対して ``doc`` を呼び出すと現れる。specに対して ``describe`` を呼び出す"
"と、説明がフォームとして得られる。"

#. type: Title ====
#: en/content/about/spec.adoc:314
#, no-wrap
msgid "Parsing/destructuring"
msgstr "パース処理/分配束縛"

#. type: Plain text
#: en/content/about/spec.adoc:317
msgid ""
"You can use ``conform`` directly in your implementations to get its destructuring/parsing/error-checking.  "
"``conform`` can be used e.g. in macro implementations and at I/O boundaries."
msgstr ""
"``conform`` を実装の中で分配束縛/パース処理/エラーチェックのために直接使うことができる。 ``conform`` は例えばマクロの"
"実装やI/Oの境界で利用できる。"

#. type: Title ====
#: en/content/about/spec.adoc:318
#, no-wrap
msgid "During development"
msgstr "開発中に"

#. type: Plain text
#: en/content/about/spec.adoc:322
msgid ""
"You can selectively instrument functions and namespaces with ``instrument``, which swaps out the fn var with a "
"wrapped version of the fn that tests the ``:args`` spec. ``unstrument`` returns a fn to its original version. You can "
"generate data for interactive testing with ``gen/sample``."
msgstr ""
"``instrument`` で関数とネームスペースに選択的に組み込むことができる。これは関数のvarを ``:args`` specをテストするラッ"
"プされたバージョンの関数に差し替える。 ``uninstrument``は関数を元のバージョンに戻す。 ``gen/sample`` でインタラクティ"
"ブなテストのためにデータを生成することができる。"

#. type: Title ====
#: en/content/about/spec.adoc:323
#, no-wrap
msgid "For testing"
msgstr "テストのために"

#. type: Plain text
#: en/content/about/spec.adoc:330
msgid ""
"You can run a suite of spec-generative tests on an entire ns with ``check``. You can get a test.check compatible "
"generator for a spec by calling ``gen``. There are built-in associations between many of the ``clojure.core`` data "
"predicates and corresponding generators, and the composite ops of **spec** know how to build generators atop those. "
"If you call ``gen`` on a spec and it is unable to construct a generator for some subtree, it will throw an exception "
"that describes where. You can pass generator-returning fns to ``spec`` in order to supply generators for things spec "
"does not know about, and you can pass an override map to ``gen`` in order to supply alternative generators for one or "
"more subpaths of a spec."
msgstr ""
"``check`` でネームスペース全体に対して一連のspecによる生成的テストを実行することができる。 ``gen`` を呼び出すことで"
"test.ckeck互換のspecのジェネレータを得ることができる。 ``clojure.core`` のデータの述語の多くと対応するジェネレータとの"
"間には組み込みで関連があり、 **spec** の複合的な演算子はそこからどのようにジェネレータを組み立てるべきか分かってい"
"る。 specに対して ``gen`` を呼び出して一部のサブツリーについてジェネレータを組み立てることができないと、その場所を示す"
"例外がスローされる。 specに分からないものにジェネレータを提供するためにジェネレータを返す関数を ``spec``　に渡すことが"
"でき、また、specの1つ以上のサブパスで代わりになるジェネレータを提供するためのオーバーライドマップを ``gen`` に渡すこと"
"ができる。"

#. type: Title ====
#: en/content/about/spec.adoc:331
#, no-wrap
msgid "At runtime"
msgstr "実行時に"

#. type: Plain text
#: en/content/about/spec.adoc:334
msgid ""
"In addition to the destructuring use cases above, you can make calls to ``conform`` or ``valid?`` anywhere you want "
"runtime checking, and can make lighter-weight internal-only specs for tests you intend to run in production."
msgstr ""
"上述の分配束縛のユースケースに加えて、 ``conform`` や ``valid?`` を実行時のチェックを行いたい箇所でどこでも呼び出すこ"
"とができ、また、プロダクションで実行することを想定したテストのための内部利用限定の軽量なspecを作ることができる。"

#. type: Plain text
#: en/content/about/spec.adoc:336
msgid ""
"Please see the <<xref/../../../guides/spec#,spec Guide>> and https://clojure.github.io/spec.alpha/index.html[API "
"docs] for more examples and usage information."
msgstr ""
"さらなるサンプルと利用方法の情報は <<xref/../../../guides/spec#,specガイド>> と https://clojure.github.io/spec.alpha/index.html"
"[API docs] を参照。"

#. type: Title ===
#: en/content/about/spec.adoc:338
#, no-wrap
msgid "predicates"
msgstr "predicates (述語)"

#. type: Plain text
#: en/content/about/spec.adoc:340
msgid "Many parts of the spec API call for 'predicates' or 'preds'. These arguments can be satisfied by:"
msgstr ""
"spec APIの多くの部分で'predicates'(述語)つまり'preds'が必要となる。こうした引数は以下のもので満たすことができる:"

#. type: Plain text
#: en/content/about/spec.adoc:342
msgid "predicate (boolean) fns"
msgstr "述語(boolean)関数"

#. type: Plain text
#: en/content/about/spec.adoc:343
msgid "sets"
msgstr "セット"

#. type: Plain text
#: en/content/about/spec.adoc:344
msgid "registered names of specs"
msgstr "登録済みのspecの名前"

#. type: Plain text
#: en/content/about/spec.adoc:345
msgid "specs (the return values of ``spec``, ``and``, ``or``, ``keys``)"
msgstr "spec(``cat``, ``alt``, ``*``, ``+``, ``?``, ``&`` の戻り値)"

#. type: Plain text
#: en/content/about/spec.adoc:346
msgid "regex ops (the return values of ``cat``, ``alt``, ``*``, ``+``, ``?``, ``&``)"
msgstr "正規表現演算子(``cat``, ``alt``, ``*``, ``+``, ``?``, ``&`` の戻り値)"

#. type: Plain text
#: en/content/about/spec.adoc:349
msgid ""
"Note that if you want to nest an independent regex predicate within a regex you will have to wrap it in a call to "
"``spec``, else it will be considered a nested pattern."
msgstr ""
"独立した正規表現の述語を正規表現の中にネストさせたい場合には ``spec`` の呼び出しの中にラップしなければならず、そうしな"
"ければネストしたパターンとみなされることに注意しよう。"

#. type: Title ===
#: en/content/about/spec.adoc:350
#, no-wrap
msgid "specs"
msgstr "specs (仕様記述)"

#. type: Plain text
#: en/content/about/spec.adoc:352
msgid "The return values of ``spec``, ``and``, ``or`` and ``keys``."
msgstr "``spec``, ``and``, ``or``, ``keys`` の戻り値。"

#. type: Title ===
#: en/content/about/spec.adoc:353
#, no-wrap
msgid "regex ops"
msgstr "regex ops (正規表現演算子)"

#. type: Plain text
#: en/content/about/spec.adoc:355
msgid "The return values of ``cat``, ``alt``, ``*``, ``+``, ``?``, ``&``. When nested these form a single expression."
msgstr "``cat``, ``alt``, ``*``, ``+``, ``?``, ``&`` の戻り値。ネストするとこれらは単一の式になる。"

#. type: Title ===
#: en/content/about/spec.adoc:356
#, no-wrap
msgid "conform"
msgstr "conform (一致させる)"

#. type: Plain text
#: en/content/about/spec.adoc:361
msgid ""
"``conform`` is the basic operation for consuming specs, and does both validation and conforming/destructuring.  Note "
"that conforming is 'deep' and flows through all of the spec and regex operations, map specs etc.  Since ``nil`` and "
"``false`` are legitimate conformed values, conform returns the distinguished ``:clojure.spec.alpha/invalid`` when a "
"value cannot be made to conform. ``valid``? can be used instead as a fully-boolean predicate."
msgstr ""
"``conform`` はspecを利用する基本的な操作で、バリデーションと一致(conform)/分配束縛の両方を行う。conformは'deep'であ"
"り、すべてのspecと正規表現演算、マップのspecなどにわたることに注意しよう。 ``nil`` と ``false`` はconformした値として"
"正当なものなため、値がconformできない場合には特別な ``:clojure.spec.alpha/invalid`` が返される。"

#. type: Title ===
#: en/content/about/spec.adoc:362
#, no-wrap
msgid "explain"
msgstr "explain (説明する)"

#. type: Plain text
#: en/content/about/spec.adoc:368
msgid ""
"When a value fails to conform to a spec you can call ``explain`` or ``explain-data`` with the same spec+value to find "
"out why. These explanations are not produced during ``conform`` because they might perform additional work and there "
"is no reason to incur that cost for non-failing inputs or when no report is desired. An important component of "
"explanations is the __path__. ``explain`` extends the path as it navigates through e.g. nested maps or regex "
"patterns, so you get better information than just the entire or leaf value. ``explain-data`` will return a map of "
"paths to problems."
msgstr ""
"ある値がspecのconformに失敗する場合には、同じspec+値で ``explain`` または ``explain-data`` を呼び出して原因を調べるこ"
"とができる。こうした説明は、追加の作業をすることになるかもしれず、失敗しない入力やレポートが望ましくない場合にまでその"
"コストを負担する理由もないため、 ``conform`` 時には生成されない。説明の重要な構成要素は __パス__ だ。 ``explain`` は例"
"えばネストしたマップや正規表現パターンを通るにつれてパスを伸ばしていくため、単なる全体もしくは葉の値よりも良い情報が得"
"られる。 ``explain-data`` は問題箇所までのパスのマップを返す。"

#. type: Title ===
#: en/content/about/spec.adoc:369
#, no-wrap
msgid "paths"
msgstr "paths (パス)"

#. type: Plain text
#: en/content/about/spec.adoc:373
msgid ""
"Due to the fact that all __branching__ points in specs are labeled, i.e. map ``keys``, choices in ``or`` and ``alt``, "
"and (possibly elided) elements of ``cat``, every subexpression in a spec can be referred to via a __path__ (vector of "
"keys) naming the parts.  These paths are used in ``explain``, ``gen`` overrides and various error reporting."
msgstr ""
"例えばマップの ``keys`` や ``or`` と ``alt`` の選択肢、(省略されうる) ``cat`` の要素のようにspecのすべての __分岐__ 点"
"はラベル付けされていることから、specのあらゆる部分式はその部分に名前を付ける __パス__ (キーのベクター)によって指し示す"
"ことができる。こうしたパスは ``explain`` や ``gen`` のオーバーライド、様々なエラー報告に利用されている。"

#. type: Title ==
#: en/content/about/spec.adoc:374
#, no-wrap
msgid "Prior Art"
msgstr "先行技術"

#. type: Plain text
#: en/content/about/spec.adoc:378
msgid ""
"Almost nothing about spec is novel. See all the libraries mentioned above, https://www.w3.org/TR/2014/REC-rdf11-"
"concepts-20140225/[RDF], as well as all the work done on various contract systems, such as https://docs.racket-lang."
"org/guide/contracts.html[Racket's contracts]."
msgstr ""
"specにはほとんど何も新規なところはない。上で述べたライブラリや https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/"
"[RDF] 、また、コントラクトシステムについてなされてきた様々な業績、例えば https://docs.racket-lang.org/guide/contracts."
"html[Racketのコントラクト] を参照。"

#. type: Plain text
#: en/content/about/spec.adoc:380
#, no-wrap
msgid "*I hope you find spec useful and powerful.*\n"
msgstr "*specの有用性と強力さをぜひ知ってほしい。*\n"
