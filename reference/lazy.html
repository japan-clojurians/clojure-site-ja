<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>Clojure - Making Clojure Lazier</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clojure の日本語ドキュメントです">
    <meta name="author" content="Japan Clojurians">
    <meta name="keywords" content="Clojure 日本語">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/normalize.css" rel="stylesheet">
    <link href="../css/webflow.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" type="image/x-icon" href="../images/clojure-logo-icon-32.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">Clojure</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../about/rationale.html">概要</a></li>
            <li><a href="../reference/documentation">リファレンス</a></li>
            <!-- <li><a href="../api/api.html">API</a></li>
              <li><a href="../community/downloads.html">リリース</a></li>
              <li><a href="../guides/guides.html">ガイド</a></li>
              <li><a href="../community/resources.html">コミュニティ</a></li>
              <li><a href="../news/news.html">ニュース</a></li>
              <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
              <li><a href="#">Action</a></li>
              <li><a href="#">Another action</a></li>
              <li><a href="#">Something else here</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Nav header</li>
              <li><a href="#">Separated link</a></li>
              <li><a href="#">One more separated link</a></li>
              </ul>
              </li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

<div class="page-header">
  <h1>Making Clojure Lazier</h1>
</div>

<p><em></em></p>

<p><div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel2">
<li><a href="#_the_current_seq_model">The current seq model</a></li>
<li><a href="#_enhancing_the_seq_model_a_third_operation_on_seqs_next">Enhancing the seq model - a third operation on seqs - 'next'</a></li>
<li><a href="#_recipe_how_to_write_lazy_sequence_functions_in_new_model">Recipe - How to write lazy sequence functions in new model</a></li>
<li><a href="#_the_victim_nil_punning">The victim - nil punning</a></li>
<li><a href="#_extension_iseqs">Extension ISeqs</a></li>
<li><a href="#_recipe_porting">Recipe - Porting</a></li>
<li><a href="#_don_t_hang_onto_your_head">Don&#8217;t hang (onto) your head</a></li>
</ul>
</div>
<div class="paragraph">
<p><em>(Note: this page describes the changes made in the last large update to sequences, when Rich was also exploring an alternative called streams. Treat this page as a useful historical record of these design decisions, rather than as reference documentation.)</em></p>
</div>
<div class="paragraph">
<p>In working on streams a few things became evident:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>stream code is ugly and imperative</p>
<div class="ulist">
<ul>
<li>
<p>even when made safe, still ugly, stateful</p>
</li>
</ul>
</div>
</li>
<li>
<p>streams support full laziness</p>
<div class="ulist">
<ul>
<li>
<p>this ends up being extremely nice</p>
</li>
</ul>
</div>
</li>
<li>
<p>Integrating streams transparently (i.e. not having both map and map-stream) would require a change, to relax the contract of the core sequence functions (map, filter etc)</p>
<div class="ulist">
<ul>
<li>
<p>If I am going to do that, could I achieve the same full laziness while keeping the beautiful recursive style of Clojure?</p>
<div class="ulist">
<ul>
<li>
<p>while being substantially compatible with existing code</p>
</li>
<li>
<p>Yes!</p>
<div class="ulist">
<ul>
<li>
<p>but - ideally some names should change</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_current_seq_model">The current seq model</h3>
<div class="ulist">
<ul>
<li>
<p>Originally modeled on Common Lisp&#8217;s cons</p>
</li>
<li>
<p>Either you have a seq, with a valid first, or nothing (nil)</p>
</li>
<li>
<p>A seq is like a logical cursor</p>
</li>
<li>
<p>rest is fundamentally eager</p>
<div class="ulist">
<ul>
<li>
<p>returns another seq or nil</p>
</li>
<li>
<p>needs to determine if there is any more in order to determine if return value is nil</p>
</li>
<li>
<p>lazy-cons can delay the calculation of first/rest, but not the determination if there is a rest</p>
<div class="ulist">
<ul>
<li>
<p>determining that often requires 'pulling' on an inner seq, reducing effective laziness</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>sequence functions currently return a seq or nil</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The eagerness of <strong>rest</strong> means the sequence functions are not fully lazy, they need to at least determine if there is a first.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enhancing_the_seq_model_a_third_operation_on_seqs_next">Enhancing the seq model - a third operation on seqs - 'next'</h3>
<div class="ulist">
<ul>
<li>
<p><em><strong>Changed:</strong></em> (<strong>rest</strong> aseq) - returns a possibly empty seq, <em>never nil</em></p>
<div class="ulist">
<ul>
<li>
<p>calls seq on arg if not already a seq</p>
</li>
<li>
<p>the returned seq may be empty</p>
<div class="ulist">
<ul>
<li>
<p>will print (), but not a single sentinel object</p>
</li>
</ul>
</div>
</li>
<li>
<p>never returns nil</p>
<div class="ulist">
<ul>
<li>
<p>currently not enforced on 3rd-party seqs</p>
</li>
</ul>
</div>
</li>
<li>
<p>a (possibly) delayed path to the remaining items, if any</p>
</li>
</ul>
</div>
</li>
<li>
<p><em><strong>Changed</strong></em>: seqs can be empty</p>
<div class="ulist">
<ul>
<li>
<p>always an ISeq</p>
</li>
</ul>
</div>
</li>
<li>
<p><em><strong>Changed</strong></em>: the <strong>seq</strong> function - no longer an identity for ISeqs</p>
<div class="ulist">
<ul>
<li>
<p>still returns either a seq or nil</p>
</li>
<li>
<p>(seq aseq) &#8594; <em><em><strong>no longer an identity, if aseq empty returns nil</strong></em></em></p>
</li>
<li>
<p>still works on nil</p>
</li>
</ul>
</div>
</li>
<li>
<p>the <strong>first</strong> function doesn&#8217;t change</p>
<div class="ulist">
<ul>
<li>
<p>calls seq on arg if not already a seq</p>
</li>
<li>
<p>returns first item</p>
</li>
<li>
<p>still works on nil</p>
</li>
</ul>
</div>
</li>
<li>
<p><em><strong>New</strong>:</em> the <strong>next</strong> function does what <strong>rest</strong> used to do</p>
<div class="ulist">
<ul>
<li>
<p>returns the next seq, if any, else nil</p>
</li>
<li>
<p>calls seq on arg if not already a seq</p>
</li>
<li>
<p>(next aseq) === (seq (rest aseq))</p>
</li>
<li>
<p>works on nil</p>
</li>
</ul>
</div>
</li>
<li>
<p><em><strong>Changed</strong></em>: seq?</p>
<div class="ulist">
<ul>
<li>
<p>(seq? ()) &#8594; true</p>
</li>
</ul>
</div>
</li>
<li>
<p><em><strong>Changed:</strong></em> Sequence fns (map, filter etc) return seqs, but not nil</p>
<div class="ulist">
<ul>
<li>
<p>You&#8217;ll need to call seq on their return value in order to get a seq/nil</p>
<div class="ulist">
<ul>
<li>
<p>seq also serves as test for end, already idiomatic</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(when (seq coll)
  ...)</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>allows full laziness</p>
</li>
<li>
<p>doesn&#8217;t support nil punning</p>
<div class="ulist">
<ul>
<li>
<p>since sequence fns no longer return seq/nil</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_recipe_how_to_write_lazy_sequence_functions_in_new_model">Recipe - How to write lazy sequence functions in new model</h3>
<div class="ulist">
<ul>
<li>
<p>Goodbye lazy-cons, hello lazy-seq</p>
<div class="ulist">
<ul>
<li>
<p>lazy-cons is gone</p>
</li>
<li>
<p>new laziness macro - <em><strong>lazy-seq</strong></em></p>
<div class="ulist">
<ul>
<li>
<p>takes a body that yields a seq, nil or anything seq-able</p>
</li>
<li>
<p>returns a logical collection that implements seq by calling the body</p>
<div class="ulist">
<ul>
<li>
<p>invokes the body only the first time seq is called on it, caches result</p>
</li>
<li>
<p>will call seq on the body&#8217;s return value if not already a seq or nil</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The net effect is the creation of a virtual collection that does no work until seq is called upon it - fully delayed</p>
</li>
<li>
<p>Supports all collection ops</p>
</li>
<li>
<p>Can be empty - e.g. calling seq on it can return nil</p>
<div class="ulist">
<ul>
<li>
<p>when empty will print as ()</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>lazy-seq goes at top level of lazy sequence function</p>
<div class="ulist">
<ul>
<li>
<p>instead of nested lazy-cons</p>
</li>
</ul>
</div>
</li>
<li>
<p>inside, use a normal cons call</p>
<div class="ulist">
<ul>
<li>
<p>won&#8217;t be created until needed</p>
</li>
</ul>
</div>
</li>
<li>
<p>if consuming another seq, use rest instead of next</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The old way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn map
  ([f coll]
   (when (seq coll)
     (lazy-cons (f (first coll)) (map f (rest coll)))))
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The new way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn map
  ([f coll]
   (lazy-seq
    (when-let [s (seq coll)]
      (cons (f (first s)) (map f (rest s))))))
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the use of when-let, which grabs the seq once, for subsequent use in first and rest, even though first/rest call seq on their argument. This has a performance benefit in this new model.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_victim_nil_punning">The victim - nil punning</h3>
<div class="paragraph">
<p>One of the nice things about CL&#8217;s cons using nil for end-of-list is that, when coupled with nil&#8217;s testability in conditionals, cons-returning functions could be used like predicates. Now only <strong>seq</strong> and <strong>next</strong> can be used in that manner - map, filter etc cannot. Note that much of the economy of the seq/nil dyad still applies, e.g. the use of when in map above.</p>
</div>
</div>
<div class="sect2">
<h3 id="_extension_iseqs">Extension ISeqs</h3>
<div class="paragraph">
<p>If you are extending ISeq you&#8217;ll need to support <strong>ISeq.more()</strong> (the underpinnings of rest). Fortunately, most ISeq extenders derive from ASeq, which defines <strong>more()</strong> in terms of <strong>next</strong>. If you derive your seq from ASeq, <em>don&#8217;t define more()</em>, use the version supplied by ASeq. Just rename your rest() method to next().</p>
</div>
</div>
<div class="sect2">
<h3 id="_recipe_porting">Recipe - Porting</h3>
<div class="paragraph">
<p>To move to the new model you&#8217;ll need to take the following steps, in this order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rename all your calls to <strong>rest</strong> to call <strong>next</strong></p>
</li>
<li>
<p>If you were defining your own lazy sequence functions, using <strong>lazy-cons</strong>, switch them over to <strong>lazy-seq</strong> using the recipe above. Make sure to call <strong>rest</strong> and not <strong>next</strong> in your recursive call.</p>
</li>
<li>
<p>Audit your code for nil-punning. The lazy branch has supports compilation in a debug mode that asserts if you try to test the truth value of a lazy sequence in a conditional, and will throw an exception if you do. Just build clojure like so:</p>
<div class="ulist">
<ul>
<li>
<p>ant -Dclojure.assert-if-lazy-seq=true</p>
</li>
<li>
<p>Then, nil puns like the following will throw exceptions:</p>
<div class="ulist">
<ul>
<li>
<p>(when (filter neg? [1 2]) :all-pos)</p>
</li>
<li>
<p>(not (concat))</p>
</li>
<li>
<p>(if (rest (seq [])) 1 2)</p>
</li>
</ul>
</div>
</li>
<li>
<p>In all cases you can fix a nil pun by wrapping the sequence with a seq call:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(when (seq (filter neg? [1 2])) :all-pos)
-&gt; nil</code></pre>
</div>
</div>
</li>
<li>
<p>After you are done, rebuild without the flag, as it will slow things down.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_don_t_hang_onto_your_head">Don&#8217;t hang (onto) your head</h3>
<div class="paragraph">
<p>Recursively defined lazy sequence functions are elegant and easy to understand. They can be very memory efficient, allowing you to work with data sources that might not fit in memory, because only the part of the data structure in current use need be in memory. It could be tricky at times to determine which parts were currently in use, as they might still be referenced by local variables. Clojure does local-variable clearing on tail calls to ensure that no lingering references remain on the stack, but there was one remaining case - closed-over locals, that was difficult to control, especially when using a macro like lazy-seq which creates a closure on your behalf.</p>
</div>
<div class="paragraph">
<p>Consider the original, not fully lazy, definition of filter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn filter
  "Returns a lazy seq of the items in coll for which
  (pred item) returns true. pred must be free of side-effects."
  [pred coll]
    (when (seq coll)
      (if (pred (first coll))
        (lazy-cons (first coll) (filter pred (rest coll)))
        (recur pred (rest coll)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>By recurring to the fn itself, it is effectively erasing the coll argument each iteration, so it looks like it wouldn&#8217;t retain coll while skipping elements not matching the predicate. The problem is that sometimes the call to filter is in the lazy-cons, which expands into a closure that closes over coll, thus retaining it while the looping occurs, and there is nothing the called function can do about it. This means that expressions like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(filter #(= % 20) (map inc (range 10000000)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>could cause out of memory exceptions. The only way to avoid it was to rewrite filter using mutation. Bleh.</p>
</div>
<div class="paragraph">
<p>The new filter looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn filter
  "Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects."
  [pred coll]
  (let [step (fn [p c]
                 (when-let [s (seq c)]
                   (if (p (first s))
                     (cons (first s) (filter p (rest s)))
                     (recur p (rest s)))))]
    (lazy-seq (step pred coll))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The body of the old filter has been put in a helper fn, and lazy-cons replaced with cons, then the whole call is wrapped in a lazy-seq, following the recipe above. However lazy-seq also creates a closure which closes over coll. Without some enhancement, this filter, while lazier, will have the same memory footprint as the old. The new lazy branch contains a compiler enhancement for this and similar scenarios. <strong>lazy-seq</strong> and <strong>delay</strong> both perform closed-over local clearing on the tail call of their body, ensuring no references remain in the closure itself when the tail-call executes. They can do this because they cache the results, and thus know the closure will be invoked only once. Thus the lazy branch has no problems with the filter expression above, and you can use similar techniques to control memory usage in your own lazy functions.</p>
</div>
</div></p>

<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>

  </body>
</html>