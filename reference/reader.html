<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>Clojure - Reader(リーダー)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clojure の日本語ドキュメントです">
    <meta name="author" content="Japan Clojurians">
    <meta name="keywords" content="Clojure 日本語">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/normalize.css" rel="stylesheet">
    <link href="../css/webflow.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" type="image/x-icon" href="../images/clojure-logo-icon-32.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">Clojure</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../about/rationale.html">概要</a></li>
            <li><a href="../reference/documentation">リファレンス</a></li>
            <!-- <li><a href="../api/api.html">API</a></li>
              <li><a href="../community/downloads.html">リリース</a></li>
              <li><a href="../guides/guides.html">ガイド</a></li>
              <li><a href="../community/resources.html">コミュニティ</a></li>
              <li><a href="../news/news.html">ニュース</a></li>
              <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
              <li><a href="#">Action</a></li>
              <li><a href="#">Another action</a></li>
              <li><a href="#">Something else here</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Nav header</li>
              <li><a href="#">Separated link</a></li>
              <li><a href="#">One more separated link</a></li>
              </ul>
              </li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

<div class="page-header">
  <h1>Reader(リーダー)</h1>
</div>

<p><em></em></p>

<p><div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_reader_forms_リーダーフォーム">Reader forms (リーダーフォーム)</a>
<ul class="sectlevel2">
<li><a href="#_symbols_シンボル">Symbols (シンボル)</a></li>
<li><a href="#_リテラル">リテラル</a></li>
<li><a href="#_lists_リスト">Lists (リスト)</a></li>
<li><a href="#_vectors_ベクター">Vectors (ベクター)</a></li>
<li><a href="#_maps_マップ">Maps (マップ)</a></li>
<li><a href="#_sets_セット">Sets (セット)</a></li>
<li><a href="#_deftype_defrecord_及びコンストラクタの呼び出し_version_1_3以降">deftype、defrecord、及びコンストラクタの呼び出し (version 1.3以降):</a></li>
</ul>
</li>
<li><a href="#macrochars">Macro characters (マクロキャラクター)</a>
<ul class="sectlevel2">
<li><a href="#_quote_クォート">Quote (') (クォート)</a></li>
<li><a href="#_character_文字">Character (\) (文字)</a></li>
<li><a href="#_comment_コメント">Comment (;) (コメント)</a></li>
<li><a href="#_deref">Deref (@)</a></li>
<li><a href="#_metadata_メタデータ">Metadata (^) (メタデータ)</a></li>
<li><a href="#_dispatch_ディスパッチ">Dispatch (#) (ディスパッチ)</a></li>
<li><a href="#syntax-quote">Syntax-quote (シンタックスクォート) (`, バッククォートである点について注意), Unquote (アンクォート)(~) 及び Unquote-splicing (アンクォートスプライシング) (~@)</a></li>
</ul>
</li>
<li><a href="#_extensible_data_notation_edn_拡張可能なデータ記法">extensible data notation (edn) (拡張可能なデータ記法)</a></li>
<li><a href="#tagged_literals">Tagged Literals (タグ付きリテラル)</a>
<ul class="sectlevel2">
<li><a href="#_built_in_tagged_literals">Built-in tagged literals</a></li>
</ul>
</li>
<li><a href="#_reader_conditionals_リーダーコンディショナル">Reader Conditionals (リーダーコンディショナル)</a></li>
</ul>
</div>
<div class="paragraph">
<p>Clojureには <a href="http://en.wikipedia.org/wiki/Homoiconicity">同図像性</a>
という特性がある。同図像性というのはClojureのプログラムはClojureのデータ構造で表現されることを高尚に説明する言葉だ。これはClojure(及びCommon
Lisp)とその他のプログラミング言語の間の重要な差だ。- Clojureはストリームやファイルの中の文法 <strong>ではなく</strong>
、データ構造の評価で定義される。Clojureプログラムが他のClojureプログラムを操作や変形、あるいは創り出すということはとても一般的で、簡単に行うことができる。</p>
</div>
<div class="paragraph">
<p>とはいうものの、ほとんどのClojureプログラムはテキストファイルとして作成される。このテキストをパースし、コンパイラが解釈できるデータ構造を生成するのがreaderの役割だ。
<em>reader</em> とClojureのデータの表現はXMLやJSON等を使うような文脈でも使用できる。</p>
</div>
<div class="paragraph">
<p>readerの文法は文字で定義されており、Clojureの言語はシンボル、リスト、ベクター、マップetc
によって定義されていると言う人もいるかもしれない。実際にはreaderはフォームを(文字ではなく)ストリームから読み込み、そのフォームによって表現されるオブジェクトを返す
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read">read</a>
関数によって表現されている。</p>
</div>
<div class="paragraph">
<p>どこかしらから解説を始める必要があるので、このリファレンスでは評価の最初の段階にあたるリーダーフォームの解説から始めている。これには必然的にデータ構造の詳細な解説とコンパイラによる解釈が付随する。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reader_forms_リーダーフォーム">Reader forms (リーダーフォーム)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_symbols_シンボル">Symbols (シンボル)</h3>
<div class="ulist">
<ul>
<li>
<p>シンボルは数字でない文字で始まり、英数字及び*、+、!、 -、 _、 '、?を含むことができる(将来他の文字が許容される可能性もある)。</p>
</li>
<li>
<p>'/' には特別な意味があり、シンボルの途中に含むことでネームスペースとシンボルの名前を分割することができる(例：
'my-namespace/foo')。'/'単体は除算関数を指す。</p>
</li>
<li>
<p>'.' には特別な意味がある - シンボルの途中に含むことで完全修飾されたクラス名 (例：
'java.util.BitSet')、またはネームスペースを指定することができる。'.'
で開始、または終了するシンボルはClojureに予約されている。/ か . を含むシンボルは「修飾されている」と呼ばれる。</p>
</li>
<li>
<p>':' で開始、もしくは終了する文字はClojureによって予約されている。シンボルには一つ、もしくは連続しない':'を含むことができる。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_リテラル">リテラル</h3>
<div class="ulist">
<ul>
<li>
<p>Strings (文字列リテラル) - "ダブルクォート"
で囲まれている。複数行にまたがることもできる。標準のJavaエスケープ文字がサポートされている。</p>
</li>
<li>
<p>Numbers (数字リテラル) - 一般的に Java と同様に表記される。</p>
<div class="ulist">
<ul>
<li>
<p>Integer (整数)は長さの制限がなく、longの範囲内にある時はLongとして読み込まれ、それ以外の場合には
clojrue.lang.BigIntとして読み込まれる。末尾にNが付いている整数は常にBigIntとして読み込まれる。可能な場合には2から36の基数を指定して表記することができる。(参照:
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#parseLong(java.lang.String,%20int)">Long.parseLong()</a>)。
例えば <code>2r101010</code>、<code>8r52</code>、<code>36r16</code>,<code>42</code> は全て同じLongになる。</p>
</li>
<li>
<p>浮動少数はDoubleとして読み込まれる。末尾にMが付いているとBigDecimalとして読み込まれる。</p>
</li>
<li>
<p>分数もサポートされている。 (例： <code>22/7</code>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Characters (文字リテラル) - 先頭にバックスラッシュが付いている：<code>\c</code>、 <code>\newline</code>、<code>\space</code>、 <code>\tab</code>、
<code>\formfeed</code>、 <code>\backspace</code>、 <code>\return</code> はそれぞれの文字を意味する。ユニコード文字はJavaと同じく <code>\uNNNN</code>
と表記される。8進数は <code>\oNNN</code> と表記される。</p>
</li>
<li>
<p><code>nil</code> は&#8217;何もない、もしくは値がない&#8217;ことを意味する - Javaのnullを表現し、論理的なテストではfalseになる。</p>
</li>
<li>
<p>Booleans (ブーリアンリテラル) - <code>true</code> と <code>false</code></p>
</li>
<li>
<p>Keywords (キーワード) - キーワードはシンボルと似ているが、以下の点で異なる:</p>
<div class="ulist">
<ul>
<li>
<p>コロン(:) で始まらなければならない(例：:fred)。</p>
</li>
<li>
<p>'.'を含めたりクラスの名前に使用したりできない。</p>
</li>
<li>
<p>シンボルと同様にネームスペースを含むことができる。 <code>:person/name</code></p>
</li>
<li>
<p>コロン2つで始まるキーワードは現在のネームスペースにおいて修飾されたキーワードに自動的に解決される:</p>
<div class="ulist">
<ul>
<li>
<p>キーワードが修飾されていない場合、そのネームスペースは現在のネームスペースになる。 <code>user</code> では <code>::rect</code> は
<code>user/rect</code> として読み込まれる。</p>
</li>
<li>
<p>キーワードが修飾されている場合、そのネームスペースは現在のネームスペースでのエイリアスを利用して解決される。 <code>x</code> が <code>example</code>
にエイリアスされたネームスペースでは、 <code>::x/foo</code> は <code>:example/foo</code> に解決される。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_lists_リスト">Lists (リスト)</h3>
<div class="paragraph">
<p>Listは0個以上の丸括弧で括られたフォーム: <code>(a b c)</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_vectors_ベクター">Vectors (ベクター)</h3>
<div class="paragraph">
<p>ベクターは0個以上の角括弧で括られたフォーム: <code>[1 2 3]</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_maps_マップ">Maps (マップ)</h3>
<div class="ulist">
<ul>
<li>
<p>マップは波括弧で括られた0個以上のキー/バリューの対: <code>{:a 1 :b 1}</code></p>
</li>
<li>
<p>カンマは空白と同様に扱われ、マップの対を区切ることにも使える。<code>{:a 1, :b 2}</code></p>
</li>
<li>
<p>キーとバリューにはどのようなフォームも使用できる。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="map_namespace_syntax">ネームスペース付きマップ記法</h4>
<div class="paragraph">
<p><em>Added in Clojure 1.9</em></p>
</div>
<div class="paragraph">
<p>マップのリテラルには任意でキーに対するデフォルトのネームスペースコンテキストを <code>#:ns</code> プレフィックスによって指定することが可能で、その場合
<em>ns</em> にはネームスペースの名前を指定し、プレフィックスはマップの <code>{</code> の前に置く。加えて <code>#::</code>
を使用してキーワードのネームスペースの解決と同じセマンティクスで自動的にネームスペースを解決することができる。</p>
</div>
<div class="paragraph">
<p>ネームスペース付きのマップリテラルの文法に対する読み込みは通常のマップに対する読み込みと以下の点が異なる:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>キー</p>
<div class="ulist">
<ul>
<li>
<p>ネームスペースの指定がないキーもしくはシンボルはデフォルトのネームスペースで読み込まれる。</p>
</li>
<li>
<p>ネームスペースの指定があるシンボルもしくはキーワードは影響されずに読み込まれる。 <strong>ただし</strong> 、特別なネームスペース <code>_</code>
は読み込み時に取り除かれるので扱いが異なる。これを使用することでネームスペースの指定があるマップの中で、ネームスペースの指定がないキーワード、シンボルを使用することが可能になる。</p>
</li>
<li>
<p>キーワード、シンボルでないキーは影響を受けない。</p>
</li>
</ul>
</div>
</li>
<li>
<p>バリュー</p>
<div class="ulist">
<ul>
<li>
<p>バリューは影響されない。</p>
</li>
<li>
<p>ネストしたマップリテラルのキーは影響されない。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>例として以下のネームスペース指定付きの以下のマップ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">#:person{:first "Han"
         :last "Solo"
         :ship #:ship{:name "Millenium Falcon"
                      :model "YT-1300f light freighter"}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>は以下のように読み込まれる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">{:person/first "Han"
 :person/last "Solo"
 :person/ship {:ship/name "Millenium Falcon"
               :ship/model "YT-1300f light freighter"}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sets_セット">Sets (セット)</h3>
<div class="paragraph">
<p>セットは0個以上の、先頭に <code>#</code> を持つ波括弧で括られたフォーム： <code>#{:a :b :c}</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_deftype_defrecord_及びコンストラクタの呼び出し_version_1_3以降">deftype、defrecord、及びコンストラクタの呼び出し (version 1.3以降):</h3>
<div class="ulist">
<ul>
<li>
<p>Javaのクラス、deftype、defrecordのコンストラクタは完全修飾されたクラス名の先頭に#を、末尾にベクターを付けることで呼び出すことができる:
<code>#my.klass_or_type_or_record[:a :b :c]</code><br></p>
</li>
<li>
<p>ベクターの中の要素は <strong>評価されずに</strong>
各コンストラクタに渡される。defrecordのインスタンスはマップを代わりに受け取る似たようなフォームを使用して作成することができる:
<code>my.record{:a 1, :b 2}</code><br></p>
</li>
<li>
<p>キーを付与されたバリューは <strong>評価されずに</strong>
defrecordのフィールドに割り当てられる。マップリテラルに対応するエントリーがないdefrecordのフィールドにはnilが割り当てられる。defrecordで定義されている以外のキーに対応するバリューは結果のdefrecordインスタンスに追加される。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="macrochars">Macro characters (マクロキャラクター)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>リーダーの挙動はリーダー自身に組み込まれている定義とリードテーブルによる拡張システムの組み合わせで決定される。read
tableのエントリーはマクロキャラクターと呼ばれる特定の文字に対応する、リーダーマクロと呼ばれるる読み込みの動作のマッピングを定義する。特別な指定がない限り、マクロキャラクターはユーザーシンボルに含めることはできない</p>
</div>
<div class="sect2">
<h3 id="_quote_クォート">Quote (') (クォート)</h3>
<div class="paragraph">
<p><code>'form</code> &#8658; <code>(quote form)</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_character_文字">Character (\) (文字)</h3>
<div class="paragraph">
<p>上記のように文字リテラルを生成する。文字リテラルの例: <code>\a \b \c</code></p>
</div>
<div class="paragraph">
<p>以下の特殊文字は汎用的に使われる文字として使用できる: <code>\newline</code>, <code>\space</code>, <code>\tab</code>, <code>\formfeed</code>,
<code>\backspace</code>, and <code>\return</code>.</p>
</div>
<div class="paragraph">
<p>UnicodeのサポートはJavaの規約に準拠しており、Javaのバージョンに対応するサポートがある。Unicodeのリテラルは <code>\uNNNN</code>
の形式となる。例えばΩのリテラルは <code>\u03A9</code> になる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_comment_コメント">Comment (;) (コメント)</h3>
<div class="paragraph">
<p>単一行コメント。セミコロンから行末までをreaderに無視させる効果がある。</p>
</div>
</div>
<div class="sect2">
<h3 id="_deref">Deref (@)</h3>
<div class="paragraph">
<p><code>@form &#8658; (deref form)</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_metadata_メタデータ">Metadata (^) (メタデータ)</h3>
<div class="paragraph">
<p>メタデータは次のようなオブジェクトと関連のあるマップだ：シンボル、リスト、ベクター、マップ、IMetaを返すタグ付きリテラル、レコード、タイプ、及びコンストラクタ呼び出し。メタデータのリーダーマクロは最初にメタデータを読み込み、それを次に読み込むフォームに関連付ける。(オブジェクトにメタデータを関連付けるには
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/with-meta">with-meta</a>
を参照):
<code>^{:a 1 :b 2} [1 2 3]</code> は <code>{:a 1 :b 2}</code> をメタデータマップにもつ <code>[1 2 3]</code> を生成する。</p>
</div>
<div class="paragraph">
<p>簡略化したバージョンではメタデータを単純なシンボルもしくは文字列として指定できる。その場合メタデータはキーを:tag,バリューを(解決後の)シンボルもしくは文字列とした単一エントリーのマップになる。例:
<code>^String x</code> は <code>^{:tag java.lang.String} x</code> と同等。</p>
</div>
<div class="paragraph">
<p>このようなタグはコンパイラーに型情報を渡すことに使用できる。</p>
</div>
<div class="paragraph">
<p>もう一つの簡略した表記ではメタデータにキーワードを使用できる。その場合、メタデータはキーを指定したキーワードバリューをtrueとした単一エントリーのマップとして扱われる:
<code>^:dynamic x</code> は <code>^{:dynamic true} x</code> と同等。</p>
</div>
<div class="paragraph">
<p>メタデータはチェインすることができる。その場合、メタデータは右から左へとマージされる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_dispatch_ディスパッチ">Dispatch (#) (ディスパッチ)</h3>
<div class="paragraph">
<p>ディスパッチマクロはリーダーに、後に続く文字でインデックスされた別のテーブルに定義されているリーダーマクロを使用させる。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>#{} - 上記のセットを参照</p>
</li>
<li>
<p>正規表現パターン (#"pattern")</p>
<div class="paragraph">
<p>正規表現パターンは <em>読み込み時に</em> コンパイルされる。コンパイルした結果のオブジェクトは
java.util.regex.Patternタイプになる。正規表現のエスケープ文字のルールは文字列とは異なる。特にバックスラッシュはそれ自身として扱われる。(なのでエスケープするためにもうひとつバックスラッシュを付ける必要がない)。例えば、
<code>(re-pattern "\\s*\\d+")</code> は簡潔に <code>#"\s*\d+"</code> と書ける。</p>
</div>
</li>
<li>
<p>Var-quote (#')</p>
<div class="paragraph">
<p><code>#'x</code> &#8658; <code>(var x)</code></p>
</div>
</li>
<li>
<p>無名関数リテラル (#())</p>
<div class="paragraph">
<p><code>#(&#8230;&#8203;)</code> &#8658; <code>(fn [args] (&#8230;&#8203;))</code> + ここで引数は%、%n
、%nまたは%&amp;の形をとる引数リテラルの存在によって決定される。%は%1と同義で、 %nは(1から始まる)n番目の引数を指定し、%&amp;
はrest引数を指定する。これは
<a href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/fn">fn</a>
を置き換えるものではない - 慣習的には短く一度しか使用しないマッピングやフィルター関数などのために利用する。#()フォームをネストすることはできない。</p>
</div>
</li>
<li>
<p>次のフォームを無視する (#_)</p>
<div class="paragraph">
<p>#_
の後に続くフォームはreaderによって完全に無視される。(<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/comment">comment</a>
マクロはnilを返すのでこちらの方がより完全なフォームの除去になる)。</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="syntax-quote">Syntax-quote (シンタックスクォート) (`, バッククォートである点について注意), Unquote (アンクォート)(~) 及び Unquote-splicing (アンクォートスプライシング) (~@)</h3>
<div class="paragraph">
<p>シンボル、リスト、ベクター、セット、マップ以外のフォームについては `xと&#8217;xは同等。</p>
</div>
<div class="paragraph">
<p>シンボルに対してシンタックスクォートはシンボルを現在のコンテキストで <em>解決</em> し、完全修飾されたシンボルを生成する。(例:
namespace/name もしくは
fully.qualified.Classname)。シンボルがネームスペースで修飾されておらず、'#'で終わる場合、同じ名前に'_'とユニークなIDを末尾につけた自動生成されたシンボルに解決される。例:
x# は x_123に解決される。同じシンタックスクォート内での同じシンボルに対する参照は同一の自動生成されたシンボルに解決される。</p>
</div>
<div class="paragraph">
<p>リスト/ベクター/セット/マップに対するシンタックスクォートは対応するデータ構造のテンプレートを設ける。テンプレートの内部では未修飾のフォームはあたかも再帰的にシンタックスクォートされたように振る舞うが、アンクォートもしくはアンクォートスプライシング修飾することでフォームを再帰的なシンタックスクォートの対象から外すことができる。その場合、フォームは式として扱われ、テンプレートの中でそれぞれその値、もしくは値のシークエンスで置き換えられる。</p>
</div>
<div class="paragraph">
<p>例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">user=&gt; (def x 5)
user=&gt; (def lst '(a b c))
user=&gt; `(fred x ~x lst ~@lst 7 8 :nine)
(user/fred user/x 5 user/lst a b c 7 8 :nine)</code></pre>
</div>
</div>
<div class="paragraph">
<p>現在リードテーブルをユーザープログラムからアクセスすることはできない。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensible_data_notation_edn_拡張可能なデータ記法">extensible data notation (edn) (拡張可能なデータ記法)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clojureのreaderは <a href="https://github.com/edn-format/edn">extensible data notation
(edn)</a>のスーパーセットをサポートしている。ednの仕様の策定は現在活動的に行われおり、Clojureのデータの文法のサブセットを定義することでこのドキュメントを言語に依らない形で補完している。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tagged_literals">Tagged Literals (タグ付きリテラル)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>タグ付きリテラルはednのClojureによる実装
<a href="https://github.com/edn-format/edn#tagged-elements">tagged elements</a>.</p>
</div>
<div class="paragraph">
<p>Clojure が起動する際、クラスパスのルート位置から <code>data_readers.clj</code>
という名前がついたファイルが探される。それらのファイルには次のようなシンボルをClojureマップに書く:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">{foo/bar my.project.foo/bar
 foo/baz my.project/baz}</code></pre>
</div>
</div>
<div class="paragraph">
<p>各ペアのキーはClojureリーダーによって認識されるタグとなる。ペアのバリューは完全修飾された <a href="vars">Var</a>
の名前であり、リーダーがタグの後に続くフォームをパースするために参照される。例えば上記の <code>data_eaders.clj</code>
ファイルが与えられた場合、Clojureのリーダーはこのフォームを次のようにパースする:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">#foo/bar [1 2 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Var <code>#'my.project.foo/bar</code> をベクター <code>[1 2 3]</code>
に対して呼び出す。データリーダー関数はフォームが通常のClojureデータ構造としてリーダーに読み込まれた後に呼び出される。</p>
</div>
<div class="paragraph">
<p>ネームスペースで修飾されていないリーダータグはClojureのために確保されている。デフォルトのリーダータグは
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/default-data-readers">default-data-readers</a>
で定義されているが、 <code>data_readers.clj</code> で上書きすることもできるし、
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2Adata-readers%2A">*data-readers*</a>
を再束縛することもできる。 タグに対してデータリーダーが見つからなかった場合、
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/%2Adefault-data-reader-fn%2A">*default-data-reader-fn*</a>
で束縛されている関数がタグと値と共に呼びだされ値が作り出される。 *default-data-reader-fn*
がnilの場合(デフォルト)RuntimeExceptionが発生する。</p>
</div>
<div class="sect2">
<h3 id="_built_in_tagged_literals">Built-in tagged literals</h3>
<div class="paragraph">
<p>Clojure 1.4 introduced the <em>instant</em> and <em>UUID</em> tagged literals. Instants
have the format <code>#inst "yyyy-mm-ddThh:mm:ss.fff+hh:mm"</code>.  NOTE: Some of the
elements of this format are optional. See the code for details.  The default
reader will parse the supplied string into a <code>java.util.Date</code> by
default. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(def instant #inst "2018-03-28T10:48:00.000")
(= java.util.Date (class instant))
;=&gt; true</pre>
</div>
</div>
<div class="paragraph">
<p>Since pass[<strong>data-readers</strong>] is a dynamic var that can be bound, you can
replace the default reader with a different one. For example,
<code>clojure.instant/read-instant-calendar</code> will parse the literal into a
<code>java.util.Calendar</code>, while <code>clojure.instant/read-instant-timestamp</code> will
parse it into a <code>java.util.Timestamp</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(binding [*data-readers* {'inst read-instant-calendar}]
  (= java.util.Calendar (class (read-string instant))))
;=&gt; true

(binding [*data-readers* {'inst read-instant-timestamp}]
  (= java.util.Timestamp (class (read-string instant))))
;=&gt; true</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>#uuid</code> tagged literal will be parsed into a <code>java.util.UUID</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(= java.util.UUID (class (read-string "#uuid \"3b8a31ed-fd89-4f1b-a00f-42e3d60cf5ce\"")))
;=&gt; true</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reader_conditionals_リーダーコンディショナル">Reader Conditionals (リーダーコンディショナル)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clojure 1.7 で複数のClojureプラットフォームの間でロードできるポータブルなファイルのための新しい拡張子
(.cljc)が導入された。プラットフォームに特有なコードを管理する主なメカニズムはプラットフォームに特有なコードをできるだけ小さなネームスペースに隔離し、それらのプラットフォーム毎のバージョン(.clj/.class
or.cljs)を用意することだ。</p>
</div>
<div class="paragraph">
<p>プラットフォーム毎に異なるコードを隔離することが現実的ではない場合やコードがほとんどポータブルでプラットフォーム特有の部分がごく少ない場合のために1.7で
cljcとデフォルトREPLでのみ使える <em>リーダーコンディショナル</em> が導入された。<em>リーダーコンディショナル</em>
は控えめに、必要な時だけ使うことが推奨される。</p>
</div>
<div class="paragraph">
<p>リーダーコンディショナルは <code>#?</code> もしくは <code>#?@</code> で始まる新しいディスパッチフォームだ。どちらも <code>cond</code>
と似たような形でフィーチャーと式を含む。全てのClojureプラットフォームはよく知られた "プラットフォームフィーチャー" が存在する -
<code>:clj</code>, <code>:cljs</code>,
<code>:cljr</code>。リーダーコンディショナルの条件はプラットフォームにマッチするフィーチャーが見つかるまで順番に検査され、そのフィーチャーの式を読み込んで返す。マッチしなかった分岐の式は読み込まれはするが、スキップされる。よく知られた
<code>:default</code>
フィーチャーは必ずマッチするためデフォルトとして使える。マッチするブランチが存在しない場合、フォームは一切読み込まれない(リーダーコンディショナルが最初から存在しないのと同等)。</p>
</div>
<div class="paragraph">
<p>以下の例はClojureでは Double/NaN ClojureScript では
js/NaN、それ以外のプラットフォームではnilとして読み込まれる。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">#?(:clj     Double/NaN
   :cljs    js/NaN
   :default nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>#?@</code>
の文法は全く同じだが、アンクォートスプライシングと同様に周りのコンテキストにスプライス可能なコレクションを返す式が期待される。リーダーコンディショナルスプライシングをトップレベルで使用することはサポートされておらず、例外が発生する。例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">[1 2 #?@(:clj [3 4] :cljs [5 6])]
;; in clj =&gt;        [1 2 3 4]
;; in cljs =&gt;       [1 2 5 6]
;; anywhere else =&gt; [1 2]</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read">read</a>
と
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/read-string">read-string</a>
関数は任意でオプションを指定したマップを第一引数に取ることができる。このオプションマップのキーとバリューで現在のフィーチャーとリーダーコンディショナルの挙動を指定することができる:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">  :read-cond - :allow を指定してリーダーコンディショナルを処理する、もしくは
               :preserve で全てのブランチを保持する。
  :features - 有効なフィーチャーキーワードのパーシスタントセット。</code></pre>
</div>
</div>
<div class="paragraph">
<p>ClojureScriptのリーダーコンデショナルをClojureからテストする例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(read-string
  {:read-cond :allow
   :features #{:cljs}}
  "#?(:cljs :works! :default :boo)")
;; :works!</code></pre>
</div>
</div>
<div class="paragraph">
<p>ただ、Clojureのリーダーは <em>常に</em>
プラットフォームフィーチャーである:cljも注入する点には注意が必要だ。プラットフォームに依存しない読み込みに関しては
<a href="https://github.com/clojure/tools.reader">tools.reader</a>を参照。</p>
</div>
<div class="paragraph">
<p>リーダーが <code>{:read-cond :preserve}</code>
で呼び出された場合、リーダーコンディショナルと未実行の分岐がデータとして保持されたフォームを返す。その場合、リーダーコンディショナルは <code>:form</code>
と <code>:splicing?</code> フラグのキーワード取得をサポートする型として返される。読み込まれたもののスキップされたタグ付きリテラルは <code>:form</code>
<code>:tag</code> のキーによるキーワード取得をサポートする型として返される。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(read-string
  {:read-cond :preserve}
  "[1 2 #?@(:clj [3 4] :cljs [5 6])]")
;; [1 2 #?@(:clj [3 4] :cljs [5 6])]</code></pre>
</div>
</div>
<div class="paragraph">
<p>これらの型の述語やコンストラクタとして以下の関数を使用することができる:<br>
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reader-conditional%3F">reader-conditional?</a>
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reader-conditional">reader-conditional</a>
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/tagged-literal%3F">tagged-literal?</a>
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/tagged-literal">tagged-literal</a></p>
</div>
</div>
</div></p>

<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>

  </body>
</html>