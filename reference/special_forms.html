<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>Clojure - Special Forms</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Clojure の日本語ドキュメントです">
    <meta name="author" content="Japan Clojurians">
    <meta name="keywords" content="Clojure 日本語">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/normalize.css" rel="stylesheet">
    <link href="../css/webflow.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" type="image/x-icon" href="../images/clojure-logo-icon-32.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">Clojure</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              <!-- <li><a href="../about/rationale.html">概要</a></li> -->
            <li><a href="../reference/documentation">リファレンス</a></li>
            <!-- <li><a href="../api/api.html">API</a></li>
              <li><a href="../community/downloads.html">リリース</a></li>
              <li><a href="../guides/guides.html">ガイド</a></li>
              <li><a href="../community/resources.html">コミュニティ</a></li>
              <li><a href="../news/news.html">ニュース</a></li>
              <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
              <li><a href="#">Action</a></li>
              <li><a href="#">Another action</a></li>
              <li><a href="#">Something else here</a></li>
              <li class="divider"></li>
              <li class="dropdown-header">Nav header</li>
              <li><a href="#">Separated link</a></li>
              <li><a href="#">One more separated link</a></li>
              </ul>
              </li> -->
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

<div class="page-header">
  <h1>Special Forms</h1>
</div>

<p><em></em></p>

<p><div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#def">(<em>def</em> symbol init?)</a></li>
<li><a href="#if">(<em>if</em> test then else?)</a></li>
<li><a href="#do">(<em>do</em> exprs*)</a></li>
<li><a href="#let">(<em>let</em> [bindings* ] exprs*)</a></li>
<li><a href="#quote">(<em>quote</em> form)</a></li>
<li><a href="#var">(<em>var</em> symbol)</a></li>
<li><a href="#fn">(<em>fn</em> name? [params* ] exprs*)</a></li>
<li><a href="#__em_fn_em_name_params_exprs">(<em>fn</em> name? ([params* ] exprs*)+)</a></li>
<li><a href="#__em_fn_em_name_params_condition_map_exprs">(<em>fn</em> name? [params* ] condition-map? exprs*)</a></li>
<li><a href="#__em_fn_em_name_params_condition_map_exprs_2">(<em>fn</em> name? ([params* ] condition-map? exprs*)+)</a></li>
<li><a href="#loop">(<em>loop</em> [bindings* ] exprs*)</a></li>
<li><a href="#recur">(<em>recur</em> exprs*)</a></li>
<li><a href="#throw">(<em>throw</em> expr)</a></li>
<li><a href="#try">(<em>try</em> expr* catch-clause* finally-clause?)</a></li>
<li><a href="#monitor-enter">(<em>monitor-enter</em> x)</a></li>
<li><a href="#monitor-exit">(<em>monitor-exit</em> x)</a></li>
<li><a href="#_other_special_forms">Other Special Forms</a></li>
<li><a href="#binding-forms">Binding Forms (Destructuring)</a>
<ul class="sectlevel2">
<li><a href="#_vector_binding_destructuring">Vector binding destructuring</a></li>
<li><a href="#_map_binding_destructuring">Map binding destructuring</a></li>
<li><a href="#_nested_destructuring">Nested destructuring</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="def">(<em>def</em> symbol init?)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Creates and interns or locates a global var with the name of symbol and a namespace of the value of the current namespace (<em><strong>*ns*</strong></em>). If init is supplied, it is evaluated, and the root binding of the var is set to the resulting value. If init is not supplied, the root binding of the var is unaffected. <em><strong>def</strong></em> always applies to the root binding, even if the var is thread-bound at the point where <em><strong>def</strong></em> is called. <em><strong>def</strong></em> yields the var itself <em>(not its value)</em>. Throws an exception if symbol is already in the namespace and not mapped to an interned var. Since 1.3, <em><strong>def</strong></em> has allowed an optional doc-string: (<em>def</em> symbol doc-string? init?).</p>
</div>
<div class="paragraph">
<p>Any metadata on the symbol will be evaluated, and become metadata on the var itself. There are several metadata keys that have special interpretation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em><strong>:private</strong></em></p>
<div class="paragraph">
<p>a boolean indicating the access control for the var. If this key is not present, the default access is public (e.g. as if :private false).</p>
</div>
</li>
<li>
<p><em><strong>:doc</strong></em></p>
<div class="paragraph">
<p>a string containing short (1-3 line) documentation for the var contents</p>
</div>
</li>
<li>
<p><em><strong>:test</strong></em></p>
<div class="paragraph">
<p>a fn of no args that uses assert to check various operations. The var itself will be accessible during evaluation of a literal fn in the metadata map.</p>
</div>
</li>
<li>
<p><em><strong>:tag</strong></em></p>
<div class="paragraph">
<p>a symbol naming a class or a Class object that indicates the Java type of the object in the var, or its return value if the object is a fn.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition the compiler will place the following metadata keys on the var:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em><strong>:file</strong></em> string</p>
</li>
<li>
<p><em><strong>:line</strong></em> int</p>
</li>
<li>
<p><em><strong>:name</strong></em> simple symbol</p>
</li>
<li>
<p><em><strong>:ns</strong></em> namespace in which var is interned</p>
</li>
<li>
<p><em><strong>:macro</strong></em> true if var names a macro</p>
</li>
<li>
<p><em><strong>:arglists</strong></em> a list of vector(s) of argument forms, as were supplied to defn</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The var metadata can be used for application-specific purposes as well. Consider using namespace-qualified keys (e.g. :myns/foo) to avoid clashes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn
 ^{:doc "mymax [xs+] gets the maximum value in xs using &gt; "
   :test (fn []
             (assert (= 42  (mymax 2 42 5 4))))
   :user/comment "this is the best fn ever!"}
  mymax
  ([x] x)
  ([x y] (if (&gt; x y) x y))
  ([x y &amp; more]
   (reduce mymax (mymax x y) more)))

user=&gt; (meta #'mymax)
  {:name mymax,
   :user/comment "this is the best fn ever!",
   :doc "mymax [xs+] gets the maximum value in xs using &gt; ",
   :arglists ([x] [x y] [x y &amp; more])
   :file "repl-1",
   :line 126,
   :ns #&lt;Namespace user &gt;,
   :test #&lt;user$fn__289 user$fn__289@20f443 &gt;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Many macros expand into <em><strong>def</strong></em> (e.g. <em><strong>defn</strong></em>, <em><strong>defmacro</strong></em>), and thus also convey metadata for the resulting var from the symbol used as the name.</p>
</div>
<div class="paragraph">
<p>Using def to modify the root value of a var at other than the top level is usually an indication that you are using the var as a mutable global, and is considered bad style. Consider either using binding to provide a thread-local value for the var, or putting a ref or agent in the var and using transactions or actions for mutation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="if">(<em>if</em> test then else?)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Evaluates test. If not the singular values <strong>nil</strong> or <strong>false</strong>, evaluates and yields then, otherwise, evaluates and yields else. If else is not supplied it defaults to <strong>nil</strong>. All of the other conditionals in Clojure are based upon the same logic, that is, <strong>nil</strong> and <strong>false</strong> constitute logical falsity, and everything else constitutes logical truth, and those meanings apply throughout. <em><strong>if</strong></em> performs conditional tests of boolean Java method return values without conversion to Boolean. Note that <em><strong>if</strong></em> does not test for arbitrary values of java.lang.Boolean, only the singular value <strong>false</strong> (Java&#8217;s Boolean.FALSE), so if you are creating your own boxed Booleans make sure to use Boolean/valueOf and not the Boolean constructors.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="do">(<em>do</em> exprs*)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Evaluates the expressions in order and returns the value of the last. If no expressions are supplied, returns nil.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="let">(<em>let</em> [bindings* ] exprs*)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>binding &#8658; binding-form init-expr</p>
</div>
<div class="paragraph">
<p>Evaluates the exprs in a lexical context in which the symbols in the binding-forms are bound to their respective init-exprs or parts therein. The bindings are sequential, so each binding can see the prior bindings. The exprs are contained in an implicit do. If a binding symbol is annotated with a metadata tag, the compiler will try to resolve the tag to a class name and presume that type in subsequent references to the binding. The simplest binding-form is a symbol, which is bound to the entire init-expr:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [x 1
      y x]
  y)
-&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="special_forms#binding-forms">Binding Forms</a> for more information about binding forms.</p>
</div>
<div class="paragraph">
<p><strong>Locals created with let are not variables. Once created their values never change!</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quote">(<em>quote</em> form)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Yields the unevaluated form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure-repl" data-lang="clojure-repl">user=&gt; '(a b c)
(a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note there is no attempt made to call the function a. The return value is a list of 3 symbols.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="var">(<em>var</em> symbol)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The symbol must resolve to a var, and the Var object itself <em>(not its value)</em> is returned. The reader macro #'x expands to (var x).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fn">(<em>fn</em> name? [params* ] exprs*)</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="__em_fn_em_name_params_exprs">(<em>fn</em> name? ([params* ] exprs*)+)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>params &#8658; positional-params* , or positional-params* &amp; rest-param<br>
positional-param &#8658; binding-form<br>
rest-param &#8658; binding-form<br>
name &#8658; symbol</p>
</div>
<div class="paragraph">
<p>Defines a function (fn). Fns are first-class objects that implement the IFn interface. The IFn interface defines an invoke() function that is overloaded with arity ranging from 0-20. A single fn object can implement one or more invoke methods, and thus be overloaded on arity. One and only one overload can itself be variadic, by specifying the ampersand followed by a single rest-param. Such a variadic entry point, when called with arguments that exceed the positional params, will find them in a seq contained in the rest param. If the supplied args do not exceed the positional params, the rest param will be nil.</p>
</div>
<div class="paragraph">
<p>The first form defines a fn with a single invoke method. The second defines a fn with one or more overloaded invoke methods. The arities of the overloads must be distinct. In either case, the result of the expression is a single fn object.</p>
</div>
<div class="paragraph">
<p>The exprs are compiled in an environment in which the params are bound to the actual arguments. The exprs are enclosed in an implicit do. If a name symbol is provided, it is bound within the function definition to the function object itself, allowing for self-calling, even in anonymous functions. If a param symbol is annotated with a metadata tag, the compiler will try to resolve the tag to a class name and presume that type in subsequent references to the binding.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(def mult
  (fn this
      ([] 1)
      ([x] x)
      ([x y] (* x y))
      ([x y &amp; more]
          (apply this (this x y) more))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that named fns such as mult are normally defined with defn, which expands into something such as the above.</p>
</div>
<div class="paragraph">
<p>A fn (overload) defines a recursion point at the top of the function, with arity equal to the number of params <em>including the rest param, if present</em>. See recur.</p>
</div>
<div class="paragraph">
<p>fns implement the Java Callable, Runnable and Comparator interfaces.</p>
</div>
<div class="paragraph">
<p><strong><em>Since 1.1</em></strong></p>
</div>
<div class="paragraph">
<p>Functions support specifying runtime pre- and postconditions.</p>
</div>
<div class="paragraph">
<p>The syntax for function definitions becomes the following:</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__em_fn_em_name_params_condition_map_exprs">(<em>fn</em> name? [params* ] condition-map? exprs*)</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="__em_fn_em_name_params_condition_map_exprs_2">(<em>fn</em> name? ([params* ] condition-map? exprs*)+)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The syntax extension also applies to defn and other macros which expand to fn forms.</p>
</div>
<div class="paragraph">
<p>Note: If the sole form following the parameter vector is a map, it is treated as the function body, and not the condition map.</p>
</div>
<div class="paragraph">
<p>The condition-map parameter may be used to specify pre- and postconditions for a function. It is of the following form:</p>
</div>
<div class="paragraph">
<p>{:pre [pre-expr*]<br>
:post [post-expr*]}</p>
</div>
<div class="paragraph">
<p>where either key is optional. The condition map may also be provided as metadata of the arglist.</p>
</div>
<div class="paragraph">
<p><strong>pre-expr</strong> and <strong>post-expr</strong> are boolean expressions that may refer to the parameters of the function. In addition, <strong>%</strong> may be used in a post-expr to refer to the function&#8217;s return value. If any of the conditions evaluate to false and <strong>*assert*</strong> is true, an assertion failure exception is thrown.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn constrained-sqr [x]
    {:pre  [(pos? x)]
     :post [(&gt; % 16), (&lt; % 225)]}
    (* x x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="special_forms#binding-forms">Binding Forms</a> for more information about binding forms.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="loop">(<em>loop</em> [bindings* ] exprs*)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>loop is exactly like let, except that it establishes a recursion point at the top of the loop, with arity equal to the number of bindings. See recur.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="recur">(<em>recur</em> exprs*)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Evaluates the exprs in order, then, in parallel, rebinds the bindings of the recursion point to the values of the exprs. If the recursion point was a fn method, then it rebinds the params. If the recursion point was a loop, then it rebinds the loop bindings. Execution then jumps back to the recursion point. The recur expression must match the arity of the recursion point exactly. In particular, if the recursion point was the top of a variadic fn method, there is no gathering of rest args - a single seq (or null) should be passed. recur in other than a tail position is an error.</p>
</div>
<div class="paragraph">
<p>Note that recur is the only non-stack-consuming looping construct in Clojure. There is no tail-call optimization and the use of self-calls for looping of unknown bounds is discouraged. recur is functional and its use in tail-position is verified by the compiler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(def factorial
  (fn [n]
    (loop [cnt n acc 1]
       (if (zero? cnt)
            acc
          (recur (dec cnt) (* acc cnt))))))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="throw">(<em>throw</em> expr)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The expr is evaluated and thrown, therefore it should yield an instance of some derivee of Throwable.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="try">(<em>try</em> expr* catch-clause* finally-clause?)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>catch-clause &#8594; (<em>catch</em> classname name expr*)<br>
finally-clause &#8594; (<em>finally</em> expr*)</p>
</div>
<div class="paragraph">
<p>The exprs are evaluated and, if no exceptions occur, the value of the last is returned. If an exception occurs and catch clauses are provided, each is examined in turn and the first for which the thrown exception is an instance of the named class is considered a matching catch clause. If there is a matching catch clause, its exprs are evaluated in a context in which name is bound to the thrown exception, and the value of the last is the return value of the function. If there is no matching catch clause, the exception propagates out of the function. Before returning, normally or abnormally, any finally exprs will be evaluated for their side effects.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="monitor-enter">(<em>monitor-enter</em> x)</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="monitor-exit">(<em>monitor-exit</em> x)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>These are synchronization primitives that should be avoided in user code. Use the <em><strong>locking</strong></em> macro.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_special_forms">Other Special Forms</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a id="."></a>
<a id="new"></a>
The special forms <a href="java_interop#dot">dot ('.')</a>, <a href="java_interop#new">new</a>, and <a href="java_interop#set">set!</a> of fields are described in the <a href="java_interop">Java Interop</a> section of the reference.</p>
</div>
<div class="paragraph">
<p><a id="set!"></a>
<a href="vars#set%21">set!</a> of vars is described in the <a href="vars">Vars</a> section of the reference.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="binding-forms">Binding Forms (Destructuring)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clojure supports abstract structural binding, often called destructuring, in let binding lists, fn parameter lists, and any macro that expands into a let or fn. The basic idea is that a binding-form can be a data structure literal containing symbols that get bound to the respective parts of the init-expr. The binding is abstract in that a vector literal can bind to anything that is sequential, while a map literal can bind to anything that is associative.</p>
</div>
<div class="sect2">
<h3 id="_vector_binding_destructuring">Vector binding destructuring</h3>
<div class="paragraph">
<p>Vector binding-exprs allow you to bind names to parts of <em>sequential</em> things (not just vectors), like vectors, lists, seqs, strings, arrays, and anything that supports nth. The basic sequential form is a vector of binding-forms, which will be bound to successive elements from the init-expr, looked up via nth. In addition, and optionally, &amp; followed by a binding-forms will cause that binding-form to be bound to the remainder of the sequence, i.e. that part not yet bound, looked up via <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nthnext">nthnext</a> .</p>
</div>
<div class="paragraph">
<p>Finally, also optional, :as followed by a symbol will cause that symbol to be bound to the entire init-expr:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [[a b c &amp; d :as e] [1 2 3 4 5 6 7]]
  [a b c d e])

-&gt;[1 2 3 (4 5 6 7) [1 2 3 4 5 6 7]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>These forms can be nested:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [[[x1 y1][x2 y2]] [[1 2] [3 4]]]
  [x1 y1 x2 y2])

-&gt;[1 2 3 4]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Strings work too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [[a b &amp; c :as str] "asdjhhfdas"]
  [a b c str])

-&gt;[\a \s (\d \j \h \h \f \d \a \s) "asdjhhfdas"]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_map_binding_destructuring">Map binding destructuring</h3>
<div class="paragraph">
<p>Map binding-forms allow you to bind names to parts of <em>associative</em> things (not just maps), like maps, vectors, string and arrays (the latter three have integer keys). It consists of a map of binding-form-key pairs, each symbol being bound to the value in the init-expr at the key. In addition, and optionally, an <em><strong>:as</strong></em> key in the binding form followed by a symbol will cause that symbol to be bound to the entire init-expr. Also optionally, an <em><strong>:or</strong></em> key in the binding form followed by another map may be used to supply default values for some or all of the keys if they are not found in the init-expr:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [{a :a, b :b, c :c, :as m :or {a 2 b 3}}  {:a 5 :c 6}]
  [a b c m])

-&gt;[5 3 6 {:c 6, :a 5}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is often the case that you will want to bind same-named symbols to the map keys. The <em><strong>:keys</strong></em> directive allows you to avoid the redundancy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [{fred :fred ethel :ethel lucy :lucy} m] ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [{:keys [fred ethel lucy]} m] ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>As of Clojure 1.6, you can also use prefixed map keys in the map destructuring form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [m {:x/a 1, :y/b 2}
      {:keys [x/a y/b]} m]
  (+ a b))

-&gt; 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case of using prefixed keys, the bound symbol name will be the same as the right-hand side of the prefixed key. You can also use auto-resolved keyword forms in the <em><strong>:keys</strong></em> directive:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [m {::x 42}
      {:keys [::x]} m]
  x)

-&gt; 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are similar <em><strong>:strs</strong></em> and <em><strong>:syms</strong></em> directives for matching string and symbol keys, the latter also allowing prefixed symbol keys since Clojure 1.6.</p>
</div>
<div class="paragraph">
<p>Clojure 1.9 adds support for directly destructuring many keys (or symbols) that share the same namespace using the following destructuring key forms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:<em>ns</em>/keys</code> - <em>ns</em> specifies the default namespace for the key to look up in the input</p>
<div class="ulist">
<ul>
<li>
<p>keys elements should not specify a namespace</p>
</li>
<li>
<p>keys elements also define new local symbols, as with :keys</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>:<em>ns</em>/syms</code> - <em>ns</em> specifies the default namespace for the symbol to look up in the input</p>
<div class="ulist">
<ul>
<li>
<p>syms elements should not specify a namespace</p>
</li>
<li>
<p>syms elements also define new local symbols, as with :syms</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [m #:domain{:a 1, :b 2}
      {:domain/keys [a b]} m]
  [a b])

-&gt; [1 2]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nested_destructuring">Nested destructuring</h3>
<div class="paragraph">
<p>Since binding forms can be nested within one another arbitrarily, you can pull apart just about anything:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(let [{j :j, k :k, i :i, [r s &amp; t :as v] :ivec, :or {i 12 j 13}}
      {:j 15 :k 16 :ivec [22 23 24 25]}]
  [i j k r s t v])

-&gt; [12 15 16 22 23 (24 25) [22 23 24 25]]</code></pre>
</div>
</div>
</div>
</div>
</div></p>

<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>

  </body>
</html>